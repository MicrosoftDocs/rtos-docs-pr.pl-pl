---
title: Rozdział 1 — Omówienie usługi Azure RTO LevelX
description: Usługa Azure RTO LevelX zapewnia ni i lub Flash funkcje do wyrównywania zużycia w aplikacjach osadzonych.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 045446fec74164f125bc0ad27e8b7a904be14ab2
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/22/2021
ms.locfileid: "104822177"
---
# <a name="chapter-1---overview-of-azure-rtos-levelx"></a><span data-ttu-id="e1e40-103">Rozdział 1 — Omówienie usługi Azure RTO LevelX</span><span class="sxs-lookup"><span data-stu-id="e1e40-103">Chapter 1 - Overview of Azure RTOS LevelX</span></span>

<span data-ttu-id="e1e40-104">Usługa Azure RTO LevelX zapewnia ni i lub Flash funkcje do wyrównywania zużycia w aplikacjach osadzonych.</span><span class="sxs-lookup"><span data-stu-id="e1e40-104">Azure RTOS LevelX provides NAND and NOR flash wear leveling facilities to embedded applications.</span></span> <span data-ttu-id="e1e40-105">Ponieważ zarówno ni, jak i lub flash pamięci można wymazać tylko przez wiele razy, ma krytyczne znaczenie dla równomiernego dystrybuowania pamięci flash.</span><span class="sxs-lookup"><span data-stu-id="e1e40-105">Since both NAND and NOR flash memory can only be erased a finite number of times, it's critical to distribute the flash memory use evenly.</span></span> <span data-ttu-id="e1e40-106">Jest to zwykle nazywane "bilansowaniem" i jest celem za LevelX.</span><span class="sxs-lookup"><span data-stu-id="e1e40-106">This is typically called "wear leveling" and is the purpose behind LevelX.</span></span>

<span data-ttu-id="e1e40-107">Algorytm wybierający, który blok Flash do ponownego użycia jest przede wszystkim oparty na liczbie wymazywania, ale nie w całości.</span><span class="sxs-lookup"><span data-stu-id="e1e40-107">The algorithm that chooses which flash block to reuse is primarily based on the erase count, but not entirely.</span></span> <span data-ttu-id="e1e40-108">Blok o najmniejszej liczbie wymazywań może nie zostać wybrany, jeśli istnieje inny blok, który ma liczbę wymazywań w akceptowalnej wartości delta z minimalnej liczby wymazywań i ma większą liczbę przestarzałych mapowań.</span><span class="sxs-lookup"><span data-stu-id="e1e40-108">The block with the lowest erase count might not be chosen if there is another block that has an erase count within an acceptable delta from the minimal erase count and that has a greater number of obsolete mappings.</span></span> <span data-ttu-id="e1e40-109">W takich przypadkach blok o największej liczbie przestarzałych mapowań zostanie wymazany i ponownie użyty, co spowoduje oszczędności wynikające z przeniesienia prawidłowych wpisów mapowania.</span><span class="sxs-lookup"><span data-stu-id="e1e40-109">In such cases, the block with the greatest number of obsolete mappings will be erased and reused, thus saving overhead in moving valid mapping entries.</span></span>

<span data-ttu-id="e1e40-110">LevelX obsługuje wiele wystąpień ni i/lub lub części, tj. aplikacja może korzystać z oddzielnych wystąpień LevelX w ramach tej samej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e1e40-110">LevelX supports multiple instances of NAND and/or NOR parts, i.e., the application can utilize separate instances of LevelX within the same application.</span></span> <span data-ttu-id="e1e40-111">Każde wystąpienie wymaga własnego bloku kontroli dostarczonego przez aplikację oraz własnego sterownika Flash.</span><span class="sxs-lookup"><span data-stu-id="e1e40-111">Each instance requires its own control block provided by the application as well as its own flash driver.</span></span>

<span data-ttu-id="e1e40-112">LevelX przedstawia użytkownikowi tablicę sektorów logicznych, które są mapowane na fizyczną pamięć flash wewnątrz LevelX.</span><span class="sxs-lookup"><span data-stu-id="e1e40-112">LevelX presents to the user an array of logical sectors that are mapped to physical flash memory inside of LevelX.</span></span> <span data-ttu-id="e1e40-113">Aby zwiększyć wydajność, LevelX udostępnia również pamięć podręczną najnowszych mapowań sektora logicznego.</span><span class="sxs-lookup"><span data-stu-id="e1e40-113">To enhance performance, LevelX also provides a cache of the most recent logical sector mappings.</span></span> <span data-ttu-id="e1e40-114">Rozmiar tej pamięci podręcznej jest definiowany przez programistę.</span><span class="sxs-lookup"><span data-stu-id="e1e40-114">The size of this cache is defined by the programmer.</span></span> <span data-ttu-id="e1e40-115">Aplikacje mogą używać LevelX w połączeniu z FileX lub mogą bezpośrednio odczytywać i zapisywać sektory logiczne.</span><span class="sxs-lookup"><span data-stu-id="e1e40-115">Applications may use LevelX in conjunction with FileX or may read/write logical sectors directly.</span></span> <span data-ttu-id="e1e40-116">LevelX nie ma zależności od FileX i bardzo mało zależności od ThreadX (używane są tylko pierwotne typy danych ThreadX).</span><span class="sxs-lookup"><span data-stu-id="e1e40-116">LevelX has no dependency on FileX and very little dependency on ThreadX (only primitive ThreadX data types are used).</span></span>

<span data-ttu-id="e1e40-117">LevelX jest zaprojektowana pod kątem odporności na uszkodzenia.</span><span class="sxs-lookup"><span data-stu-id="e1e40-117">LevelX is designed for fault tolerance.</span></span> <span data-ttu-id="e1e40-118">Aktualizacje programu Flash są wykonywane w procesie wieloetapowym, który można przerwać w każdym kroku.</span><span class="sxs-lookup"><span data-stu-id="e1e40-118">Flash updates are performed in a multiple-step process that can be interrupted in each step.</span></span> <span data-ttu-id="e1e40-119">LevelX automatycznie przywraca optymalny stan podczas kolejnej operacji.</span><span class="sxs-lookup"><span data-stu-id="e1e40-119">LevelX automatically recovers to the optimal state during the next operation.</span></span>

<span data-ttu-id="e1e40-120">LevelX wymaga sterownika Flash do fizycznego dostępu do źródłowej pamięci flash.</span><span class="sxs-lookup"><span data-stu-id="e1e40-120">LevelX requires a flash driver for physical access to the underlying flash memory.</span></span> <span data-ttu-id="e1e40-121">Przykłady ni i i symulowanych sterowników są dostarczane i mogą być używane jako dobry punkt wyjścia do implementowania rzeczywistych sterowników LevelX.</span><span class="sxs-lookup"><span data-stu-id="e1e40-121">Example NAND and NOR simulated drivers are provided and can be used as a good starting point for implementing actual LevelX drivers.</span></span> <span data-ttu-id="e1e40-122">Ponadto wymagania dotyczące sterowników są szczegółowo opisane w dalszej części tej dokumentacji.</span><span class="sxs-lookup"><span data-stu-id="e1e40-122">In addition, driver requirements are detailed later in this documentation.</span></span>

<span data-ttu-id="e1e40-123">W poniższych tematach opisano operację funkcjonalną dla ni i LevelX.</span><span class="sxs-lookup"><span data-stu-id="e1e40-123">The following chapters describe the functional operation for the NAND and NOR LevelX support.</span></span>
