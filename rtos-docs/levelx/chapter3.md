---
title: Obsługa usługi Azure RTO LevelX ni
description: NI pamięć flash jest często używana w LevelX w przypadku dużych magazynów danych, które są typowymi systemami plików.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 3286e4ea7f16b28ff55fc95a87a1e0c313ec4240
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/22/2021
ms.locfileid: "104822171"
---
# <a name="chapter-3---azure-rtos-levelx-nand-support"></a><span data-ttu-id="de12d-103">Rozdział 3 — Obsługa platformy Azure RTO LevelX ni</span><span class="sxs-lookup"><span data-stu-id="de12d-103">Chapter 3 - Azure RTOS LevelX NAND support</span></span>

<span data-ttu-id="de12d-104">NI pamięć flash jest często wykorzystywana w przypadku dużych magazynów danych, które są typowymi systemami plików.</span><span class="sxs-lookup"><span data-stu-id="de12d-104">NAND flash memory is commonly utilized for large data storage, which is typical of file systems.</span></span> <span data-ttu-id="de12d-105">Pamięć ni składa się z *bloków*.</span><span class="sxs-lookup"><span data-stu-id="de12d-105">NAND memory consists of *blocks*.</span></span> <span data-ttu-id="de12d-106">W każdym bloku ni jest serią *stron*.</span><span class="sxs-lookup"><span data-stu-id="de12d-106">Within each NAND block is a series of *pages*.</span></span> <span data-ttu-id="de12d-107">Bloki ni są wymazywane, co oznacza, że wszystkie strony w bloku ni są wymazywane (ustawiane na wszystkie).</span><span class="sxs-lookup"><span data-stu-id="de12d-107">NAND blocks are erasable, which means that all pages within the NAND block are erased (set to all ones).</span></span> <span data-ttu-id="de12d-108">Każda Strona bloku ni ma zestaw *bajtów zapasowych* , które są używane przez usługę Azure RTO LevelX do księgowania, niewłaściwego zarządzania blokami i wykrywania błędów.</span><span class="sxs-lookup"><span data-stu-id="de12d-108">Each NAND block page has a set of *spare bytes* that are utilized by Azure RTOS LevelX for bookkeeping, bad block management, and error detection.</span></span> <span data-ttu-id="de12d-109">Strony blokowe ni są dostępne w różnych rozmiarach.</span><span class="sxs-lookup"><span data-stu-id="de12d-109">NAND block pages are available in a variety of sizes.</span></span> <span data-ttu-id="de12d-110">Najczęstsze rozmiary stron to:</span><span class="sxs-lookup"><span data-stu-id="de12d-110">The most common page sizes are:</span></span> 

| <span data-ttu-id="de12d-111">**Rozmiar strony**</span><span class="sxs-lookup"><span data-stu-id="de12d-111">**Page Size**</span></span> | <span data-ttu-id="de12d-112">**Bajty zapasowe**</span><span class="sxs-lookup"><span data-stu-id="de12d-112">**Spare Bytes**</span></span> |
| ------------- | --------------- |
| <span data-ttu-id="de12d-113">256</span><span class="sxs-lookup"><span data-stu-id="de12d-113">256</span></span>           | <span data-ttu-id="de12d-114">8</span><span class="sxs-lookup"><span data-stu-id="de12d-114">8</span></span>               |
| <span data-ttu-id="de12d-115">512</span><span class="sxs-lookup"><span data-stu-id="de12d-115">512</span></span>           | <span data-ttu-id="de12d-116">16</span><span class="sxs-lookup"><span data-stu-id="de12d-116">16</span></span>              |
| <span data-ttu-id="de12d-117">2048</span><span class="sxs-lookup"><span data-stu-id="de12d-117">2048</span></span>          | <span data-ttu-id="de12d-118">64</span><span class="sxs-lookup"><span data-stu-id="de12d-118">64</span></span>              |

<span data-ttu-id="de12d-119">Pamięć ni różni się od programu lub pamięci, w której nie ma bezpośredniego dostępu, czyli nie można odczytać pamięci ni bezpośrednio z procesora, takiego jak lub pamięci.</span><span class="sxs-lookup"><span data-stu-id="de12d-119">NAND memory differs from NOR memory in that there is no direct access, i.e., NAND memory cannot be read directly from the processor like NOR memory.</span></span> <span data-ttu-id="de12d-120">Pamięć ni można zapisywać tylko po wymazaniu ograniczonej liczby razy.</span><span class="sxs-lookup"><span data-stu-id="de12d-120">NAND memory can only be written to after an erase a limited number of times.</span></span> <span data-ttu-id="de12d-121">Ponownie różni się od programu lub pamięci, które mogą być pisane nieograniczoną liczbę razy, gdy żądanie zapisu jest czyszczone.</span><span class="sxs-lookup"><span data-stu-id="de12d-121">Again, this differs from NOR memory that can be written an unlimited number of times providing the write request is clearing set bits.</span></span> <span data-ttu-id="de12d-122">Na koniec bajty zapasowe skojarzone z każdą stroną są unikatowe dla ni Flash.</span><span class="sxs-lookup"><span data-stu-id="de12d-122">Finally, the spare bytes associated with each page are unique to NAND flash.</span></span> <span data-ttu-id="de12d-123">Typowe konfiguracje zapasowych bajtów są przedstawione w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="de12d-123">Typical spare byte configurations are as shown in the table below.</span></span>

| <span data-ttu-id="de12d-124">**Bajty zapasowe**</span><span class="sxs-lookup"><span data-stu-id="de12d-124">**Spare Bytes**</span></span> | <span data-ttu-id="de12d-125">**Liczby bajtów**</span><span class="sxs-lookup"><span data-stu-id="de12d-125">**Byte numbers**</span></span> | <span data-ttu-id="de12d-126">**Konfiguracja**</span><span class="sxs-lookup"><span data-stu-id="de12d-126">**Configuration**</span></span>     |
| ------------------------- | -------------- | --------------------- |
| <span data-ttu-id="de12d-127">8</span><span class="sxs-lookup"><span data-stu-id="de12d-127">8</span></span>                         | <span data-ttu-id="de12d-128">Bajty 0-2:</span><span class="sxs-lookup"><span data-stu-id="de12d-128">Bytes 0-2:</span></span>     | <span data-ttu-id="de12d-129">Bajty ECC</span><span class="sxs-lookup"><span data-stu-id="de12d-129">ECC bytes</span></span>             |
|                           | <span data-ttu-id="de12d-130">Bajty 3, 4, 6, 7:</span><span class="sxs-lookup"><span data-stu-id="de12d-130">Bytes 3,4,6,7:</span></span> | <span data-ttu-id="de12d-131">Mapowanie sektora LevelX</span><span class="sxs-lookup"><span data-stu-id="de12d-131">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="de12d-132">Bajt 5:</span><span class="sxs-lookup"><span data-stu-id="de12d-132">Byte 5:</span></span>        | <span data-ttu-id="de12d-133">Zła flaga bloku</span><span class="sxs-lookup"><span data-stu-id="de12d-133">Bad block flag</span></span>        |
| <span data-ttu-id="de12d-134">16</span><span class="sxs-lookup"><span data-stu-id="de12d-134">16</span></span>                        | <span data-ttu-id="de12d-135">Bajty 0-3, 6-7:</span><span class="sxs-lookup"><span data-stu-id="de12d-135">Bytes 0-3,6-7:</span></span> | <span data-ttu-id="de12d-136">Bajty ECC</span><span class="sxs-lookup"><span data-stu-id="de12d-136">ECC bytes</span></span>             |
|                           | <span data-ttu-id="de12d-137">Bajty 8-11:</span><span class="sxs-lookup"><span data-stu-id="de12d-137">Bytes 8-11:</span></span>    | <span data-ttu-id="de12d-138">Mapowanie sektora LevelX</span><span class="sxs-lookup"><span data-stu-id="de12d-138">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="de12d-139">Bajty 12-15:</span><span class="sxs-lookup"><span data-stu-id="de12d-139">Bytes 12-15:</span></span>   | <span data-ttu-id="de12d-140">Nieużywane</span><span class="sxs-lookup"><span data-stu-id="de12d-140">Unused</span></span>                |
|                           | <span data-ttu-id="de12d-141">Bajt 5:</span><span class="sxs-lookup"><span data-stu-id="de12d-141">Byte 5:</span></span>        | <span data-ttu-id="de12d-142">Zła flaga bloku</span><span class="sxs-lookup"><span data-stu-id="de12d-142">Bad block flag</span></span>        |
| <span data-ttu-id="de12d-143">64</span><span class="sxs-lookup"><span data-stu-id="de12d-143">64</span></span>                        | <span data-ttu-id="de12d-144">Bajt 0:</span><span class="sxs-lookup"><span data-stu-id="de12d-144">Byte 0:</span></span>        | <span data-ttu-id="de12d-145">Zła flaga bloku</span><span class="sxs-lookup"><span data-stu-id="de12d-145">Bad block flag</span></span>        |
|                           | <span data-ttu-id="de12d-146">Bajty 2-5:</span><span class="sxs-lookup"><span data-stu-id="de12d-146">Bytes 2-5:</span></span>     | <span data-ttu-id="de12d-147">Mapowanie sektora LevelX</span><span class="sxs-lookup"><span data-stu-id="de12d-147">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="de12d-148">Bajty 6-39:</span><span class="sxs-lookup"><span data-stu-id="de12d-148">Bytes 6-39:</span></span>    | <span data-ttu-id="de12d-149">Nieużywane</span><span class="sxs-lookup"><span data-stu-id="de12d-149">Unused</span></span>                |
|                           | <span data-ttu-id="de12d-150">Bajty 40-63:</span><span class="sxs-lookup"><span data-stu-id="de12d-150">Bytes 40-63:</span></span>   | <span data-ttu-id="de12d-151">Bajty ECC</span><span class="sxs-lookup"><span data-stu-id="de12d-151">ECC bytes</span></span>             |

<span data-ttu-id="de12d-152">LevelX wykorzystuje 4 zapasowe bajty każdej strony ni do śledzenia sektora logicznego zamapowanego na fizyczną stronę ni.</span><span class="sxs-lookup"><span data-stu-id="de12d-152">LevelX Utilizes 4 of the spare bytes of each NAND page for keeping track of the logical sector mapped to the physical NAND page.</span></span> <span data-ttu-id="de12d-153">Te 4 bajty są używane do implementacji 32-bitową liczbę całkowitą bez znaku przy użyciu zastrzeżonego formatu LevelX.</span><span class="sxs-lookup"><span data-stu-id="de12d-153">These 4 bytes are used to implement a 32-bit unsigned integer with a LevelX proprietary format.</span></span> <span data-ttu-id="de12d-154">Górny bit pola 32-bitowego (bit 31) jest używany do wskazania, że mapowanie sektora logicznego na stronę jest prawidłowe.</span><span class="sxs-lookup"><span data-stu-id="de12d-154">The upper bit of the 32-bit field (bit 31) is used to indicate the logical sector-to-page mapping is valid.</span></span> <span data-ttu-id="de12d-155">Jeśli ten bit ma wartość 0, informacje na tej stronie nie są już prawidłowe.</span><span class="sxs-lookup"><span data-stu-id="de12d-155">If this bit is 0, the information in this page is no longer valid.</span></span> <span data-ttu-id="de12d-156">Następny bit — bit 30 — służy do wskazywania, że ta strona jest w toku, a nowy sektor jest zapisywany.</span><span class="sxs-lookup"><span data-stu-id="de12d-156">The next bit—bit 30—is used to indicate this page is in the process of becoming obsolete and a new sector is being written.</span></span> <span data-ttu-id="de12d-157">Bit 29 służy do wskazania, kiedy zapis mapowania jest zakończony.</span><span class="sxs-lookup"><span data-stu-id="de12d-157">Bit 29 is used to indicate when the mapping entry write is complete.</span></span> <span data-ttu-id="de12d-158">Jeśli bit 29 ma wartość 0, zakończono zapisywanie wpisu mapowania.</span><span class="sxs-lookup"><span data-stu-id="de12d-158">If bit 29 is 0, the mapping entry write is complete.</span></span> <span data-ttu-id="de12d-159">Jeśli ustawiono bit 29, wpis mapowania był w trakcie zapisywania.</span><span class="sxs-lookup"><span data-stu-id="de12d-159">If bit 29 is set, the mapping entry was in the process of being written.</span></span> <span data-ttu-id="de12d-160">Bity 30 i 29 są używane podczas odzyskiwania po potencjalnej utracie mocy podczas aktualizowania nowej strony Flash.</span><span class="sxs-lookup"><span data-stu-id="de12d-160">Bits 30 and 29 are used in recovering from a potential power loss while updating a new flash page.</span></span> <span data-ttu-id="de12d-161">Na koniec niższa 29 bitów (28-0) zawiera numer sektora logicznego dla strony.</span><span class="sxs-lookup"><span data-stu-id="de12d-161">Finally, the lower 29-bits (28-0) contain the logical sector number for the page.</span></span>

<span data-ttu-id="de12d-162">**LevelX — wpis mapowania**</span><span class="sxs-lookup"><span data-stu-id="de12d-162">**LevelX Mapping Entry**</span></span>

| <span data-ttu-id="de12d-163">Liczba bitów:</span><span class="sxs-lookup"><span data-stu-id="de12d-163">Bit(s)</span></span> | <span data-ttu-id="de12d-164">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="de12d-164">Meaning</span></span> |
| ------ | ------- |
| <span data-ttu-id="de12d-165">31</span><span class="sxs-lookup"><span data-stu-id="de12d-165">31</span></span>     | <span data-ttu-id="de12d-166">Prawidłowa flaga.</span><span class="sxs-lookup"><span data-stu-id="de12d-166">Valid flag.</span></span> <span data-ttu-id="de12d-167">Gdy zestaw i sektor logiczny nie są wszystkie, oznacza to, że mapowanie jest prawidłowe</span><span class="sxs-lookup"><span data-stu-id="de12d-167">When set and logical sector is not all ones indicates mapping is valid</span></span> |
| <span data-ttu-id="de12d-168">30</span><span class="sxs-lookup"><span data-stu-id="de12d-168">30</span></span>     | <span data-ttu-id="de12d-169">Flaga przestarzała.</span><span class="sxs-lookup"><span data-stu-id="de12d-169">Obsolete flag.</span></span> <span data-ttu-id="de12d-170">Po wyczyszczeniu to mapowanie jest przestarzałe lub jest w stanie przestarzałe.</span><span class="sxs-lookup"><span data-stu-id="de12d-170">When clear, this mapping is either obsolete or is in the process of becoming obsolete.</span></span> |
| <span data-ttu-id="de12d-171">29</span><span class="sxs-lookup"><span data-stu-id="de12d-171">29</span></span>     | <span data-ttu-id="de12d-172">Zapis mapowania wpisu jest zakończony, gdy ten bit ma wartość 0</span><span class="sxs-lookup"><span data-stu-id="de12d-172">Mapping entry write is complete when this bit is 0</span></span> |
| <span data-ttu-id="de12d-173">0-28</span><span class="sxs-lookup"><span data-stu-id="de12d-173">0-28</span></span>   | <span data-ttu-id="de12d-174">Sektor logiczny zmapowany na Tę stronę fizyczną — gdy nie wszystkie te.</span><span class="sxs-lookup"><span data-stu-id="de12d-174">Logical sector mapped to this physical page—when not all ones.</span></span> |

<span data-ttu-id="de12d-175">LevelX używa również pierwszej strony każdego bloku ni dla liczby wymazywania bloku oraz listy mapowanych stron, gdy blok jest pełny.</span><span class="sxs-lookup"><span data-stu-id="de12d-175">LevelX also utilizes the first page of each NAND block for the block erase count as well as the list of mapped pages when the block is full.</span></span> <span data-ttu-id="de12d-176">Poniżej przedstawiono format pierwszej strony bloku ni w LevelX:</span><span class="sxs-lookup"><span data-stu-id="de12d-176">The format of the first page of a NAND block in LevelX is shown below:</span></span>

| <span data-ttu-id="de12d-177">LevelX bloku strony 0</span><span class="sxs-lookup"><span data-stu-id="de12d-177">LevelX Block Page 0 Format</span></span> |
|:--------------------------:|
| <span data-ttu-id="de12d-178">[Liczba wymazanych bloków]</span><span class="sxs-lookup"><span data-stu-id="de12d-178">[Block Erase Count]</span></span>        |
| <span data-ttu-id="de12d-179">[Mapowanie sektorów strony 1]</span><span class="sxs-lookup"><span data-stu-id="de12d-179">[Page 1 Sector Mapping]</span></span>    |
| <span data-ttu-id="de12d-180">...</span><span class="sxs-lookup"><span data-stu-id="de12d-180">...</span></span>                        |
| <span data-ttu-id="de12d-181">Mapowanie sektora [Strona "n"]</span><span class="sxs-lookup"><span data-stu-id="de12d-181">[Page "n" Sector Mapping]</span></span>  |
| <span data-ttu-id="de12d-182">[0xF0F0F0F0]</span><span class="sxs-lookup"><span data-stu-id="de12d-182">[0xF0F0F0F0]</span></span>               |

> [!NOTE]
> <span data-ttu-id="de12d-183">Informacje o mapowaniu stron są zapisywane tylko wtedy, gdy blok jest pełny, tj. wszystkie strony bloku zostały zapisaną w.</span><span class="sxs-lookup"><span data-stu-id="de12d-183">The page mapping information is only written when the block is full, i.e., all the pages of the block have been written to.</span></span> <span data-ttu-id="de12d-184">Umożliwia to szybsze wyszukiwanie bezpłatnych stron i mapowań sektorów logicznych w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="de12d-184">This enables faster search for free pages and logical sector mapping during run-time.</span></span>

## <a name="nand-bad-block-support"></a><span data-ttu-id="de12d-185">Obsługa nieprawidłowego bloku ni</span><span class="sxs-lookup"><span data-stu-id="de12d-185">NAND Bad Block Support</span></span>

<span data-ttu-id="de12d-186">Pamięć ni jest również prawdopodobnie nieprawidłowymi blokadami lub pamięcią.</span><span class="sxs-lookup"><span data-stu-id="de12d-186">NAND memory is also more likely to have bad blocks than NOR memory.</span></span> <span data-ttu-id="de12d-187">Jest to bardzo duże działanie, ponieważ ni producenci mogą zwiększyć wzrost, umożliwiając korzystanie z nieprawidłowych bloków i wymaganie, aby oprogramowanie działało w przypadku takich nieprawidłowych bloków.</span><span class="sxs-lookup"><span data-stu-id="de12d-187">This is largely because NAND manufacturers can increase yield by allowing bad blocks and requiring software to work-around such bad blocks.</span></span> <span data-ttu-id="de12d-188">LevelX obsługuje ni niewłaściwe zarządzanie blokami przez proste mapowanie wokół nieprawidłowych bloków.</span><span class="sxs-lookup"><span data-stu-id="de12d-188">LevelX handles NAND bad block management by simply mapping around bad blocks.</span></span>

<span data-ttu-id="de12d-189">Program LevelX udostępnia również interfejsy API dla 256-bajtowych kodów korekcji błędów (ECC) dla podstawowego sterownika LevelX, które będą używane do obliczania nowych kodów ECC lub w celu przeprowadzenia 1-bitowej korekcji błędów podczas odczytywania stron w każdej sekcji 256-bajtowej strony.</span><span class="sxs-lookup"><span data-stu-id="de12d-189">LevelX also provides APIs for 256-byte Hamming Error Correction Codes (ECC) for the underlying LevelX driver to utilize for calculating new ECC codes or to perform 1-bit error correction on page reading within each 256-byte section of the page.</span></span>

## <a name="nand-driver-requirements"></a><span data-ttu-id="de12d-190">Wymagania dotyczące sterownika ni</span><span class="sxs-lookup"><span data-stu-id="de12d-190">NAND Driver Requirements</span></span>

<span data-ttu-id="de12d-191">LevelX wymaga podstawowego sterownika Flash ni, który jest specyficzny dla bazowej części Flash i implementacji sprzętowej.</span><span class="sxs-lookup"><span data-stu-id="de12d-191">LevelX requires an underlying NAND flash driver that is specific to the underlying flash part and hardware implementation.</span></span> <span data-ttu-id="de12d-192">Sterownik jest określany do LevelX podczas inicjowania za pośrednictwem interfejsu API ***lx_nand_flash_open***.</span><span class="sxs-lookup"><span data-stu-id="de12d-192">The driver is specified to LevelX during initialization via the API ***lx_nand_flash_open***.</span></span> <span data-ttu-id="de12d-193">Prototyp sterownika LevelX jest następujący.</span><span class="sxs-lookup"><span data-stu-id="de12d-193">The prototype of the LevelX driver is as follows.</span></span>

```c
INT nand_driver_initialize(LX_NAND_FLASH *instance);
```

<span data-ttu-id="de12d-194">Parametr *instance* określa blok sterowania LevelX ni.</span><span class="sxs-lookup"><span data-stu-id="de12d-194">The *instance* parameter specifies the LevelX NAND control block.</span></span> <span data-ttu-id="de12d-195">Funkcja inicjowania sterownika jest odpowiedzialna za konfigurowanie wszystkich innych usług na poziomie sterowników dla skojarzonego wystąpienia LevelX.</span><span class="sxs-lookup"><span data-stu-id="de12d-195">The driver initialization function is responsible for setting up all the other driver-level services for the associated LevelX instance.</span></span> <span data-ttu-id="de12d-196">Na poniższej liście przedstawiono usługi wymagane przez każde wystąpienie LevelX ni.</span><span class="sxs-lookup"><span data-stu-id="de12d-196">The services required for each LevelX NAND instance are shown in the list below.</span></span>

- <span data-ttu-id="de12d-197">Strona odczytu</span><span class="sxs-lookup"><span data-stu-id="de12d-197">Read Page</span></span>
- <span data-ttu-id="de12d-198">Strona zapisu</span><span class="sxs-lookup"><span data-stu-id="de12d-198">Write Page</span></span>
- <span data-ttu-id="de12d-199">Blokuj wymazywanie</span><span class="sxs-lookup"><span data-stu-id="de12d-199">Block Erase</span></span>
- <span data-ttu-id="de12d-200">Blokuj wymazywanie</span><span class="sxs-lookup"><span data-stu-id="de12d-200">Block Erased Verify</span></span>
- <span data-ttu-id="de12d-201">Strona została wymazana</span><span class="sxs-lookup"><span data-stu-id="de12d-201">Page Erased Verify</span></span>
- <span data-ttu-id="de12d-202">Pobieranie stanu blokowania</span><span class="sxs-lookup"><span data-stu-id="de12d-202">Block Status Get</span></span>
- <span data-ttu-id="de12d-203">Zablokuj ustawienie stanu</span><span class="sxs-lookup"><span data-stu-id="de12d-203">Block Status Set</span></span>
- <span data-ttu-id="de12d-204">Pobieranie dodatkowych bajtów</span><span class="sxs-lookup"><span data-stu-id="de12d-204">Block Extra Bytes Get</span></span>
- <span data-ttu-id="de12d-205">Zablokuj dodatkowe bajty</span><span class="sxs-lookup"><span data-stu-id="de12d-205">Block Extra Bytes Set</span></span>
- <span data-ttu-id="de12d-206">Program obsługi błędów systemu</span><span class="sxs-lookup"><span data-stu-id="de12d-206">System Error Handler</span></span>

## <a name="driver-initialization"></a><span data-ttu-id="de12d-207">Inicjowanie sterownika</span><span class="sxs-lookup"><span data-stu-id="de12d-207">Driver Initialization</span></span>

<span data-ttu-id="de12d-208">Te usługi są skonfigurowane za pośrednictwem ustawień wskaźników funkcji w wystąpieniu **LX_NAND_FLASH** w ramach funkcji inicjowania sterownika.</span><span class="sxs-lookup"><span data-stu-id="de12d-208">These services are setup via setting function pointers in the **LX_NAND_FLASH** instance within the driver's initialization function.</span></span> <span data-ttu-id="de12d-209">Funkcja inicjacji sterownika określa również łączną liczbę bloków, stron na blok, bajty na stronę, a obszar pamięci RAM jest wystarczająco duży, aby można było odczytać jedną stronę do pamięci.</span><span class="sxs-lookup"><span data-stu-id="de12d-209">The driver initialization function also specifies the total number of block, pages per block, bytes per page, and a RAM area large enough to read one page into memory.</span></span> <span data-ttu-id="de12d-210">Funkcja inicjacji sterownika, która umożliwia również wykonywanie dodatkowych obowiązków inicjalizacji dotyczących urządzeń i/lub implementacji przed zwróceniem **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="de12d-210">The driver initialization function likely also performs additional device and/or implementation-specific initialization duties before returning **LX_SUCCESS**.</span></span>

## <a name="driver-read-page"></a><span data-ttu-id="de12d-211">Strona odczytu sterownika</span><span class="sxs-lookup"><span data-stu-id="de12d-211">Driver Read Page</span></span>

<span data-ttu-id="de12d-212">Usługa LevelX ni Driver "Read Page" jest odpowiedzialna za odczytywanie określonej strony w określonym bloku ni Flash.</span><span class="sxs-lookup"><span data-stu-id="de12d-212">The LevelX NAND driver "read page" service is responsible for reading a specific page in a specific block of the NAND flash.</span></span> <span data-ttu-id="de12d-213">Wszystkie błędy sprawdzania i poprawiania logiki są odpowiedzialne za usługę sterownika.</span><span class="sxs-lookup"><span data-stu-id="de12d-213">All error checking and correcting logic is the responsibility of the driver service.</span></span> <span data-ttu-id="de12d-214">Jeśli to się powiedzie, sterownik LevelX ni zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="de12d-214">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="de12d-215">Jeśli to się nie powiedzie, sterownik LevelX ni zwraca **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="de12d-215">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="de12d-216">Poniżej przedstawiono prototyp usługi LevelX ni sterownika.</span><span class="sxs-lookup"><span data-stu-id="de12d-216">The prototype of the LevelX NAND driver "read page" service is given below.</span></span>

```c
INT nand_driver_read_page(
    ULONG block,
    ULONG page,
    ULONG *destination, 
    ULONG words);
```

<span data-ttu-id="de12d-217">Miejsce, w którym *blok* i *Strona* identyfikują, którą stronę odczytać i *miejsce docelowe* oraz *słowa* określają miejsce umieszczenia zawartości strony oraz liczbę słów 32-bitowych do odczytania.</span><span class="sxs-lookup"><span data-stu-id="de12d-217">Where *block* and *page* identify which page to read and *destination* and *words* specify where to place the page contents and how many 32-bit words to read.</span></span>

## <a name="driver-write-page"></a><span data-ttu-id="de12d-218">Strona zapisu sterownika</span><span class="sxs-lookup"><span data-stu-id="de12d-218">Driver Write Page</span></span>

<span data-ttu-id="de12d-219">Usługa LevelX ni Driver "Write Page" jest odpowiedzialna za pisanie określonej strony w określonym bloku ni Flash.</span><span class="sxs-lookup"><span data-stu-id="de12d-219">The LevelX NAND driver "write page" service is responsible for writing a specific page into the specified block of the NAND flash.</span></span> <span data-ttu-id="de12d-220">Wszystkie sprawdzanie błędów i obliczenia ECC są odpowiedzialne za usługę sterownika.</span><span class="sxs-lookup"><span data-stu-id="de12d-220">All error checking and ECC computation is the responsibility of the driver service.</span></span> <span data-ttu-id="de12d-221">Jeśli to się powiedzie, sterownik LevelX ni zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="de12d-221">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="de12d-222">Jeśli to się nie powiedzie, sterownik LevelX ni zwraca **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="de12d-222">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="de12d-223">Poniżej przedstawiono prototyp usługi LevelX ni sterownika "Write Page".</span><span class="sxs-lookup"><span data-stu-id="de12d-223">The prototype of the LevelX NAND driver "write page" service is shown below.</span></span>

```c
INT nand_driver_write_page(
    ULONG block, 
    ULONG page,
    ULONG *source, 
    ULONG words);
```

<span data-ttu-id="de12d-224">Miejsce, w którym *blok* i *Strona* identyfikują, która strona do *zapisu i* *słowa* określają Źródło zapisu oraz liczbę słów 32-bitowych do zapisu.</span><span class="sxs-lookup"><span data-stu-id="de12d-224">Where *block* and *page* identify which page to write and *source* and *words* specify the source of the write and how many 32-bit words to write.</span></span>

> [!NOTE]
> <span data-ttu-id="de12d-225">LevelX polega na sterowniku wykrywania błędów niskiego poziomu podczas zapisywania na stronie Flash, która zwykle obejmuje odczytywanie strony i porównywanie z buforem zapisu w celu upewnienia się, że zapis zakończył się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="de12d-225">LevelX relies on the driver for low-level error detection when writing to the flash page, which typically involves reading back the page and comparing with the write buffer to ensure the write was successful.</span></span>

## <a name="driver-block-erase"></a><span data-ttu-id="de12d-226">Blok sterownika — wymazywanie</span><span class="sxs-lookup"><span data-stu-id="de12d-226">Driver Block Erase</span></span>

<span data-ttu-id="de12d-227">Usługa LevelX ni Driver "Block Erase" jest odpowiedzialna za wymazywanie określonego bloku ni Flash.</span><span class="sxs-lookup"><span data-stu-id="de12d-227">The LevelX NAND driver "block erase" service is responsible for erasing the specified block of the NAND flash.</span></span> <span data-ttu-id="de12d-228">Jeśli to się powiedzie, sterownik LevelX ni zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="de12d-228">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="de12d-229">Jeśli to się nie powiedzie, sterownik LevelX ni zwraca **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="de12d-229">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="de12d-230">Prototyp usługi LevelX ni sterownika "Blokuj wymazywanie" jest następujący:</span><span class="sxs-lookup"><span data-stu-id="de12d-230">The prototype of the LevelX NAND driver "block erase" service is as follows.</span></span>

```c
INT nand_driver_block_erase(ULONG block,  
    ULONG erase_count);
```

<span data-ttu-id="de12d-231">*Blok* WHERE wskazuje, który blok należy wymazać.</span><span class="sxs-lookup"><span data-stu-id="de12d-231">Where *block* identifies which block to erase.</span></span> <span data-ttu-id="de12d-232">Parametr *erase_count* jest udostępniany do celów diagnostycznych.</span><span class="sxs-lookup"><span data-stu-id="de12d-232">The parameter *erase_count* is provided for diagnostic purposes.</span></span> <span data-ttu-id="de12d-233">Na przykład sterownik może chcieć ostrzec inną część oprogramowania aplikacji, gdy liczba wymazywań przekroczy określony próg.</span><span class="sxs-lookup"><span data-stu-id="de12d-233">For example, the driver may want to alert another portion of the application software when the erase count exceeds a specific threshold.</span></span>

> [!NOTE]
> <span data-ttu-id="de12d-234">LevelX opiera się na sterowniku wykrywania błędów niskiego poziomu, gdy blok zostanie wymazany, co zazwyczaj polega na zapewnieniu, że wszystkie strony bloku są wszystkie.</span><span class="sxs-lookup"><span data-stu-id="de12d-234">LevelX relies on the driver for low-level error detection when the block is erased, which typically involves ensuring that all pages of the block are all ones.</span></span>

## <a name="driver-block-erased-verify"></a><span data-ttu-id="de12d-235">Blok sterownika został wymazany</span><span class="sxs-lookup"><span data-stu-id="de12d-235">Driver Block Erased Verify</span></span>

<span data-ttu-id="de12d-236">Usługa LevelX ni Driver "Block Erase verify" jest odpowiedzialna za sprawdzenie, czy określony blok ni błysku jest wymazany.</span><span class="sxs-lookup"><span data-stu-id="de12d-236">The LevelX NAND driver "block erased verify" service is responsible for verifying that the specified block of the NAND flash is erased.</span></span> <span data-ttu-id="de12d-237">W przypadku wymazania sterownik LevelX ni zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="de12d-237">If it is erased, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="de12d-238">Jeśli blok nie zostanie wymazany, sterownik LevelX ni zwraca **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="de12d-238">If the block is not erased, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="de12d-239">Prototyp usługi LevelX ni Driver "Block Erase verify" to:</span><span class="sxs-lookup"><span data-stu-id="de12d-239">The prototype of the LevelX NAND driver "block erased verify" service is:</span></span>

```c
INT nand_driver_block_erased_verify(ULONG block);
```

<span data-ttu-id="de12d-240">*Blok* WHERE określa, który blok sprawdza, czy jest wymazany.</span><span class="sxs-lookup"><span data-stu-id="de12d-240">Where *block* specifies which block to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="de12d-241">LevelX opiera się na sterowniku, aby sprawdzić wszystkie strony i wszystkie bajty każdej strony, w tym bajty zapasowe i dane, aby upewnić się, że zostały wymazane (zawierają wszystkie).</span><span class="sxs-lookup"><span data-stu-id="de12d-241">LevelX relies on the driver to examine all pages and all bytes of each page – including spare and data bytes – to ensure they are erased (contain all ones).</span></span>

## <a name="driver-page-erased-verify"></a><span data-ttu-id="de12d-242">Zweryfikowano stronę sterownika</span><span class="sxs-lookup"><span data-stu-id="de12d-242">Driver Page Erased Verify</span></span>

<span data-ttu-id="de12d-243">Usługa LevelX ni sterownika "Strona została zweryfikowana" jest odpowiedzialna za sprawdzenie, czy określona strona określonego bloku ni lampy błyskowej została wymazana.</span><span class="sxs-lookup"><span data-stu-id="de12d-243">The LevelX NAND driver "page erased verify" service is responsible for verifying that the specified page of the specified block of the NAND flash is erased.</span></span> <span data-ttu-id="de12d-244">W przypadku wymazania sterownik LevelX ni zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="de12d-244">If it is erased, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="de12d-245">Jeśli strona nie zostanie wymazana, sterownik LevelX ni zwraca **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="de12d-245">If the page is not erased, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="de12d-246">Prototyp sterownika LevelX ni "Page Erase verify" jest:</span><span class="sxs-lookup"><span data-stu-id="de12d-246">The prototype of the LevelX NAND driver "page erased verify" service is:</span></span>

```c
INT nand_driver_page_erased_verify(
    ULONG block,  
    ULONG page);
```
<span data-ttu-id="de12d-247">*Blok* WHERE określa, który blok i *Strona* określa stronę, aby sprawdzić, czy została wymazana.</span><span class="sxs-lookup"><span data-stu-id="de12d-247">Where *block* specifies which block and *page* specifies the page to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="de12d-248">LevelX polega na sterowniku, aby sprawdzić wszystkie bajty określonej strony, w tym bajty zapasowe i dane, aby upewnić się, że zostały wymazane (zawierają wszystkie).</span><span class="sxs-lookup"><span data-stu-id="de12d-248">LevelX relies on the driver to examine all bytes of the specified page – including spare and data bytes – to ensure they are erased (contain all ones).</span></span>

## <a name="driver-block-status-get"></a><span data-ttu-id="de12d-249">Pobieranie stanu bloku sterownika</span><span class="sxs-lookup"><span data-stu-id="de12d-249">Driver Block Status Get</span></span>

<span data-ttu-id="de12d-250">Usługa LevelX ni Driver "Block status Get" jest odpowiedzialna za pobieranie nieprawidłowej flagi bloku określonego bloku ni Flash.</span><span class="sxs-lookup"><span data-stu-id="de12d-250">The LevelX NAND driver "block status get" service is responsible for retrieving the bad block flag of the specified block of the NAND flash.</span></span> <span data-ttu-id="de12d-251">Jeśli to się powiedzie, sterownik LevelX ni zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="de12d-251">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="de12d-252">Jeśli to się nie powiedzie, sterownik LevelX ni zwraca **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="de12d-252">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="de12d-253">Prototyp usługi LevelX ni Driver "Block status Get" jest następujący: pokazano poniżej.</span><span class="sxs-lookup"><span data-stu-id="de12d-253">The prototype of the LevelX NAND driver "block status get" service is: shown below.</span></span>

```c
INT nand_driver_block_status_get(
    ULONG block,  
    UCHAR *bad_block_byte);
```

<span data-ttu-id="de12d-254">*Blok* WHERE określa, który blok i *bad_block_byte* określa miejsce docelowe dla nieprawidłowej flagi bloku.</span><span class="sxs-lookup"><span data-stu-id="de12d-254">Where *block* specifies which block and *bad_block_byte* specifies the destination for the bad block flag.</span></span>

## <a name="driver-block-status-set"></a><span data-ttu-id="de12d-255">Ustawienie stanu bloku sterownika</span><span class="sxs-lookup"><span data-stu-id="de12d-255">Driver Block Status Set</span></span>

<span data-ttu-id="de12d-256">Usługa LevelX ni Driver "Block status Set" jest odpowiedzialna za ustawienie nieprawidłowej flagi bloku określonego bloku ni Flash.</span><span class="sxs-lookup"><span data-stu-id="de12d-256">The LevelX NAND driver "block status set" service is responsible for setting the bad block flag of the specified block of the NAND flash.</span></span> <span data-ttu-id="de12d-257">Jeśli to się powiedzie, sterownik LevelX ni zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="de12d-257">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="de12d-258">Jeśli to się nie powiedzie, sterownik LevelX ni zwraca **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="de12d-258">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="de12d-259">Prototyp usługi LevelX ni Driver "Block status Set":</span><span class="sxs-lookup"><span data-stu-id="de12d-259">The prototype of the LevelX NAND driver "block status set" service is:</span></span>

```c
INT nand_driver_block_status_set(
    ULONG block,
    UCHAR bad_block_byte);
```

<span data-ttu-id="de12d-260">*Blok* WHERE określa, który blok i *bad_block_byte* określa wartość nieprawidłowej flagi bloku.</span><span class="sxs-lookup"><span data-stu-id="de12d-260">Where *block* specifies which block and *bad_block_byte* specifies the value of the bad block flag.</span></span>

## <a name="driver-block-extra-bytes-get"></a><span data-ttu-id="de12d-261">Pobieranie dodatkowych bajtów w bloku sterownika</span><span class="sxs-lookup"><span data-stu-id="de12d-261">Driver Block Extra Bytes Get</span></span>

<span data-ttu-id="de12d-262">Usługa LevelX ni Driver "Blokuj dodatkową liczbę bajtów" jest odpowiedzialna za pobieranie dodatkowych bajtów skojarzonych z konkretną stroną określonego bloku ni Flash.</span><span class="sxs-lookup"><span data-stu-id="de12d-262">The LevelX NAND driver "block extra bytes get" service is responsible for retrieving extra bytes associated with a specific page of a specific block of the NAND flash.</span></span> <span data-ttu-id="de12d-263">Jeśli to się powiedzie, sterownik LevelX ni zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="de12d-263">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="de12d-264">Jeśli to się nie powiedzie, sterownik LevelX ni zwraca **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="de12d-264">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="de12d-265">Prototyp usługi LevelX ni Driver "Block Extra Bytes Get" to:</span><span class="sxs-lookup"><span data-stu-id="de12d-265">The prototype of the LevelX NAND driver "block extra bytes get" service is:</span></span>

```c
INT nand_driver_block_extra_bytes_get(
    ULONG block,  
    ULONG page, 
    UCHAR *destination, 
    UINT size);
```

<span data-ttu-id="de12d-266">*Blok* WHERE określa, który blok, *Strona* określa określoną stronę i *miejsce docelowe* określa miejsce docelowe dla dodatkowych bajtów.</span><span class="sxs-lookup"><span data-stu-id="de12d-266">Where *block* specifies which block, *page* specifies the specific page and *destination* specifies the destination for the extra bytes.</span></span> <span data-ttu-id="de12d-267">*Rozmiar* parametru określa liczbę dodatkowych bajtów do pobrania.</span><span class="sxs-lookup"><span data-stu-id="de12d-267">The parameter *size* specifies how many extra bytes to get.</span></span>

## <a name="driver-block-extra-bytes-set"></a><span data-ttu-id="de12d-268">Zestaw dodatkowych bajtów bloku sterownika</span><span class="sxs-lookup"><span data-stu-id="de12d-268">Driver Block Extra Bytes Set</span></span>

<span data-ttu-id="de12d-269">Usługa LevelX ni Driver "Block Extra Bytes Set" jest odpowiedzialna za ustawienie dodatkowych bajtów na określonej stronie określonego bloku ni Flash.</span><span class="sxs-lookup"><span data-stu-id="de12d-269">The LevelX NAND driver "block extra bytes set" service is responsible for setting extra bytes in a specific page of a specific block of the NAND flash.</span></span> <span data-ttu-id="de12d-270">Jeśli to się powiedzie, sterownik LevelX ni zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="de12d-270">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="de12d-271">Jeśli to się nie powiedzie, sterownik LevelX ni zwraca **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="de12d-271">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="de12d-272">Prototyp usługi LevelX ni Driver "Block Extra Bytes Set" to:</span><span class="sxs-lookup"><span data-stu-id="de12d-272">The prototype of the LevelX NAND driver "block extra bytes set" service is:</span></span>

```c
INT nand_driver_block_extra_bytes_set(
    ULONG block,  
    ULONG page, 
    UCHAR *source, 
    UINT size);
```

<span data-ttu-id="de12d-273">*Blok* WHERE określa, który blok, *Strona* określa określoną stronę i *Źródło* określa źródło dodatkowych bajtów.</span><span class="sxs-lookup"><span data-stu-id="de12d-273">Where *block* specifies which block, *page* specifies the specific page and *source* specifies the source of the extra bytes.</span></span> <span data-ttu-id="de12d-274">*Rozmiar* parametru określa liczbę dodatkowych bajtów do ustawienia.</span><span class="sxs-lookup"><span data-stu-id="de12d-274">The parameter *size* specifies how many extra bytes to set.</span></span>

## <a name="driver-system-error"></a><span data-ttu-id="de12d-275">Błąd systemu sterownika</span><span class="sxs-lookup"><span data-stu-id="de12d-275">Driver System Error</span></span>

<span data-ttu-id="de12d-276">Usługa programu obsługi błędów systemu LevelX ni jest odpowiedzialna za ustawienie obsługi błędów systemu wykrytych przez LevelX.</span><span class="sxs-lookup"><span data-stu-id="de12d-276">The LevelX NAND driver "system error handler" service is responsible for setting handling system errors detected by LevelX.</span></span> <span data-ttu-id="de12d-277">Przetwarzanie w tej procedurze jest zależne od aplikacji.</span><span class="sxs-lookup"><span data-stu-id="de12d-277">The processing in this routine is application dependent.</span></span> <span data-ttu-id="de12d-278">Jeśli to się powiedzie, sterownik LevelX ni zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="de12d-278">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="de12d-279">Jeśli to się nie powiedzie, sterownik LevelX ni zwraca **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="de12d-279">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="de12d-280">Prototyp usługi LevelX ni sterownika "System Error" jest następujący:</span><span class="sxs-lookup"><span data-stu-id="de12d-280">The prototype of the LevelX NAND driver "system error" service is:</span></span>

```c
INT nand_driver_system_error(
    UINT error_code,  
    ULONG block, 
    ULONG page);
```

<span data-ttu-id="de12d-281">*Blok* WHERE określa, który blok i *Strona* określa określoną stronę, w której wystąpił błąd reprezentowany przez *error_code* .</span><span class="sxs-lookup"><span data-stu-id="de12d-281">Where *block* specifies which block, and *page* specifies the specific page the error represented by *error_code* occurred.</span></span>

## <a name="nand-simulated-driver"></a><span data-ttu-id="de12d-282">Sterownik symulowany ni</span><span class="sxs-lookup"><span data-stu-id="de12d-282">NAND Simulated Driver</span></span>

<span data-ttu-id="de12d-283">LevelX udostępnia symulowany sterownik Flash ni, który po prostu używa pamięci RAM do symulowania operacji części Flash ni.</span><span class="sxs-lookup"><span data-stu-id="de12d-283">LevelX provides a simulated NAND flash driver that simply uses RAM to simulate the operation of a NAND flash part.</span></span> <span data-ttu-id="de12d-284">Domyślnie ni symulowany sterownik zawiera 8 ni bloków Flash z 16 stronami na blok i 2048 bajtów na stronę.</span><span class="sxs-lookup"><span data-stu-id="de12d-284">By default, the NAND simulated driver provides 8 NAND flash blocks with 16 pages per block and 2048 bytes per page.</span></span>

<span data-ttu-id="de12d-285">Symulowana Funkcja inicjowania sterownika ni Flash to \***lx_nand_flash_simulator_initialize** _ i jest zdefiniowana w _ *_lx_nand_flash_simulator. c_* \*.</span><span class="sxs-lookup"><span data-stu-id="de12d-285">The simulated NAND flash driver initialization function is ***lx_nand_flash_simulator_initialize** _ and is defined in _*_lx_nand_flash_simulator.c_\*\*.</span></span> <span data-ttu-id="de12d-286">Ten sterownik zapewnia również dobry szablon do pisania określonych sterowników ni Flash.</span><span class="sxs-lookup"><span data-stu-id="de12d-286">This driver also provides a good template for writing specific NAND flash drivers.</span></span>

## <a name="nand-filex-integration"></a><span data-ttu-id="de12d-287">Integracja z programem ni FileX</span><span class="sxs-lookup"><span data-stu-id="de12d-287">NAND FileX Integration</span></span>

<span data-ttu-id="de12d-288">Jak wspomniano wcześniej, LevelX nie polega na FileX dla operacji.</span><span class="sxs-lookup"><span data-stu-id="de12d-288">As mentioned earlier, LevelX does not rely on FileX for operation.</span></span> <span data-ttu-id="de12d-289">Wszystkie interfejsy API LevelX mogą być wywoływane bezpośrednio przez oprogramowanie aplikacji do przechowywania/pobierania nieprzetworzonych danych do sektorów logicznych dostarczonych przez LevelX.</span><span class="sxs-lookup"><span data-stu-id="de12d-289">All the LevelX APIs may be called directly by the application software to store/retrieve raw data to the logical sectors provided by LevelX.</span></span> <span data-ttu-id="de12d-290">Jednak LevelX obsługuje również FileX.</span><span class="sxs-lookup"><span data-stu-id="de12d-290">However, LevelX also supports FileX.</span></span>

<span data-ttu-id="de12d-291">Plik ***fx_nand_flash_simulated_driver. c*** zawiera przykładowy sterownik FileX do użycia z symulacją Flash ni.</span><span class="sxs-lookup"><span data-stu-id="de12d-291">The file ***fx_nand_flash_simulated_driver.c*** contains an example FileX driver for use with the NAND flash simulation.</span></span> <span data-ttu-id="de12d-292">Interesujący aspekt tego sterownika polega na tym, że łączy on 512-bajtowe sektory logiczne zwykle używane przez FileX do pojedynczego sektora logicznego żądania odczytu/zapisu do symulatora LevelX przy użyciu stron 2048-bajtowych.</span><span class="sxs-lookup"><span data-stu-id="de12d-292">An interesting aspect of this driver is that it combines 512-byte logical sectors typically used by FileX into single logical sector read/write requests to the LevelX simulator using 2048-byte pages.</span></span> <span data-ttu-id="de12d-293">Powoduje to wydajniejsze wykorzystanie pamięci flash ni.</span><span class="sxs-lookup"><span data-stu-id="de12d-293">This results in more efficient use of the NAND flash memory.</span></span> <span data-ttu-id="de12d-294">Sterownik ni Flash FileX dla LevelX zapewnia dobry punkt wyjścia do pisania niestandardowych sterowników FileX.</span><span class="sxs-lookup"><span data-stu-id="de12d-294">The NAND flash FileX driver for LevelX provides a good starting point for writing custom FileX drivers.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="de12d-295">Format Flash ni FileX powinien mieć jeden pełny rozmiar bloku dla sektorów niższy niż program ni Flash.</span><span class="sxs-lookup"><span data-stu-id="de12d-295">The FileX NAND flash format should be one full block size of sectors less than the NAND flash provides.</span></span> <span data-ttu-id="de12d-296">Pomoże to zapewnić najlepszą wydajność podczas przetwarzania poziomu zużycia.</span><span class="sxs-lookup"><span data-stu-id="de12d-296">This will help ensure best performance during the wear level processing.</span></span> <span data-ttu-id="de12d-297">Dodatkowe techniki zwiększające wydajność zapisu w algorytmie LevelXego zużycia są następujące:</span><span class="sxs-lookup"><span data-stu-id="de12d-297">Additional techniques to improve write performance in the LevelX wear leveling algorithm include the following.</span></span>

1. <span data-ttu-id="de12d-298">Upewnij się, że wszystkie zapisy mają dokładnie jeden lub więcej klastrów o rozmiarze i Rozpocznij na dokładnych granicach klastra.</span><span class="sxs-lookup"><span data-stu-id="de12d-298">Ensure that all writes are exactly one or more clusters in size and start on exact cluster boundaries.</span></span>
1. <span data-ttu-id="de12d-299">Przed wykonaniem operacji zapisu dużych plików za pośrednictwem klasy FileX ***Fx_file_allocate*** interfejsów API należy wstępnie przydzielić klastry.</span><span class="sxs-lookup"><span data-stu-id="de12d-299">Pre-allocate clusters before performing large file write operations via the FileX ***fx_file_allocate*** class of APIs.</span></span>
1. <span data-ttu-id="de12d-300">Upewnij się, że sterownik FileX jest włączony, aby otrzymywać informacje o sektorach wydania i żądania wysyłane do sterownika w celu wydania sektorów są obsługiwane w sterowniku przez wywołanie ***lx_nor_flash_sector_release***.</span><span class="sxs-lookup"><span data-stu-id="de12d-300">Ensure the FileX driver is enabled to receive release sector information and requests made to the driver to release sectors are handled in the driver by calling ***lx_nor_flash_sector_release***.</span></span>
1. <span data-ttu-id="de12d-301">Okresowe korzystanie z ***lx_nand_flash_defragment*** , aby zwolnić tyle bloków ni, jak to możliwe, a tym samym zwiększyć wydajność zapisu.</span><span class="sxs-lookup"><span data-stu-id="de12d-301">Periodic use of ***lx_nand_flash_defragment*** to free up as many NAND blocks as possible and thus improve write performance.</span></span>
1. <span data-ttu-id="de12d-302">Użyj interfejsu API ***lx_nand_flash_extended_cache_enable*** , aby zapewnić pamięć podręczną pamięci RAM różnych zasobów ni, aby zwiększyć wydajność.</span><span class="sxs-lookup"><span data-stu-id="de12d-302">Utilize the ***lx_nand_flash_extended_cache_enable*** API to provide a RAM cache of various NAND block resources for faster performance.</span></span>
