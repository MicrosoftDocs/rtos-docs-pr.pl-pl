---
title: Rozdział 5 — usługa Azure RTO LevelX i pomoc techniczna
description: ANI pamięć flash składa się z bloków, które są zwykle równo widoczne przez 512 bajtów. Usługa Azure RTO LevelX dzieli każdy lub blok Flash na 512-bajtowe sektory logiczne.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 3a0c73c2b45c32bf3f1ef56de684fa83c334b59e
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/22/2021
ms.locfileid: "104822164"
---
# <a name="chapter-5---azure-rtos-levelx-nor-support"></a><span data-ttu-id="4e6fc-104">Rozdział 5 — usługa Azure RTO LevelX i pomoc techniczna</span><span class="sxs-lookup"><span data-stu-id="4e6fc-104">Chapter 5 - Azure RTOS LevelX NOR support</span></span>

<span data-ttu-id="4e6fc-105">ANI pamięć flash składa się z *bloków* , które są zwykle równo widoczne przez 512 bajtów.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-105">NOR flash memory is composed of *blocks* that are typically evenly divisible by 512 bytes.</span></span> <span data-ttu-id="4e6fc-106">Brak koncepcji *strony* Flash w programie ani w pamięci flash.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-106">There are no concept of a flash *page* in NOR flash memory.</span></span> <span data-ttu-id="4e6fc-107">Ponadto nie ma bajtów *zapasowych* w wersji ani w pamięci flash, dlatego usługa Azure RTO LevelX musi korzystać z samej pamięci lub samego programu Flash dla wszystkich informacji o zarządzaniu.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-107">Also, there are no *spare* bytes in NOR flash memory, hence Azure RTOS LevelX must use the NOR flash memory itself for all management information.</span></span> <span data-ttu-id="4e6fc-108">Bezpośredni dostęp do odczytu jest możliwy w pamięci lub na platformie Flash.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-108">Direct read access is possible in NOR flash memory.</span></span> <span data-ttu-id="4e6fc-109">Dostęp do zapisu zwykle wymaga specjalnej sekwencji operacji.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-109">Write access typically requires a special sequence of operations.</span></span> <span data-ttu-id="4e6fc-110">LUB pamięć Flash może być wielokrotnie zapisywana, co oznacza, że bity są usuwane.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-110">NOR flash memory may be written to multiple times, providing that bits are being cleared.</span></span> <span data-ttu-id="4e6fc-111">Bity w pamięci programu ani Flash można ustawić tylko raz, za pośrednictwem operacji wymazywania bloku.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-111">Bits in NOR flash memory can only be set once, via the erase block operation.</span></span>

<span data-ttu-id="4e6fc-112">LevelX dzieli każdy lub blok Flash na 512-bajtowe *sektory* logiczne.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-112">LevelX divides each NOR flash block into 512-byte logical *sectors*.</span></span> <span data-ttu-id="4e6fc-113">Ponadto LevelX używa pierwszych "n" sektorów każdego lub bloku Flash do przechowywania informacji o zarządzaniu.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-113">Furthermore, LevelX uses the first "n" sectors of each NOR flash block to store management information.</span></span> <span data-ttu-id="4e6fc-114">Format informacji o zarządzaniu pamięcią LevelX lub Flash to:</span><span class="sxs-lookup"><span data-stu-id="4e6fc-114">The format of the LevelX NOR flash memory management information is:</span></span>

<span data-ttu-id="4e6fc-115">**LevelX i format bloku**</span><span class="sxs-lookup"><span data-stu-id="4e6fc-115">**LevelX NOR Block Format**</span></span>

| <span data-ttu-id="4e6fc-116">Przesunięcie bajtów</span><span class="sxs-lookup"><span data-stu-id="4e6fc-116">Byte Offset</span></span>  | <span data-ttu-id="4e6fc-117">Zawartość</span><span class="sxs-lookup"><span data-stu-id="4e6fc-117">Contents</span></span>                     |
| ------------ | ---------------------------- |
| <span data-ttu-id="4e6fc-118">0</span><span class="sxs-lookup"><span data-stu-id="4e6fc-118">0</span></span>            | <span data-ttu-id="4e6fc-119">[Liczba wymazanych bloków]</span><span class="sxs-lookup"><span data-stu-id="4e6fc-119">[Block Erase Count]</span></span>          |
| <span data-ttu-id="4e6fc-120">4</span><span class="sxs-lookup"><span data-stu-id="4e6fc-120">4</span></span>            | <span data-ttu-id="4e6fc-121">[Minimalny zamapowany sektor]</span><span class="sxs-lookup"><span data-stu-id="4e6fc-121">[Minimum Mapped Sector]</span></span>      |
| <span data-ttu-id="4e6fc-122">8</span><span class="sxs-lookup"><span data-stu-id="4e6fc-122">8</span></span>            | <span data-ttu-id="4e6fc-123">[Maksymalny zamapowany sektor]</span><span class="sxs-lookup"><span data-stu-id="4e6fc-123">[Maximum Mapped Sector]</span></span>      |
| <span data-ttu-id="4e6fc-124">12</span><span class="sxs-lookup"><span data-stu-id="4e6fc-124">12</span></span>           | <span data-ttu-id="4e6fc-125">[Mapa bitowa wolnego sektora]</span><span class="sxs-lookup"><span data-stu-id="4e6fc-125">[Free Sector Bit Map]</span></span>        |
| <span data-ttu-id="4e6fc-126">m</span><span class="sxs-lookup"><span data-stu-id="4e6fc-126">m</span></span>            | <span data-ttu-id="4e6fc-127">[Wpis mapowania sektora 0]</span><span class="sxs-lookup"><span data-stu-id="4e6fc-127">[Sector 0 Mapping Entry]</span></span>     |
|              | <span data-ttu-id="4e6fc-128">…</span><span class="sxs-lookup"><span data-stu-id="4e6fc-128">…</span></span>                            |
| <span data-ttu-id="4e6fc-129">m + 4 \* (n-1)</span><span class="sxs-lookup"><span data-stu-id="4e6fc-129">m+4\*(n-1)</span></span>    | <span data-ttu-id="4e6fc-130">[Sektor "n" — wpis mapowania]</span><span class="sxs-lookup"><span data-stu-id="4e6fc-130">[Sector "n" Mapping Entry]</span></span>   |
|              | <span data-ttu-id="4e6fc-131">…</span><span class="sxs-lookup"><span data-stu-id="4e6fc-131">…</span></span>                            |
| <span data-ttu-id="4e6fc-132">s</span><span class="sxs-lookup"><span data-stu-id="4e6fc-132">s</span></span>            | <span data-ttu-id="4e6fc-133">[Zawartość sektora 0]</span><span class="sxs-lookup"><span data-stu-id="4e6fc-133">[Sector 0 Contents]</span></span>          |
|              | <span data-ttu-id="4e6fc-134">…</span><span class="sxs-lookup"><span data-stu-id="4e6fc-134">…</span></span>                            |
| <span data-ttu-id="4e6fc-135">s + 512 \* (n-1)</span><span class="sxs-lookup"><span data-stu-id="4e6fc-135">s+512\*(n-1)</span></span> | <span data-ttu-id="4e6fc-136">[Zawartość sektora "n"]</span><span class="sxs-lookup"><span data-stu-id="4e6fc-136">[Sector "n" Contents]</span></span>         |

<span data-ttu-id="4e6fc-137">*Liczba wymazania bloku* 32-bitowego zawiera liczbę wymazanych bloków.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-137">The 32-bit *Block Erase Count* contains the number of times the block has been erased.</span></span> <span data-ttu-id="4e6fc-138">Głównym celem LevelX jest zachowanie liczby wymazywań wszystkich bloków stosunkowo blisko, aby zapobiec przedwczesnemu wykorzystaniu jednego bloku.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-138">The main goal of LevelX is to keep the erase count of all blocks relatively close to help prevent any one block from wearing out prematurely.</span></span> <span data-ttu-id="4e6fc-139">32-bitowy *minimalny zamapowany sektor* i pola *maksymalnego zamapowanego sektora* są zapisywane tylko wtedy, gdy wszystkie sektory logiczne w bloku zostały zamapowane i zapisana.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-139">The 32-bit *Minimum Mapped Sector* and *Maximum Mapped Sector* fields are written only when all the logical sectors in the block have been mapped and written to.</span></span> <span data-ttu-id="4e6fc-140">Te pola są przydatne do optymalizacji operacji odczytu sektora.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-140">These fields are useful for optimization of the sector read operation.</span></span> <span data-ttu-id="4e6fc-141">Wpis *mapy bitowej wolnego sektora* jest mapą bitową, w której każdy bit zestawu odpowiada niezamapowanemu sektorowi w bloku.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-141">The *Free Sector Bit Map* entry is a bit map where each set bit corresponds to an unmapped sector in the block.</span></span> <span data-ttu-id="4e6fc-142">To pole służy do zwiększania wydajności wyszukiwania wolnych sektorów.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-142">This field is used to make the free sector search more efficient.</span></span> <span data-ttu-id="4e6fc-143">Jest to pole o zmiennej długości, które wymaga jednego słowa dla każdego 32 sektorów w bloku.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-143">This is a variable length field that requires one word for every 32 sectors in the block.</span></span> <span data-ttu-id="4e6fc-144">Tablica *wpisów mapowania sektorów* zawiera informacje o mapowaniu dla każdego sektora w bloku.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-144">The *Sector Mapping Entry* array contains mapping information for each sector in the block.</span></span> <span data-ttu-id="4e6fc-145">Każdy wpis ma następujący format:</span><span class="sxs-lookup"><span data-stu-id="4e6fc-145">Each entry has the following format:</span></span>

<span data-ttu-id="4e6fc-146">**Wpis mapowania sektora**</span><span class="sxs-lookup"><span data-stu-id="4e6fc-146">**Sector Mapping Entry**</span></span>

| <span data-ttu-id="4e6fc-147">Liczba bitów:</span><span class="sxs-lookup"><span data-stu-id="4e6fc-147">Bit(s)</span></span> | <span data-ttu-id="4e6fc-148">Znaczenie</span><span class="sxs-lookup"><span data-stu-id="4e6fc-148">Meaning</span></span>  |
| ------ | -------- |
| <span data-ttu-id="4e6fc-149">31</span><span class="sxs-lookup"><span data-stu-id="4e6fc-149">31</span></span>     | <span data-ttu-id="4e6fc-150">Prawidłowa flaga.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-150">Valid flag.</span></span> <span data-ttu-id="4e6fc-151">Gdy zestaw i sektor logiczny nie są wszystkie, oznacza to, że mapowanie jest prawidłowe</span><span class="sxs-lookup"><span data-stu-id="4e6fc-151">When set and logical sector not all ones indicates mapping is valid</span></span> |
| <span data-ttu-id="4e6fc-152">30</span><span class="sxs-lookup"><span data-stu-id="4e6fc-152">30</span></span>     | <span data-ttu-id="4e6fc-153">Flaga przestarzała.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-153">Obsolete flag.</span></span> <span data-ttu-id="4e6fc-154">Po wyczyszczeniu to mapowanie jest przestarzałe lub jest w stanie przestarzałe.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-154">When clear, this mapping is either obsolete or is in the process of becoming obsolete.</span></span> |
| <span data-ttu-id="4e6fc-155">29</span><span class="sxs-lookup"><span data-stu-id="4e6fc-155">29</span></span>     | <span data-ttu-id="4e6fc-156">Zapis mapowania wpisu jest zakończony, gdy ten bit ma wartość 0</span><span class="sxs-lookup"><span data-stu-id="4e6fc-156">Mapping entry write is complete when this bit is 0</span></span> |
| <span data-ttu-id="4e6fc-157">0-28</span><span class="sxs-lookup"><span data-stu-id="4e6fc-157">0-28</span></span>   | <span data-ttu-id="4e6fc-158">Sektor logiczny mapowany na ten sektor fizyczny — bez wszystkich.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-158">Logical sector mapped to this physical sector—when not all ones.</span></span> |

<span data-ttu-id="4e6fc-159">Górny bit pola 32-bitowego (bit 31) jest używany do wskazania, że mapowanie sektora logicznego jest prawidłowe.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-159">The upper bit of the 32-bit field (bit 31) is used to indicate the logical sector mapping is valid.</span></span> <span data-ttu-id="4e6fc-160">Jeśli ten bit ma wartość 0, informacje zawarte w tym wpisie (i jego zawartość sektora) nie są już prawidłowe.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-160">If this bit is 0, the information in this entry (and corresponding sector contents) is no longer valid.</span></span> <span data-ttu-id="4e6fc-161">Kolejny bit-bit 30-jest używany do wskazania, że ten sektor jest w stanie przestarzały, i trwa zapisywanie nowego sektora.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-161">The next bit - bit 30 - is used to indicate this sector is in the process of becoming obsolete and a new sector is being written.</span></span> <span data-ttu-id="4e6fc-162">Bit 29 służy do wskazania, kiedy zapis mapowania jest zakończony.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-162">Bit 29 is used to indicate when the mapping entry write is complete.</span></span> <span data-ttu-id="4e6fc-163">Jeśli bit 29 ma wartość 0, zakończono zapisywanie wpisu mapowania.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-163">If bit 29 is 0, the mapping entry write is complete.</span></span> <span data-ttu-id="4e6fc-164">Jeśli ustawiono bit 29, wpis mapowania był w trakcie zapisywania.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-164">If bit 29 is set, the mapping entry was in the process of being written.</span></span> <span data-ttu-id="4e6fc-165">Bity 30 i 29 są używane podczas odzyskiwania po potencjalnej utracie mocy podczas aktualizowania nowego mapowania sektorów.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-165">Bits 30 and 29 are used in recovering from a potential power loss while updating a new sector mapping.</span></span> <span data-ttu-id="4e6fc-166">Na koniec niższa 29 bitów (28-0) zawiera numer sektora logicznego dla sektora.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-166">Finally, the lower 29-bits (28-0) contain the logical sector number for the sector.</span></span> <span data-ttu-id="4e6fc-167">Jeśli sektor nie został zmapowany, zostaną ustawione wszystkie bity, tj. wartość 0xFFFFFFFF.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-167">If a sector has not been mapped, all bits will be set, i.e., it will have a value of 0xFFFFFFFF.</span></span>

## <a name="nor-driver-requirements"></a><span data-ttu-id="4e6fc-168">LUB wymagania dotyczące sterowników</span><span class="sxs-lookup"><span data-stu-id="4e6fc-168">NOR Driver Requirements</span></span>

<span data-ttu-id="4e6fc-169">LevelX wymaga podstawowego lub Flash sterownika, który jest specyficzny dla bazowej części Flash i implementacji sprzętowej.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-169">LevelX requires an underlying NOR flash driver that is specific to the underlying flash part and hardware implementation.</span></span> <span data-ttu-id="4e6fc-170">Sterownik jest określany do LevelX podczas inicjowania za pośrednictwem interfejsu API ***lx_nor_flash_open***.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-170">The driver is specified to LevelX during initialization via the API ***lx_nor_flash_open***.</span></span> <span data-ttu-id="4e6fc-171">Prototyp sterownika LevelX:</span><span class="sxs-lookup"><span data-stu-id="4e6fc-171">The prototype of the LevelX driver is:</span></span>

```c
INT nor_driver_initialize(LX_NOR_FLASH *instance);
```

<span data-ttu-id="4e6fc-172">Parametr "*instance*" określa LevelX lub blok sterujący.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-172">The "*instance*" parameter specifies the LevelX NOR control block.</span></span> <span data-ttu-id="4e6fc-173">Funkcja inicjowania sterownika jest odpowiedzialna za konfigurowanie wszystkich innych usług na poziomie sterowników dla skojarzonego wystąpienia LevelX.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-173">The driver initialization function is responsible for setting up all the other driver-level services for the associated LevelX instance.</span></span> <span data-ttu-id="4e6fc-174">Usługi wymagane dla każdego LevelXu i wystąpienia są następujące:</span><span class="sxs-lookup"><span data-stu-id="4e6fc-174">The services required for each LevelX NOR instance are:</span></span>

- <span data-ttu-id="4e6fc-175">Odczytaj sektor</span><span class="sxs-lookup"><span data-stu-id="4e6fc-175">Read Sector</span></span>
- <span data-ttu-id="4e6fc-176">Sektor zapisu</span><span class="sxs-lookup"><span data-stu-id="4e6fc-176">Write Sector</span></span>
- <span data-ttu-id="4e6fc-177">Blokuj wymazywanie</span><span class="sxs-lookup"><span data-stu-id="4e6fc-177">Block Erase</span></span>
- <span data-ttu-id="4e6fc-178">Blokuj wymazywanie</span><span class="sxs-lookup"><span data-stu-id="4e6fc-178">Block Erased Verify</span></span>
- <span data-ttu-id="4e6fc-179">Program obsługi błędów systemu</span><span class="sxs-lookup"><span data-stu-id="4e6fc-179">System Error Handler</span></span>

## <a name="driver-initialization"></a><span data-ttu-id="4e6fc-180">Inicjowanie sterownika</span><span class="sxs-lookup"><span data-stu-id="4e6fc-180">Driver Initialization</span></span>

<span data-ttu-id="4e6fc-181">Te usługi są skonfigurowane za pośrednictwem ustawień wskaźników funkcji w wystąpieniu **LX_NOR_FLASH** w ramach funkcji inicjowania sterownika.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-181">These services are setup via setting function pointers in the **LX_NOR_FLASH** instance within the driver's initialization function.</span></span> <span data-ttu-id="4e6fc-182">Funkcja inicjowania sterownika jest również odpowiedzialna za:</span><span class="sxs-lookup"><span data-stu-id="4e6fc-182">The driver initialization function also is responsible for:</span></span>

1. <span data-ttu-id="4e6fc-183">Określanie adresu podstawowego dla lampy błyskowej.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-183">Specifying the base address of the flash.</span></span>
1. <span data-ttu-id="4e6fc-184">Określanie całkowitej liczby bloków i liczby wyrazów na blok.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-184">Specifying the total number of blocks and the number of words per block.</span></span>
1. <span data-ttu-id="4e6fc-185">Bufor pamięci RAM służący do odczytywania jednego sektora Flash (512 bajtów) i wyrównany do ULONG dostępu.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-185">A RAM buffer for reading one sector of flash (512 bytes) and aligned for ULONG access.</span></span>

<span data-ttu-id="4e6fc-186">Funkcja inicjacji sterownika, która umożliwia również wykonywanie dodatkowych obowiązków inicjalizacji dotyczących urządzeń i/lub implementacji przed zwróceniem **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-186">The driver initialization function likely also performs additional device and/or implementation-specific initialization duties before returning **LX_SUCCESS**.</span></span>

## <a name="driver-read-sector"></a><span data-ttu-id="4e6fc-187">Sektor odczytu sterownika</span><span class="sxs-lookup"><span data-stu-id="4e6fc-187">Driver Read Sector</span></span>

<span data-ttu-id="4e6fc-188">Usługa LevelX lub sterownik "Ready" sektora jest odpowiedzialny za odczytywanie określonego sektora w określonym bloku i na potrzeby lampy błyskowej.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-188">The LevelX NOR driver "read sector" service is responsible for reading a specific sector in a specific block of the NOR flash.</span></span> <span data-ttu-id="4e6fc-189">Wszystkie błędy sprawdzania i poprawiania logiki są odpowiedzialne za usługę sterownika.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-189">All error checking and correcting logic is the responsibility of the driver service.</span></span> <span data-ttu-id="4e6fc-190">Jeśli to się powiedzie, LevelX lub sterownik zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-190">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4e6fc-191">Jeśli to się nie powiedzie, LevelX lub sterownik zwraca *LX_ERROR*.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-191">If not successful, the LevelX NOR driver returns *LX_ERROR*.</span></span> <span data-ttu-id="4e6fc-192">Prototyp usługi LevelX lub sterownika "Read sektora" to:</span><span class="sxs-lookup"><span data-stu-id="4e6fc-192">The prototype of the LevelX NOR driver "read sector" service is:</span></span>

```c
INT nor_driver_read_sector(
    ULONG *flash_address,
    ULONG *destination, 
    ULONG words);
```

<span data-ttu-id="4e6fc-193">Gdzie "*flash_address*" określa adres sektora logicznego w bloku i i Flash pamięci oraz "*miejsce docelowe*" i "*słowa*" określają miejsce umieszczenia zawartości sektora oraz liczbę słów 32-bitowych do odczytania.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-193">Where "*flash_address*" specifies the address of a logical sector within a NOR flash block of memory and "*destination*" and "*words*" specify where to place the sector contents and how many 32-bit words to read.</span></span>

## <a name="driver-write-sector"></a><span data-ttu-id="4e6fc-194">Sektor zapisu sterowników</span><span class="sxs-lookup"><span data-stu-id="4e6fc-194">Driver Write Sector</span></span>

<span data-ttu-id="4e6fc-195">Usługa LevelX lub "sektora zapisu" jest odpowiedzialna za pisanie określonego sektora w bloku i na potrzeby lampy błyskowej.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-195">The LevelX NOR driver "write sector" service is responsible for writing a specific sector into a block of the NOR flash.</span></span> <span data-ttu-id="4e6fc-196">Wszystkie sprawdzanie błędów jest odpowiedzialne za usługę sterownika.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-196">All error checking is the responsibility of the driver service.</span></span> <span data-ttu-id="4e6fc-197">Jeśli to się powiedzie, LevelX lub sterownik zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-197">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4e6fc-198">Jeśli to się nie powiedzie, LevelX lub sterownik zwraca **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-198">If not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="4e6fc-199">Prototyp usługi LevelX lub "sektora zapisu" jest:</span><span class="sxs-lookup"><span data-stu-id="4e6fc-199">The prototype of the LevelX NOR driver "write sector" service is:</span></span>

```c
INT nor_driver_write_sector(
    ULONG *flash_address,
    ULONG *source, 
    ULONG words);
```

<span data-ttu-id="4e6fc-200">Gdzie "*flash_address*" określa adres sektora logicznego w bloku i lub flash pamięci, a "*Źródło*" i "*słowa*" określają Źródło zapisu oraz liczbę słów 32-bitowych do zapisu.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-200">Where "*flash_address*" specifies the address of a logical sector within a NOR flash block of memory and "*source*" and "*words*" specify the source of the write and how many 32-bit words to write.</span></span>

> [!NOTE]
> <span data-ttu-id="4e6fc-201">LevelX opiera się na sterowniku, aby sprawdzić, czy sektor zapisu zakończył się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-201">LevelX relies on the driver to verify that the write sector was successful.</span></span> <span data-ttu-id="4e6fc-202">Jest to zazwyczaj wykonywane przez odczytanie zaprogramowanej wartości, aby upewnić się, że jest ona zgodna z żądaną wartością do zapisania.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-202">This is typically done by reading back the programmed value to ensure it matches the requested value to be written.</span></span>

## <a name="driver-block-erase"></a><span data-ttu-id="4e6fc-203">Blok sterownika — wymazywanie</span><span class="sxs-lookup"><span data-stu-id="4e6fc-203">Driver Block Erase</span></span>

<span data-ttu-id="4e6fc-204">Usługa LevelX i sterownik "Blokuj wymazywanie" jest odpowiedzialny za wymazywanie określonego bloku i błysku.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-204">The LevelX NOR driver "block erase" service is responsible for erasing the specified block of the NOR flash.</span></span> <span data-ttu-id="4e6fc-205">Jeśli to się powiedzie, LevelX lub sterownik zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-205">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4e6fc-206">Jeśli to się nie powiedzie, LevelX lub sterownik zwraca **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-206">If not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="4e6fc-207">Prototyp usługi LevelX lub sterownika "Blokuj wymazywanie" jest:</span><span class="sxs-lookup"><span data-stu-id="4e6fc-207">The prototype of the LevelX NOR driver "block erase" service is:</span></span>

```c
INT nor_driver_block_erase(ULONG block,  
    ULONG erase_count);
```

<span data-ttu-id="4e6fc-208">Gdzie "*Block*" identyfikuje, które nie są blokowane.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-208">Where "*block*" identifies which NOR block to erase.</span></span> <span data-ttu-id="4e6fc-209">Parametr "*erase_count*" jest dostarczany do celów diagnostycznych.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-209">The parameter "*erase_count*" is provided for diagnostic purposes.</span></span> <span data-ttu-id="4e6fc-210">Na przykład sterownik może chcieć ostrzec inną część oprogramowania aplikacji, gdy liczba wymazywań przekroczy określony próg.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-210">For example, the driver may want to alert another portion of the application software when the erase count exceeds a specific threshold.</span></span>

> [!NOTE]
> <span data-ttu-id="4e6fc-211">LevelX polega na sterowniku, aby sprawdzić wszystkie bajty bloku, aby upewnić się, że zostały wymazane (zawierają wszystkie).</span><span class="sxs-lookup"><span data-stu-id="4e6fc-211">LevelX relies on the driver to examine all bytes of the block to ensure they are erased (contain all ones).</span></span>

## <a name="driver-block-erased-verify"></a><span data-ttu-id="4e6fc-212">Blok sterownika został wymazany</span><span class="sxs-lookup"><span data-stu-id="4e6fc-212">Driver Block Erased Verify</span></span>

<span data-ttu-id="4e6fc-213">Usługa LevelX lub sterownik "Blokuj wymazywanie weryfikacji" jest odpowiedzialny za sprawdzenie, czy określony blok i błysk zostały wymazane.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-213">The LevelX NOR driver "block erased verify" service is responsible for verifying that the specified block of the NOR flash is erased.</span></span> <span data-ttu-id="4e6fc-214">W przypadku wymazania LevelX lub sterownik zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-214">If it is erased, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4e6fc-215">Jeśli blok nie zostanie wymazany, LevelX lub sterownik zwraca **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-215">If the block is not erased, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="4e6fc-216">Prototyp usługi LevelX lub sterownika "Blokuj wymazywane sprawdzanie" to:</span><span class="sxs-lookup"><span data-stu-id="4e6fc-216">The prototype of the LevelX NOR driver "block erased verify" service is:</span></span>

```c
INT nor_driver_block_erased_verify(ULONG block);
```

<span data-ttu-id="4e6fc-217">Gdzie "*Block*" określa, który blok, aby sprawdzić, czy został wymazany.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-217">Where "*block*" specifies which block to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="4e6fc-218">LevelX polega na sterowniku, aby sprawdzić wszystkie bajty określonego, aby upewnić się, że zostały wymazane (zawierają wszystkie).</span><span class="sxs-lookup"><span data-stu-id="4e6fc-218">LevelX relies on the driver to examine all bytes of the specified to ensure they are erased (contain all ones).</span></span>

## <a name="driver-system-error"></a><span data-ttu-id="4e6fc-219">Błąd systemu sterownika</span><span class="sxs-lookup"><span data-stu-id="4e6fc-219">Driver System Error</span></span>

<span data-ttu-id="4e6fc-220">Usługa LevelX lub sterownik programu obsługi błędów systemu jest odpowiedzialny za ustawienie obsługi błędów systemu wykrytych przez LevelX.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-220">The LevelX NOR driver "system error handler" service is responsible for setting handling system errors detected by LevelX.</span></span> <span data-ttu-id="4e6fc-221">Przetwarzanie w tej procedurze jest zależne od aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-221">The processing in this routine is application dependent.</span></span> <span data-ttu-id="4e6fc-222">Jeśli to się powiedzie, LevelX lub sterownik zwraca **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-222">If it is successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="4e6fc-223">Jeśli to się nie powiedzie, LevelX lub sterownik zwraca **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-223">If it is not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="4e6fc-224">Prototyp usługi LevelX lub sterownika "Error system" jest następujący:</span><span class="sxs-lookup"><span data-stu-id="4e6fc-224">The prototype of the LevelX NOR driver "system error" service is:</span></span>

```c
INT nor_driver_system_error(UINT error_code);
```

<span data-ttu-id="4e6fc-225">Gdzie "*error_code*" reprezentuje błąd, który wystąpił.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-225">Where "*error_code*" represents the error that occurred.</span></span>

## <a name="nor-simulated-driver"></a><span data-ttu-id="4e6fc-226">LUB symulowany sterownik</span><span class="sxs-lookup"><span data-stu-id="4e6fc-226">NOR Simulated Driver</span></span>

<span data-ttu-id="4e6fc-227">LevelX zapewnia symulowane lub nieflash sterownika, który po prostu używa pamięci RAM do symulowania operacji części a i programu Flash.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-227">LevelX provides a simulated NOR flash driver that simply uses RAM to simulate the operation of a NOR flash part.</span></span> <span data-ttu-id="4e6fc-228">Domyślnie niesymulowany sterownik zawiera 8 i bloki Flash z 16 512-bajtowymi sektorami na blok.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-228">By default, the NOR simulated driver provides 8 NOR flash blocks with 16 512-byte sectors per block.</span></span>

<span data-ttu-id="4e6fc-229">Funkcja inicjalizacji sterownika symulowane i Flash to \***lx_nor_flash_simulator_initialize** _ i jest zdefiniowana w _ *_lx_nor_flash_simulator. c_* \*.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-229">The simulated NOR flash driver initialization function is ***lx_nor_flash_simulator_initialize** _ and is defined in _*_lx_nor_flash_simulator.c_\*\*.</span></span> <span data-ttu-id="4e6fc-230">Ten sterownik zapewnia również dobry szablon do pisania określonych lub sterowników Flash.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-230">This driver also provides a good template for writing specific NOR flash drivers.</span></span>

## <a name="nor-filex-integration"></a><span data-ttu-id="4e6fc-231">ANI integracja FileX</span><span class="sxs-lookup"><span data-stu-id="4e6fc-231">NOR FileX Integration</span></span>

<span data-ttu-id="4e6fc-232">Jak wspomniano wcześniej, LevelX nie polega na FileX dla operacji.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-232">As mentioned earlier, LevelX does not rely on FileX for operation.</span></span> <span data-ttu-id="4e6fc-233">Wszystkie interfejsy API LevelX mogą być wywoływane bezpośrednio przez oprogramowanie aplikacji do przechowywania/pobierania nieprzetworzonych danych do sektorów logicznych dostarczonych przez LevelX.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-233">All the LevelX APIs may be called directly by the application software to store/retrieve raw data to the logical sectors provided by LevelX.</span></span> <span data-ttu-id="4e6fc-234">Jednak LevelX obsługuje również FileX.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-234">However, LevelX also supports FileX.</span></span>

<span data-ttu-id="4e6fc-235">Plik ***fx_nor_flash_simulated_driver. c*** zawiera przykładowy sterownik FileX do użycia z symulacją i funkcją Flash.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-235">The file ***fx_nor_flash_simulated_driver.c*** contains an example FileX driver for use with the NOR flash simulation.</span></span> <span data-ttu-id="4e6fc-236">Sterownik programu ani Flash FileX dla LevelX zapewnia dobry punkt wyjścia do pisania niestandardowych sterowników FileX.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-236">The NOR flash FileX driver for LevelX provides a good starting point for writing custom FileX drivers.</span></span>

> [!NOTE]
> <span data-ttu-id="4e6fc-237">FileX ani format Flash powinny mieć jeden pełny rozmiar bloku sektorów mniejszy niż wartość i błysk.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-237">The FileX NOR flash format should be one full block size of sectors less than the NOR flash provides.</span></span> <span data-ttu-id="4e6fc-238">Pomoże to zapewnić najlepszą wydajność podczas przetwarzania poziomu zużycia.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-238">This will help ensure best performance during the wear level processing.</span></span> <span data-ttu-id="4e6fc-239">Dodatkowe techniki zwiększające wydajność zapisu w algorytmie LevelXego zużycia są następujące:</span><span class="sxs-lookup"><span data-stu-id="4e6fc-239">Additional techniques to improve write performance in the LevelX wear leveling algorithm include:</span></span>
> 1. <span data-ttu-id="4e6fc-240">Upewnij się, że wszystkie zapisy mają dokładnie jeden lub więcej klastrów o rozmiarze i Rozpocznij na dokładnych granicach klastra.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-240">Ensure that all writes are exactly one or more clusters in size and start on exact cluster boundaries.</span></span>
> 2. <span data-ttu-id="4e6fc-241">Przed wykonaniem operacji zapisu dużych plików za pośrednictwem klasy FileX ***Fx_file_allocate*** interfejsów API należy wstępnie przydzielić klastry.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-241">Pre-allocate clusters before performing large file write operations via the FileX ***fx_file_allocate*** class of APIs.</span></span>
> 3.  <span data-ttu-id="4e6fc-242">Okresowe korzystanie z ***lx_nor_flash_defragment*** w celu zwolnienia możliwie największej liczby lub bloków, a tym samym zwiększenie wydajności zapisu.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-242">Periodic use of ***lx_nor_flash_defragment*** to free up as many NOR blocks as possible and thus improve write performance.</span></span>
> 4. <span data-ttu-id="4e6fc-243">Upewnij się, że sterownik FileX jest włączony, aby otrzymywać informacje o sektorach wydania i żądania wysyłane do sterownika w celu wydania sektorów są obsługiwane w sterowniku przez wywołanie ***lx_nor_flash_sector_release***.</span><span class="sxs-lookup"><span data-stu-id="4e6fc-243">Ensure the FileX driver is enabled to receive release sector information and requests made to the driver to release sectors are handled in the driver by calling ***lx_nor_flash_sector_release***.</span></span>
