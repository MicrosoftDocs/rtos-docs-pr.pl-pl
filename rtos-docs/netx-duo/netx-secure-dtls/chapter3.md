---
title: Rozdział 3 — Opis funkcjonalny usługi Azure RTO NetX Secure DTLS
description: Ten rozdział zawiera opis funkcjonalny usługi Azure RTO NetX Secure DTLS.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 468f1dc8a8334dc89064594b29dc8cfabd7d8fae
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/22/2021
ms.locfileid: "104822884"
---
# <a name="chapter-3-functional-description-of-azure-rtos-netx-secure-dtls"></a><span data-ttu-id="e8120-103">Rozdział 3: Opis funkcjonalny usługi Azure RTO NetX Secure DTLS</span><span class="sxs-lookup"><span data-stu-id="e8120-103">Chapter 3: Functional description of Azure RTOS NetX Secure DTLS</span></span>

## <a name="execution-overview"></a><span data-ttu-id="e8120-104">Przegląd wykonywania</span><span class="sxs-lookup"><span data-stu-id="e8120-104">Execution Overview</span></span>

<span data-ttu-id="e8120-105">Ten rozdział zawiera opis funkcjonalny usługi Azure RTO NetX Secure DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-105">This chapter contains a functional description of Azure RTOS NetX Secure DTLS.</span></span> <span data-ttu-id="e8120-106">Istnieją dwa podstawowe typy wykonywania programu w aplikacji NetX Secure DTLS: inicjalizacje i wywołania interfejsu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e8120-106">There are two primary types of program execution in a NetX Secure DTLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="e8120-107">Zabezpieczenia NetX zakładają istnienie ThreadX i NetX/NetXDuo.</span><span class="sxs-lookup"><span data-stu-id="e8120-107">NetX Secure assumes the existence of ThreadX and NetX/NetXDuo.</span></span> <span data-ttu-id="e8120-108">Z ThreadX wymaga wykonania wątku, zawieszenia, okresowe czasomierze i wzajemnych wykluczeń.</span><span class="sxs-lookup"><span data-stu-id="e8120-108">From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities.</span></span> <span data-ttu-id="e8120-109">Z NetX/NetXDuo wymaga, aby urządzenia i sterowniki sieci UDP i IP były obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="e8120-109">From NetX/NetXDuo it requires the UDP and IP networking facilities and drivers.</span></span>

## <a name="datagram-transport-layer-security-dtls-and-transport-layer-security-tls"></a><span data-ttu-id="e8120-110">Datagram Transport Layer Security (DTLS) i Transport Layer Security (TLS)</span><span class="sxs-lookup"><span data-stu-id="e8120-110">Datagram Transport Layer Security (DTLS) and Transport Layer Security (TLS)</span></span>

<span data-ttu-id="e8120-111">NetX Secure DTLS implementuje protokół datagram Transport Layer Security w wersji 1,2 zdefiniowanej w dokumencie RFC 6347.</span><span class="sxs-lookup"><span data-stu-id="e8120-111">NetX Secure DTLS implements the Datagram Transport Layer Security protocol version 1.2 defined in RFC 6347.</span></span> <span data-ttu-id="e8120-112">DTLS w wersji 1,0 została zdefiniowana w RFC 4347 i zgodna z wersją TLS 1,1.</span><span class="sxs-lookup"><span data-stu-id="e8120-112">DTLS version 1.0 was defined in RFC 4347 and corresponded to TLS version 1.1.</span></span> <span data-ttu-id="e8120-113">Ze względu na to, że DTLS jest zasadniczo rozszerzeniem protokołu TLS, zdecydowano, że następna wersja będzie używać tego samego numeru wersji, co w odpowiedniej wersji protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-113">Due to DTLS being essentially an extension to TLS, it was decided that the next version would use the same version number as the corresponding TLS version.</span></span> <span data-ttu-id="e8120-114">W takim przypadku nie istnieje DTLS wersja 1,1, ponieważ DTLS wersja 1,2 odpowiada wersji TLS 1,2.</span><span class="sxs-lookup"><span data-stu-id="e8120-114">Thus, there is no DTLS version 1.1 as DTLS version 1.2 corresponds to TLS version 1.2.</span></span>

> [!NOTE]
> <span data-ttu-id="e8120-115">NetX Secure obsługuje DTLS w wersji 1,2.</span><span class="sxs-lookup"><span data-stu-id="e8120-115">NetX Secure supports DTLS version 1.2.</span></span> <span data-ttu-id="e8120-116">DTLS 1,0 (RFC 4347) **nie** jest obecnie obsługiwany.</span><span class="sxs-lookup"><span data-stu-id="e8120-116">DTLS 1.0 (RFC 4347) is **not** currently supported.</span></span>

<span data-ttu-id="e8120-117">*Secure Sockets Layer* (SSL) była oryginalną nazwą protokołu TLS, zanim stała się standardem RFC 2246 i "SSL" jest często używana jako nazwa ogólna dla protokołów TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-117">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and “SSL” is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="e8120-118">Ostatnia wersja protokołu SSL to 3,0, a protokół TLS 1,0 jest czasami określany jako wersja SSL 3,1.</span><span class="sxs-lookup"><span data-stu-id="e8120-118">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="e8120-119">Wszystkie wersje oficjalnego protokołu "SSL" są uznawane za przestarzałe i niezabezpieczone, a obecnie NetX Secure nie zapewnia implementacji protokołu SSL.</span><span class="sxs-lookup"><span data-stu-id="e8120-119">All versions of the official “SSL” protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="e8120-120">TLS określa protokół do generowania *kluczy sesji* , które są tworzone podczas *uzgadniania* protokołu TLS między klientem i serwerem TLS, a te klucze są używane do szyfrowania danych wysyłanych przez aplikację podczas sesji TLS *.*</span><span class="sxs-lookup"><span data-stu-id="e8120-120">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="e8120-121">DTLS jest ściśle sprzężone z protokołem TLS, ponieważ podstawowe mechansims zabezpieczeń są współużytkowane przez protokoły.</span><span class="sxs-lookup"><span data-stu-id="e8120-121">DTLS is closely coupled with TLS, as the underlying security mechansims are shared between the protocols.</span></span> <span data-ttu-id="e8120-122">Protokół TLS jest jednak przeznaczony do pracy za pośrednictwem protokołu warstwy transportowej, który zapewnia gwarancje dotyczące dostarczania pakietów i ich kolejności (prawie zawsze protokół TCP w rzeczywistości) i nie będzie działać za pośrednictwem zawodnego protokołu, takiego jak UDP.</span><span class="sxs-lookup"><span data-stu-id="e8120-122">However, TLS is designed to work over a transport layer protocol that provides guarantees about packet delivery and order (almost always TCP in practice) and will not function over an unreliable protocol like UDP.</span></span> <span data-ttu-id="e8120-123">Jest to dokładne z powodu protokołu UDP, który DTLS został wprowadzony: DTLS został zaprojektowany w celu obsługi niezawodnego charakteru protokołów UDP i podobnych.</span><span class="sxs-lookup"><span data-stu-id="e8120-123">It is precisely because of UDP that DTLS was introduced: DTLS was designed handle the unreliable nature of UDP and similar protocols.</span></span> <span data-ttu-id="e8120-124">Robi to poprzez uwzględnienie logiki określania kolejności i niezawodności (np. retransmisje porzuconych danych) Podobnie jak w przypadku niezawodnych protokołów, takich jak TCP.</span><span class="sxs-lookup"><span data-stu-id="e8120-124">It does this by including ordering and reliability logic (e.g. retransmission of dropped data) similar to reliable protocols like TCP.</span></span>

<span data-ttu-id="e8120-125">Pełne Omówienie protokołu TLS znajduje się w rozdziale 3 podręcznika użytkownika protokołu Secure TLS NetX, więc ten dokument koncentruje się na różnicach między protokołami TLS i DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-125">A complete discussion of TLS is included in Chapter 3 of the NetX Secure TLS User’s Guide, so this document will focus on the differences between TLS and DTLS.</span></span>

### <a name="dtls-record-header"></a><span data-ttu-id="e8120-126">DTLS — nagłówek rekordu</span><span class="sxs-lookup"><span data-stu-id="e8120-126">DTLS Record header</span></span>

<span data-ttu-id="e8120-127">Każdy prawidłowy rekord DTLS musi mieć nagłówek DTLS, jak pokazano na rysunku 1.</span><span class="sxs-lookup"><span data-stu-id="e8120-127">Any valid DTLS record must have a DTLS header, as shown in Figure 1.</span></span> <span data-ttu-id="e8120-128">Nagłówek jest taka sama jak w przypadku protokołu TLS z dodaniem dwóch nowych pól: 16-bitowa *Epoka* i 48-bitowy *numer sekwencyjny* opisany poniżej.</span><span class="sxs-lookup"><span data-stu-id="e8120-128">The header is the same as TLS with the addition of two new fields: the 16-bit *epoch* and the 48-bit *sequence number*, described below.</span></span>

![Diagram nagłówka rekordu DTLS.](media/image2.png)

<span data-ttu-id="e8120-130">**Rysunek 1 — nagłówek rekordu DTLS**</span><span class="sxs-lookup"><span data-stu-id="e8120-130">**Figure 1 - DTLS record header**</span></span>

<span data-ttu-id="e8120-131">Pola nagłówka rekordu TLS są zdefiniowane w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="e8120-131">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="e8120-132">Pole nagłówka TLS</span><span class="sxs-lookup"><span data-stu-id="e8120-132">TLS Header Field</span></span> | <span data-ttu-id="e8120-133">Przeznaczenie</span><span class="sxs-lookup"><span data-stu-id="e8120-133">Purpose</span></span>  |
| ---------------- | --------- |
| <span data-ttu-id="e8120-134">**8-bitowy typ komunikatu**</span><span class="sxs-lookup"><span data-stu-id="e8120-134">**8-bit Message Type**</span></span> | <span data-ttu-id="e8120-135">To pole zawiera typ wysyłanego rekordu DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-135">This field contains the type of DTLS record being sent.</span></span> <span data-ttu-id="e8120-136">Prawidłowe typy są następujące:</span><span class="sxs-lookup"><span data-stu-id="e8120-136">Valid types are as follows:</span></span><br /><span data-ttu-id="e8120-137">- ChangeCipherSpec: 0x14</span><span class="sxs-lookup"><span data-stu-id="e8120-137">- ChangeCipherSpec: 0x14</span></span><br /><span data-ttu-id="e8120-138">-Alert: 0x15</span><span class="sxs-lookup"><span data-stu-id="e8120-138">- Alert: 0x15</span></span><br /><span data-ttu-id="e8120-139">-Uzgadnianie: 0x16</span><span class="sxs-lookup"><span data-stu-id="e8120-139">- Handshake: 0x16</span></span><br /><span data-ttu-id="e8120-140">-Dane aplikacji: 0x17</span><span class="sxs-lookup"><span data-stu-id="e8120-140">- Application Data: 0x17</span></span><br /> |
| <span data-ttu-id="e8120-141">**16-bitowa wersja protokołu**</span><span class="sxs-lookup"><span data-stu-id="e8120-141">**16-bit Protocol Version**</span></span> | <span data-ttu-id="e8120-142">To pole zawiera wersję protokołu DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-142">This field contains the DTLS protocol version.</span></span> <span data-ttu-id="e8120-143">Prawidłowe wartości są następujące:</span><span class="sxs-lookup"><span data-stu-id="e8120-143">Valid values are as follows:</span></span><br /><span data-ttu-id="e8120-144">-DTLS 1,1:0xFEFD</span><span class="sxs-lookup"><span data-stu-id="e8120-144">- DTLS 1.1: 0xFEFD</span></span> |
|  <span data-ttu-id="e8120-145">**16-bitowa Epoka**</span><span class="sxs-lookup"><span data-stu-id="e8120-145">**16-bit Epoch**</span></span> |  <span data-ttu-id="e8120-146">To pole zawiera DTLS "epoki", czyli licznik, który jest zwiększany za każdym razem, gdy stan szyfrowania zostanie zmieniony (na przykład podczas generowania nowych kluczy sesji).</span><span class="sxs-lookup"><span data-stu-id="e8120-146">This field contains the DTLS “epoch” which is a counter that is incremented each time the encryption state is changed (e.g. when generating new session keys).</span></span>  |
|  <span data-ttu-id="e8120-147">**48-bitowy numer sekwencji**</span><span class="sxs-lookup"><span data-stu-id="e8120-147">**48-bit Sequence Number**</span></span> |  <span data-ttu-id="e8120-148">To pole zawiera numer sekwencyjny, który identyfikuje ten konkretny rekord.</span><span class="sxs-lookup"><span data-stu-id="e8120-148">This field contains a sequence number which identifies this particular record.</span></span> <span data-ttu-id="e8120-149">Jest on używany przez DTLS do zachowywania kolejności rekordów i sprawdzania, czy są wymagane retransmisje.</span><span class="sxs-lookup"><span data-stu-id="e8120-149">It is used by DTLS to maintain record ordering and check for retransmission need.</span></span> |
|  <span data-ttu-id="e8120-150">**16-bitowa Długość**</span><span class="sxs-lookup"><span data-stu-id="e8120-150">**16-bit Length**</span></span> |  <span data-ttu-id="e8120-151">To pole zawiera długość danych hermetyzowanych w rekordzie DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-151">This field contains the length of the data encapsulated in the DTLS record.</span></span>  |

### <a name="dtls-handshake-record-header"></a><span data-ttu-id="e8120-152">Nagłówek rekordu uzgadniania DTLS</span><span class="sxs-lookup"><span data-stu-id="e8120-152">DTLS Handshake Record header</span></span>

<span data-ttu-id="e8120-153">Każdy prawidłowy rekord uzgadniania DTLS musi mieć nagłówek uzgadniania DTLS, jak pokazano na rysunku 2.</span><span class="sxs-lookup"><span data-stu-id="e8120-153">Any valid DTLS handshake record must have a DTLS Handshake header, as shown in Figure 2.</span></span>

![Diagram nagłówka rekordu uzgadniania DTLS.](media/image3.png)

<span data-ttu-id="e8120-155">**Rysunek 2 — nagłówek rekordu uzgadniania DTLS**</span><span class="sxs-lookup"><span data-stu-id="e8120-155">**Figure 2 - DTLS Handshake record header**</span></span>

<span data-ttu-id="e8120-156">Pola nagłówka rekordu uzgadniania DTLS są zdefiniowane w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="e8120-156">The fields of the DTLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="e8120-157">Pole nagłówka TLS</span><span class="sxs-lookup"><span data-stu-id="e8120-157">TLS Header Field</span></span> | <span data-ttu-id="e8120-158">Przeznaczenie</span><span class="sxs-lookup"><span data-stu-id="e8120-158">Purpose</span></span> |
| ---------------- | ------------------------------------------------ |
| <span data-ttu-id="e8120-159">**8-bitowy typ komunikatu**</span><span class="sxs-lookup"><span data-stu-id="e8120-159">**8-bit Message Type**</span></span> | <span data-ttu-id="e8120-160">To pole zawiera typ wysyłanego rekordu DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-160">This field contains the type of DTLS record being sent.</span></span> <span data-ttu-id="e8120-161">Prawidłowe typy są następujące:</span><span class="sxs-lookup"><span data-stu-id="e8120-161">Valid types are as follows:</span></span><br /><span data-ttu-id="e8120-162">- ChangeCipherSpec: 0x14</span><span class="sxs-lookup"><span data-stu-id="e8120-162">- ChangeCipherSpec: 0x14</span></span><br /><span data-ttu-id="e8120-163">-Alert: 0x15</span><span class="sxs-lookup"><span data-stu-id="e8120-163">- Alert: 0x15</span></span><br /><span data-ttu-id="e8120-164">-Uzgadnianie: 0x16</span><span class="sxs-lookup"><span data-stu-id="e8120-164">- Handshake: 0x16</span></span><br /><span data-ttu-id="e8120-165">-Dane aplikacji: 0x17</span><span class="sxs-lookup"><span data-stu-id="e8120-165">- Application Data: 0x17</span></span> |
|  <span data-ttu-id="e8120-166">**16-bitowa Epoka**</span><span class="sxs-lookup"><span data-stu-id="e8120-166">**16-bit Epoch**</span></span> | <span data-ttu-id="e8120-167">To pole zawiera DTLS "epoki", czyli licznik, który jest zwiększany za każdym razem, gdy stan szyfrowania zostanie zmieniony (na przykład podczas generowania nowych kluczy sesji).</span><span class="sxs-lookup"><span data-stu-id="e8120-167">This field contains the DTLS “epoch” which is a counter that is incremented each time the encryption state is changed (e.g. when generating new session keys).</span></span> |
|  <span data-ttu-id="e8120-168">**48-bitowy numer sekwencji**</span><span class="sxs-lookup"><span data-stu-id="e8120-168">**48-bit Sequence Number**</span></span> | <span data-ttu-id="e8120-169">To pole zawiera numer sekwencyjny, który identyfikuje ten konkretny rekord.</span><span class="sxs-lookup"><span data-stu-id="e8120-169">This field contains a sequence number which identifies this particular record.</span></span> <span data-ttu-id="e8120-170">Jest on używany przez DTLS do zachowywania kolejności rekordów i sprawdzania, czy są wymagane retransmisje.</span><span class="sxs-lookup"><span data-stu-id="e8120-170">It is used by DTLS to maintain record ordering and check for retransmission need.</span></span> |
|  <span data-ttu-id="e8120-171">**16-bitowa wersja protokołu**</span><span class="sxs-lookup"><span data-stu-id="e8120-171">**16-bit Protocol Version**</span></span> | <span data-ttu-id="e8120-172">To pole zawiera wersję protokołu DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-172">This field contains the DTLS protocol version.</span></span> <span data-ttu-id="e8120-173">Prawidłowe wartości są następujące:</span><span class="sxs-lookup"><span data-stu-id="e8120-173">Valid values are as follows:</span></span><br /><span data-ttu-id="e8120-174">-DTLS 1,1:0xFEFD</span><span class="sxs-lookup"><span data-stu-id="e8120-174">- DTLS 1.1: 0xFEFD</span></span> |
| <span data-ttu-id="e8120-175">**16-bitowa Długość**</span><span class="sxs-lookup"><span data-stu-id="e8120-175">**16-bit Length**</span></span> | <span data-ttu-id="e8120-176">To pole zawiera długość danych hermetyzowanych w rekordzie DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-176">This field contains the length of the data encapsulated in the DTLS record.</span></span> |
| <span data-ttu-id="e8120-177">**Typ uzgadniania 8-bitowego**</span><span class="sxs-lookup"><span data-stu-id="e8120-177">**8-bit Handshake Type**</span></span> | <span data-ttu-id="e8120-178">To pole zawiera typ komunikatu uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="e8120-178">This field contains the handshake message type.</span></span> <span data-ttu-id="e8120-179">Prawidłowe wartości są następujące:</span><span class="sxs-lookup"><span data-stu-id="e8120-179">Valid values are as follows:</span></span><br /><span data-ttu-id="e8120-180">-HelloRequest: 0x00</span><span class="sxs-lookup"><span data-stu-id="e8120-180">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="e8120-181">-Komunikacie ClientHello: 0x01</span><span class="sxs-lookup"><span data-stu-id="e8120-181">- ClientHello: 0x01</span></span><br /><span data-ttu-id="e8120-182">-ServerHello: 0x02</span><span class="sxs-lookup"><span data-stu-id="e8120-182">- ServerHello: 0x02</span></span><br /><span data-ttu-id="e8120-183">-Certificate: 0x0B</span><span class="sxs-lookup"><span data-stu-id="e8120-183">- Certificate: 0x0B</span></span><br /><span data-ttu-id="e8120-184">- ServerKeyExchange: 0x0C</span><span class="sxs-lookup"><span data-stu-id="e8120-184">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="e8120-185">-CertificateRequest: 0x0D</span><span class="sxs-lookup"><span data-stu-id="e8120-185">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="e8120-186">- ServerHelloDone: 0x0E</span><span class="sxs-lookup"><span data-stu-id="e8120-186">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="e8120-187">- CertificateVerify: 0x0F</span><span class="sxs-lookup"><span data-stu-id="e8120-187">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="e8120-188">-ClientKeyExchange: 0x10</span><span class="sxs-lookup"><span data-stu-id="e8120-188">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="e8120-189">- Ukończono</span><span class="sxs-lookup"><span data-stu-id="e8120-189">- Finished</span></span> | <span data-ttu-id="e8120-190">0x14</span><span class="sxs-lookup"><span data-stu-id="e8120-190">0x14</span></span> |
| <span data-ttu-id="e8120-191">**Długość 24-bitowa**</span><span class="sxs-lookup"><span data-stu-id="e8120-191">**24-bit Length**</span></span> | <span data-ttu-id="e8120-192">To pole zawiera długość danych komunikatu uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="e8120-192">This field contains the length of the handshake message data.</span></span> |
| <span data-ttu-id="e8120-193">**16-bitowy numer sekwencji**</span><span class="sxs-lookup"><span data-stu-id="e8120-193">**16-bit Sequence Number**</span></span> | <span data-ttu-id="e8120-194">To pole zawiera numer sekwencyjny.</span><span class="sxs-lookup"><span data-stu-id="e8120-194">This field contains a sequence number.</span></span> |

### <a name="the-dtls-handshake-and-dtls-session"></a><span data-ttu-id="e8120-195">Uzgadnianie DTLS i DTLS</span><span class="sxs-lookup"><span data-stu-id="e8120-195">The DTLS Handshake and DTLS Session</span></span>

<span data-ttu-id="e8120-196">Typowe uzgadnianie DTLS jest pokazane na rysunku 3.</span><span class="sxs-lookup"><span data-stu-id="e8120-196">A typical DTLS handshake is shown in Figure 3.</span></span> <span data-ttu-id="e8120-197">Jest niemal identyczna z typowym uzgadnianiem protokołu TLS z istotną różnicą — gdy wiadomość komunikacie ClientHello jest wysyłana po raz pierwszy, serwer odpowie przy użyciu nowego komunikatu DTLS, *HelloVerifyRequest* zawierającego plik cookie.</span><span class="sxs-lookup"><span data-stu-id="e8120-197">It is nearly identical to the typical TLS handshake with an important difference – when the ClientHello message is first sent, the server responds with a new DTLS-specific message, *HelloVerifyRequest* which contains a “cookie”.</span></span> <span data-ttu-id="e8120-198">Aby można było kontynuować uzgadnianie, klient programu DTLS musi odpowiedzieć na drugą wiadomość komunikacie ClientHello zawierającą ten plik cookie.</span><span class="sxs-lookup"><span data-stu-id="e8120-198">The DTLS Client must respond with a second ClientHello message containing that cookie before the handshake can proceed.</span></span> <span data-ttu-id="e8120-199">Ten mechanizm został dodany do DTLS w celu zapobiegania określonym atakom typu "odmowa usługi" (DoS), ponieważ UDP jest protokołem bezpołączeni (protokół TCP wymaga dedykowanego połączenia/portu, tak aby protokół TLS nie odczuwał tego samego problemu).</span><span class="sxs-lookup"><span data-stu-id="e8120-199">This mechanism was added to DTLS to prevent certain Denial of Service (DoS) attacks since UDP is a connectionless protocol (TCP requires a dedicated connection/port so TLS does not suffer from the same issue).</span></span>

<span data-ttu-id="e8120-200">Uzgadnianie DTLS rozpoczyna się, gdy klient wysyła komunikat *komunikacie ClientHello* do serwera DTLS, co wskazuje na to, że wolisz rozpocząć sesję DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-200">A DTLS handshake begins when the Client sends a *ClientHello* message to a DTLS server, indicating its desire to start a DTLS session.</span></span> <span data-ttu-id="e8120-201">Komunikat zawiera informacje o szyfrowaniu, którego klient ma używać dla sesji, wraz z informacjami użytymi do wygenerowania kluczy sesji w dalszej części uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="e8120-201">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="e8120-202">Do momentu wygenerowania kluczy sesji wszystkie komunikaty w uzgadnianiu DTLS nie są szyfrowane.</span><span class="sxs-lookup"><span data-stu-id="e8120-202">Until the session keys are generated, all messages in the DTLS handshake are not encrypted.</span></span> <span data-ttu-id="e8120-203">Jak wspomniano powyżej, serwer DTLS może wysłać HelloVerifyRequest w odpowiedzi na komunikacie ClientHello, wymuszając klientowi odpowiedź z drugim zaktualizowanym komunikacie ClientHello.</span><span class="sxs-lookup"><span data-stu-id="e8120-203">As mentioned above, the DTLS Server may send a HelloVerifyRequest in response to the ClientHello, forcing the client to respond with a second updated ClientHello.</span></span>

<span data-ttu-id="e8120-204">Po odebraniu drugiego komunikatu komunikacie ClientHello serwer DTLS sprawdzi plik cookie, a w przypadku poprawnego działania zostanie wyświetlony komunikat ServerHello wskazujący na wybór opcji szyfrowania dostarczonych przez klienta.</span><span class="sxs-lookup"><span data-stu-id="e8120-204">Upon receiving the second ClientHello message, the DTLS Server will verify the cookie and if correct will respond with a ServerHello message indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="e8120-205">ServerHello następuje komunikat certyfikatu, w którym serwer udostępnia certyfikat cyfrowy do uwierzytelniania tożsamości klienta (jeśli jest używana weryfikacja X. 509).</span><span class="sxs-lookup"><span data-stu-id="e8120-205">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client (if X.509 verification is used).</span></span> <span data-ttu-id="e8120-206">Na koniec serwer wysyła komunikat ServerHelloDone, aby wskazać, że nie ma więcej komunikatów do wysłania.</span><span class="sxs-lookup"><span data-stu-id="e8120-206">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="e8120-207">Serwer może opcjonalnie wysyłać inne komunikaty po ServerHello i w niektórych przypadkach może nie wysłać komunikatu certyfikatu (na przykład gdy używane są klucze wstępne), w związku z czym konieczność komunikatu ServerHelloDone.</span><span class="sxs-lookup"><span data-stu-id="e8120-207">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message (such as when Pre-Shared Keys are used), hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="e8120-208">Gdy klient otrzyma wszystkie komunikaty serwera, ma wystarczającą ilość informacji do wygenerowania kluczy sesji.</span><span class="sxs-lookup"><span data-stu-id="e8120-208">Once the client has received all the server’s messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="e8120-209">Protokół TLS/DTLS polega na utworzeniu udostępnionego bitu danych losowych nazywanych *wstępnie głównym kluczem tajnym*, który jest stałym rozmiarem i jest używany jako inicjator do generowania wszystkich kluczy wymaganych po włączeniu szyfrowania.</span><span class="sxs-lookup"><span data-stu-id="e8120-209">TLS/DTLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="e8120-210">Wstępnie główny klucz tajny jest szyfrowany przy użyciu algorytmu klucza publicznego (np. RSA) określonego w komunikatach Hello (zobacz poniżej, aby uzyskać informacje o algorytmach klucza publicznego) i klucz publiczny dostarczony przez serwer w jego certyfikacie.</span><span class="sxs-lookup"><span data-stu-id="e8120-210">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="e8120-211">Opcjonalna funkcja TLS/DTLS o nazwie klucze wstępne (PSK) umożliwia ciphersuites, które nie korzystają z certyfikatu, ale zamiast tego używają wartości tajnej udostępnianej między hostami (zwykle za pomocą fizycznego transferu lub innej zabezpieczonej metody).</span><span class="sxs-lookup"><span data-stu-id="e8120-211">An optional TLS/DTLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="e8120-212">Po włączeniu klucza PSK klucz tajny jest używany do generowania wstępnie głównego wpisu tajnego.</span><span class="sxs-lookup"><span data-stu-id="e8120-212">When PSK is enabled, the pre-shared secret key is used to generate the Pre-Master Secret.</span></span> <span data-ttu-id="e8120-213">Zapoznaj się z sekcją dotyczącą kluczy wstępnych w sekcji "metody uwierzytelniania" poniżej.</span><span class="sxs-lookup"><span data-stu-id="e8120-213">See the section on Pre-Shared Keys in “Authentication Methods” below.</span></span>

<span data-ttu-id="e8120-214">W przypadku zwykłego uzgadniania protokołów TLS/DTLS zaszyfrowany wstępnie główny klucz tajny jest wysyłany do serwera w komunikacie ClientKeyExchange.</span><span class="sxs-lookup"><span data-stu-id="e8120-214">In a usual TLS/DTLS handshake, the encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="e8120-215">Serwer, po odebraniu komunikatu ClientKeyExchange, odszyfrowuje wstępnie główny klucz tajny przy użyciu jego klucza prywatnego i kontynuuje generowanie kluczy sesji równolegle z klientem TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-215">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS/DTLS client.</span></span>

<span data-ttu-id="e8120-216">Po wygenerowaniu kluczy sesji wszystkie dalsze komunikaty mogą być szyfrowane przy użyciu algorytmu klucza prywatnego (np. AES) wybranego w komunikatach Hello.</span><span class="sxs-lookup"><span data-stu-id="e8120-216">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="e8120-217">Jeden końcowy komunikat niezaszyfrowany o nazwie ChangeCipherSpec jest wysyłany przez klienta i serwer, aby wskazać, że wszystkie dalsze komunikaty będą szyfrowane.</span><span class="sxs-lookup"><span data-stu-id="e8120-217">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="e8120-218">Pierwszy szyfrowany komunikat Wysłany przez klienta i serwer jest również końcowym komunikatem uzgadniania protokołu TLS o nazwie zakończony.</span><span class="sxs-lookup"><span data-stu-id="e8120-218">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="e8120-219">Ten komunikat zawiera skrót wszystkich odebranych i wysłanych komunikatów uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="e8120-219">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="e8120-220">Ten skrót służy do sprawdzania, czy żaden z komunikatów w uzgadnianiu nie został naruszony ani uszkodzony (ze wskazaniem potencjalnego naruszenia zabezpieczeń).</span><span class="sxs-lookup"><span data-stu-id="e8120-220">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="e8120-221">Po odebraniu ukończonych komunikatów i sprawdzeniu wartości skrótu uzgadniania rozpocznie się sesja TLS/DTLS, a aplikacja zacznie wysyłać i odbierać dane.</span><span class="sxs-lookup"><span data-stu-id="e8120-221">Once the Finished messages are received and the handshake hashes are verified, the TLS/DTLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="e8120-222">Wszystkie dane wysyłane po obu stronach sesji TLS/DTLS są najpierw tworzone przy użyciu algorytmu wyznaczania wartości skrótu wybranego w komunikatach Hello (w celu zapewnienia integralności komunikatów) i zaszyfrowanego przy użyciu wybranego algorytmu klucza prywatnego z wygenerowanymi kluczami sesji.</span><span class="sxs-lookup"><span data-stu-id="e8120-222">All data sent by either side during the TLS/DTLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="e8120-223">Na koniec sesja TLS/DTLS może zostać zakończona pomyślnie tylko wtedy, gdy klient lub serwer wybierze tę opcję.</span><span class="sxs-lookup"><span data-stu-id="e8120-223">Finally, a TLS/DTLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="e8120-224">Obcięta sesja jest uznawana za naruszenie zabezpieczeń (ponieważ osoba atakująca może próbować uniemożliwić odbieranie wszystkich danych), więc zostanie wysłane specjalne powiadomienie, gdy jedna strona chce zakończyć sesję, nazywaną alertem CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="e8120-224">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="e8120-225">Zarówno klient, jak i serwer muszą wysyłać i przetwarzać alert CloseNotify o pomyślnym zamknięciu sesji.</span><span class="sxs-lookup"><span data-stu-id="e8120-225">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![Diagram typowej sesji uzgadniania DTLS.](media/image4.png)

<span data-ttu-id="e8120-227">**Rysunek 3 — typowe uzgadnianie DTLS**</span><span class="sxs-lookup"><span data-stu-id="e8120-227">**Figure 3- Typical DTLS handshake**</span></span>

### <a name="initialization"></a><span data-ttu-id="e8120-228">Inicjalizacja</span><span class="sxs-lookup"><span data-stu-id="e8120-228">Initialization</span></span>

<span data-ttu-id="e8120-229">Stos NetX lub NetXDuo musi być zainicjowany przed użyciem NetX Secure DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-229">The NetX or NetXDuo stack must be initialized prior to using NetX Secure DTLS.</span></span> <span data-ttu-id="e8120-230">Informacje o tym, jak poprawnie zainicjować stos TCP/IP dla operacji UDP, można znaleźć w podręczniku użytkownika NetX lub NetXDuo.</span><span class="sxs-lookup"><span data-stu-id="e8120-230">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack for UDP operation.</span></span>

<span data-ttu-id="e8120-231">Po zainicjowaniu protokołu UDP NetX można włączyć funkcję DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-231">Once NetX UDP has been initialized, DTLS can be enabled.</span></span> <span data-ttu-id="e8120-232">Wewnętrznie cały ruch sieciowy i przetwarzanie DTLS są obsługiwane przez stos NetX/NetXDuo bez konieczności interwencji użytkownika.</span><span class="sxs-lookup"><span data-stu-id="e8120-232">Internally, all DTLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="e8120-233">Jednak DTLS ma pewne konkretne wymagania, które muszą być obsługiwane niezależnie od bazowego stosu sieciowego.</span><span class="sxs-lookup"><span data-stu-id="e8120-233">However, DTLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="e8120-234">DTLS operacji klienta te parametry są przypisywane do bloku sterowania DTLS o nazwie \***NX_SECURE_DTLS_SESSION** _.</span><span class="sxs-lookup"><span data-stu-id="e8120-234">DTLS Client operation these parameters are assigned to the DTLS control block called \***NX_SECURE_DTLS_SESSION** _.</span></span> <span data-ttu-id="e8120-235">W przypadku operacji serwera DTLS blok sterowania jest wywoływany _ *_NX_SECURE_DTLS_SERVER_*\* i zawiera infrastrukturę wymaganą do obsługi wielu sesji DTLS na jednym porcie UDP — należy zauważyć, że różni się to od protokołu TLS, gdzie każda sesja TLS jest powiązana z pojedynczym portem TCP.</span><span class="sxs-lookup"><span data-stu-id="e8120-235">For DTLS Server operation, control block is called _ *_NX_SECURE_DTLS_SERVER_*\* and it contains the infrastructure needed to handle multiple DTLS sessions on a single UDP port – note that this is different from TLS where a each TLS session is bound to a single TCP port.</span></span>

<span data-ttu-id="e8120-236">Dwa tryby DTLS, serwer i klient mogą być włączone w aplikacji (ale tylko jeden tryb na gniazdo NetX), a każdy z nich ma własne określone wymagania, szczegółowo poniżej.</span><span class="sxs-lookup"><span data-stu-id="e8120-236">The two DTLS modes, Server and Client, may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

### <a name="initialization--dtls-server"></a><span data-ttu-id="e8120-237">Inicjowanie — serwer DTLS</span><span class="sxs-lookup"><span data-stu-id="e8120-237">Initialization – DTLS Server</span></span>

<span data-ttu-id="e8120-238">Tryb bezpiecznego serwera usługi NetX DTLS różni się od trybu serwera TLS ze względu na użycie protokołu UDP dla bazowego protokołu transportu sieciowego.</span><span class="sxs-lookup"><span data-stu-id="e8120-238">NetX Secure DTLS Server mode differs from TLS Server mode due to the use of UDP for the underlying network transport protocol.</span></span> <span data-ttu-id="e8120-239">W przypadku protokołu TCP port jest powiązany z pojedynczym hostem zdalnym na czas trwania sesji TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-239">With TCP, the port is bound to a single remote host for the duration of the TLS session.</span></span> <span data-ttu-id="e8120-240">Protokół UDP nie ma pojęcia dotyczącego stanu w odniesieniu do hosta zdalnego, dlatego żądania DTLS z różnych hostów będą odbierane w tym samym interfejsie UDP.</span><span class="sxs-lookup"><span data-stu-id="e8120-240">UDP has no notion of state with regard to the remote host so DTLS requests from different hosts will all be received on the same UDP interface.</span></span> <span data-ttu-id="e8120-241">W związku z tym DTLS musi zachować stan sesji zamiast polegać na gnieździe tak jak w przypadku protokołów TLS i TCP.</span><span class="sxs-lookup"><span data-stu-id="e8120-241">Therefore, DTLS must maintain session state rather than relying on the socket as with TLS and TCP.</span></span> <span data-ttu-id="e8120-242">Z tego powodu blok sterowania serwerem DTLS (NX_SECURE_DTLS_SERVER) zachowuje mapowanie informacji o hoście zdalnym (adres IP i port) do sesji DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-242">For this reason, the DTLS Server control block (NX_SECURE_DTLS_SERVER) maintains a mapping of remote host information (IP address and port) to DTLS sessions.</span></span> <span data-ttu-id="e8120-243">Wszystkie dane przychodzące w gnieździe UDP przypisanym do serwera DTLS zostaną zmapowane do istniejącej lub nowej sesji DTLS na podstawie hosta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="e8120-243">All incoming data on the UDP socket assigned to a DTLS Server will be mapped to an existing or new DTLS session based on the remote host.</span></span> <span data-ttu-id="e8120-244">Z tego powodu Tworzenie serwera DTLS wymaga kilku dodatkowych parametrów wykraczających poza potrzeb klientów TLS i DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-244">For this reason, the DTLS server creation requires several additional parameters beyond what TLS and DTLS Client need.</span></span>

<span data-ttu-id="e8120-245">Oprócz DTLS Server Control Block, TLS ciphersuites i cipher ScratchSpace/Metadata buffer, serwery DTLS wymagają buforu do obsługi sesji DTLS i bufora ponownego asemblowania pakietów używany do odszyfrowywania przychodzących rekordów DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-245">In addition to the DTLS Server control block, TLS ciphersuites, and cipher scratchspace/metadata buffer, DTLS Servers require a buffer to maintain DTLS sessions and a packet reassembly buffer used to decrypt incoming DTLS records.</span></span>

<span data-ttu-id="e8120-246">Oprócz buforów sesji serwery DTLS wymagają *certyfikatu cyfrowego*, który jest dokumentem używanym do identyfikowania serwera TLS na potrzeby połączenia z klientem TLS i certyfikatami odpowiadającymi *kluczem prywatnym*, zazwyczaj dla algorytmu szyfrowania RSA.</span><span class="sxs-lookup"><span data-stu-id="e8120-246">In addition to the session buffers, DTLS Servers require a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="e8120-247">Międzynarodowy związek telekomunikacyjny X. 509 standard określa format certyfikatu używany przez protokół TLS/DTLS i istnieje wiele narzędzi do tworzenia certyfikatów cyfrowych X. 509.</span><span class="sxs-lookup"><span data-stu-id="e8120-247">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS/DTLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="e8120-248">W przypadku NetX Secure DTLS certyfikat X. 509 musi być zakodowany binarnie przy użyciu formatu Distinguished Encoding Rules (DER) z numerem ASN. 1.</span><span class="sxs-lookup"><span data-stu-id="e8120-248">For NetX Secure DTLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="e8120-249">Algorytm DER to standardowy format binarny protokołu TLS dla certyfikatów.</span><span class="sxs-lookup"><span data-stu-id="e8120-249">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="e8120-250">Klucz prywatny skojarzony z podanym certyfikatem musi mieć format PKCS # 1 DER-Encoded.</span><span class="sxs-lookup"><span data-stu-id="e8120-250">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="e8120-251">Klucz prywatny jest używany tylko na urządzeniu i nigdy nie będzie przesyłany przez sieć.</span><span class="sxs-lookup"><span data-stu-id="e8120-251">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="e8120-252">Utrzymuj bezpieczeństwo kluczy prywatnych, ponieważ zapewniają one zabezpieczenia dotyczące komunikacji TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-252">Keep private keys safe as they provide the security for TLS/DTLS communications!</span></span>

<span data-ttu-id="e8120-253">Aby można było zainicjować certyfikat serwera DTLS, aplikacja musi udostępnić wskaźnik do buforu zawierającego certyfikat X. 509 szyfrowany algorytmem DER oraz opcjonalne dane klucza prywatnego PKCS # 1 RSA z użyciem usługi ***nx_secure_x509_certificate_intialize*** , która wypełnia strukturę **NX_SECURE_X509_CERT** odpowiednimi danymi certyfikatu do użycia przez protokół TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-253">To initialize the DTLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize*** service, which populates the **NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="e8120-254">Po zainicjowaniu certyfikatu serwera należy go dodać do bloku kontroli protokołu TLS przy użyciu usługi ***nx_secure_dtls_server_local_certificate_add*** .</span><span class="sxs-lookup"><span data-stu-id="e8120-254">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_dtls_server_local_certificate_add*** service.</span></span>

<span data-ttu-id="e8120-255">Po dodaniu certyfikatu serwera do bloku sterowania serwerem DTLS serwer może być używany do bezpiecznej komunikacji DTLS (Zobacz przykład powyżej).</span><span class="sxs-lookup"><span data-stu-id="e8120-255">Once the server’s certificate has been added to the DTLS Server control block, the server can be used for secure DTLS communications (see example above).</span></span>

### <a name="initialization--dtls-client"></a><span data-ttu-id="e8120-256">Inicjowanie — klient DTLS</span><span class="sxs-lookup"><span data-stu-id="e8120-256">Initialization – DTLS Client</span></span>

<span data-ttu-id="e8120-257">NetX bezpieczny tryb klienta DTLS jest prosty w porównaniu z serwerem DTLS, ponieważ istnieje tylko jedno połączenie wychodzące do hosta zdalnego za pośrednictwem gniazda UDP.</span><span class="sxs-lookup"><span data-stu-id="e8120-257">NetX Secure DTLS Client mode is simple in operation compared to the DTLS server since there is only a single outgoing connection to the remote host over the UDP socket.</span></span>

<span data-ttu-id="e8120-258">Aby skonfigurować klienta programu DTLS, wymagany jest *Magazyn zaufanych certyfikatów*, który jest kolekcją certyfikatów cyfrowych X. 509 szyfrowanych z zaufanych urzędów certyfikacji (CA).</span><span class="sxs-lookup"><span data-stu-id="e8120-258">To setup a DTLS Client, it requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA’s).</span></span> <span data-ttu-id="e8120-259">Te certyfikaty są zakładane przez protokół DTLS jako "zaufany" i stanowią podstawę do uwierzytelniania certyfikatów dostarczonych przez jednostki DTLS serwera do aplikacji klienta NetX Secure DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-259">These certificates are assumed by the DTLS protocol to be “trusted” and serve as the basis for authenticating certificates provided by DTLS server entities to the NetX Secure DTLS Client application.</span></span>

<span data-ttu-id="e8120-260">Certyfikat zaufanego urzędu certyfikacji może być *podpisany z podpisem własnym* lub podpisany przez inny urząd certyfikacji, w którym to przypadku certyfikat jest nazywany *POśrednim urzędem certyfikacji* (ICA).</span><span class="sxs-lookup"><span data-stu-id="e8120-260">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="e8120-261">W typowej aplikacji TLS/DTLS serwer udostępnia certyfikaty usługi ICA wraz z certyfikatem serwera, ale Jedynym wymaganiem do pomyślnego uwierzytelnienia jest to, że łańcuch wystawców (certyfikaty służące do podpisywania innych certyfikatów) może być śledzony z certyfikatu serwera z powrotem do certyfikatu zaufanego urzędu certyfikacji w zaufanym magazynie certyfikatów.</span><span class="sxs-lookup"><span data-stu-id="e8120-261">In a typical TLS/DTLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="e8120-262">Ten łańcuch jest znany jako *łańcuch zaufania* lub *łańcuch certyfikatów*.</span><span class="sxs-lookup"><span data-stu-id="e8120-262">This chain is known as a *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="e8120-263">Aby zainicjować zaufany urząd certyfikacji lub certyfikat usługi ICA, aplikacja musi udostępnić wskaźnik do buforu zawierającego certyfikat X. 509 szyfrowany algorytmem DER przy użyciu usługi ***nx_secure_x509_certificate_intialize** _, która wypełnia strukturę _ *NX_SECURE_X509_CERT** z odpowiednimi danymi certyfikatu do użycia przez protokół TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-263">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="e8120-264">Klient DTLS potrzebuje również miejsca na przydzielenie certyfikatu serwera przychodzącego (przy założeniu, że tryb klucza wstępnego nie jest używany) i bufor do asemblera pakietów do rekordów DTLS do odszyfrowania.</span><span class="sxs-lookup"><span data-stu-id="e8120-264">The DTLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used) and a buffer for assembling packets into DTLS records to be decrypted.</span></span> <span data-ttu-id="e8120-265">Te bufory są przesyłane jako parametry do usługi ***nx_secure_dtls_session_create*** (zobacz Dokumentacja interfejsu API, aby uzyskać więcej informacji).</span><span class="sxs-lookup"><span data-stu-id="e8120-265">These buffers are passed in as parameters to the ***nx_secure_dtls_session_create*** service (see API reference for more information).</span></span>

<span data-ttu-id="e8120-266">Zaufane certyfikaty, które zostały zainicjowane, są następnie dodawane do utworzonego bloku sterowania sesją DTLS za pomocą usługi ***nx_secure_dtls_session_trusted_certificate_add*** .</span><span class="sxs-lookup"><span data-stu-id="e8120-266">Trusted certificates that have been initialized are then added to the created DTLS session control block using the ***nx_secure_dtls_session_trusted_certificate_add*** service.</span></span> <span data-ttu-id="e8120-267">Niedodanie certyfikatu spowoduje niepowodzenie sesji klienta DTLS, ponieważ nie będzie można uwierzytelnić hostów serwera zdalnego przy użyciu protokołu DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-267">Failure to add a certificate will cause the DTLS Client session to fail as there will be no way for the DTLS protocol to authenticate remote server hosts.</span></span>

<span data-ttu-id="e8120-268">Po utworzeniu magazynu zaufanych certyfikatów można użyć tej sesji w celu nawiązania bezpiecznego połączenia z klientem TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-268">Once the Trusted Certificate Store has been created the session may be used to establish a secure TLS Client connection.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="e8120-269">Wywołania interfejsu aplikacji</span><span class="sxs-lookup"><span data-stu-id="e8120-269">Application Interface Calls</span></span>

<span data-ttu-id="e8120-270">NetX Secure DTLS aplikacje zazwyczaj będą wykonywać wywołania funkcji z poziomu wątków aplikacji działających w ramach RTO ThreadX.</span><span class="sxs-lookup"><span data-stu-id="e8120-270">NetX Secure DTLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="e8120-271">Niektóre inicjalizacje, szczególnie w przypadku źródłowych protokołów komunikacji sieciowej (np. UDP i IP), mogą być wywoływane z programu \*\**tx_application_define *.**</span><span class="sxs-lookup"><span data-stu-id="e8120-271">Some initialization, particularly for the underlying network communications protocols (e.g. UDP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="e8120-272">Więcej informacji na temat inicjowania komunikacji sieciowej można znaleźć w podręczniku użytkownika NetX/NetXDuo.</span><span class="sxs-lookup"><span data-stu-id="e8120-272">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="e8120-273">DTLS intensywnie wykorzystuje procedury szyfrowania, które są operacjami wymagającymi użycia procesora.</span><span class="sxs-lookup"><span data-stu-id="e8120-273">DTLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="e8120-274">Zwykle te operacje będą wykonywane w kontekście wywołania wątku.</span><span class="sxs-lookup"><span data-stu-id="e8120-274">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="dtls-session-start"></a><span data-ttu-id="e8120-275">Rozpoczęcie sesji DTLS</span><span class="sxs-lookup"><span data-stu-id="e8120-275">DTLS Session Start</span></span>

<span data-ttu-id="e8120-276">DTLS wymaga podstawowego protokołu sieciowego transportu warstwowego do działania.</span><span class="sxs-lookup"><span data-stu-id="e8120-276">DTLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="e8120-277">Zazwyczaj używany jest protokół TCP.</span><span class="sxs-lookup"><span data-stu-id="e8120-277">The protocol typically used is TCP.</span></span> <span data-ttu-id="e8120-278">Aby ustanowić NetX bezpieczną sesję TLS, należy utworzyć **NX_UDP_SOCKET** i przesłać ją do usługi **_NX_SECURE_DTLS_CLIENT_SESSION_START_** dla klientów DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-278">In order to establish a NetX Secure TLS session an **NX_UDP_SOCKET** must be created and passed into the **_nx_secure_dtls_client_session_start_** service for DTLS Clients.</span></span>

<span data-ttu-id="e8120-279">Serwery DTLS działają inaczej.</span><span class="sxs-lookup"><span data-stu-id="e8120-279">DTLS Servers operate differently.</span></span> <span data-ttu-id="e8120-280">Gniazdo UDP używane na potrzeby przychodzących żądań klienta DTLS jest zawarte w bloku sterowania NX_SECURE_DTLS_SERVER i jest inicjowane w wywołaniu \***nx_secure_dtls_server_create** _, które pobiera lokalny port UDP jako parametr.</span><span class="sxs-lookup"><span data-stu-id="e8120-280">The UDP socket used for incoming DTLS Client requests is contained within the NX_SECURE_DTLS_SERVER control block and is initialized in the call to \***nx_secure_dtls_server_create** _, which takes the local UDP port as a parameter.</span></span> <span data-ttu-id="e8120-281">_*_Nx_secure_dtls_server_start_*_ usługi jest następnie używany do uruchomienia serwera DTLS do obsługi żądań przychodzących.</span><span class="sxs-lookup"><span data-stu-id="e8120-281">The service _*_nx_secure_dtls_server_start_*_ is then used to start the DTLS Server to handle incoming requests.</span></span> <span data-ttu-id="e8120-282">Wszystkie żądania przychodzące są obsługiwane w procedurach wywołania zwrotnego dostarczonych do _nx_secure_dtls_server_create \*: jeden dla połączeń i jeden do odbierania powiadomień. Jest to aplikacja do obsługi uruchamiania sesji DTLS po odebraniu powiadomienia o połączeniu (wywołanie zwrotne powiadomienia o nawiązaniu połączenia jest wywoływane przez DTLS) przez wywołanie \***nx_secure_dtls_server_session_start**_.</span><span class="sxs-lookup"><span data-stu-id="e8120-282">All incoming requests are handled in callback routines provided to _nx_secure_dtls_server_create\*: one for connections and one for receive notifications. It is up to the application to handle starting the DTLS session when a connection notification is received (the connect notify callback is invoked by DTLS) by calling \***nx_secure_dtls_server_session_start**_.</span></span> <span data-ttu-id="e8120-283">Aplikacja musi również obsługiwać przychodzące dane po wywołaniu wywołania zwrotnego powiadomienia o odebraniu (które następuje po zakończeniu uzgadniania DTLS) przez wywołanie _ *_nx_secure_dtls_session_receive_* \*.</span><span class="sxs-lookup"><span data-stu-id="e8120-283">The application also must handle incoming data when the receive notify callback is invoked (which follows a completed DTLS handshake) by calling _\*_nx_secure_dtls_session_receive_\*\*.</span></span> <span data-ttu-id="e8120-284">Szczegóły tego elementu są podane w powyższym przykładzie i w dokumentacji interfejsu API dla każdej z powyższych wymienionych usług.</span><span class="sxs-lookup"><span data-stu-id="e8120-284">The details of this are provided in the example above and in the API reference for each of the above mentioned services.</span></span>

### <a name="dtls-packet-allocation"></a><span data-ttu-id="e8120-285">Alokacja pakietu DTLS</span><span class="sxs-lookup"><span data-stu-id="e8120-285">DTLS Packet Allocation</span></span>

<span data-ttu-id="e8120-286">NetX Secure DTLS używa tej samej struktury pakietów co NetX/NetXDuo TCP (***NX_PACKET** _), z wyjątkiem tego, że zamiast wywoływania usługi _*_nx_packet_allocate_\*_ , należy wywołać usługę _ \*_nx_secure_dtls_packet_allocate_\*\*, aby miejsce dla nagłówka DTLS mogło zostać prawidłowo przydzieloną.</span><span class="sxs-lookup"><span data-stu-id="e8120-286">NetX Secure DTLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_dtls_packet_allocate_** service must be called so that space for the DTLS header may be allocated properly.</span></span>

### <a name="dtls-session-send"></a><span data-ttu-id="e8120-287">Wysyłanie sesji DTLS</span><span class="sxs-lookup"><span data-stu-id="e8120-287">DTLS Session Send</span></span>

<span data-ttu-id="e8120-288">Po rozpoczęciu sesji TLS aplikacja może wysyłać dane przy użyciu usługi ***nx_secure_dtls_session_send*** .</span><span class="sxs-lookup"><span data-stu-id="e8120-288">Once the TLS session has started, the application may send data using the ***nx_secure_dtls_session_send*** service.</span></span> <span data-ttu-id="e8120-289">Usługa Send jest identyczna z użyciem do usługi ***nx_udp_socket_send** _, pobierając strukturę danych _ *_NX_PACKET_** zawierające przesyłane dane, docelowy adres IP i docelowy port UDP.</span><span class="sxs-lookup"><span data-stu-id="e8120-289">The send service is identical in use to the ***nx_udp_socket_send** _ service, taking an _ *_NX_PACKET_** data structure containing the data being sent, a target IP address, and a target UDP port.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="e8120-290">Podczas wysyłania danych przy użyciu nx_secure_dtls_session_send należy używać tego samego adresu IP i portu, który został użyty do ustanowienia sesji DTLS, chyba że istnieje mechanizm przenoszenia sesji na nowy adres i port UDP na bieżąco (nie jest to typowe).</span><span class="sxs-lookup"><span data-stu-id="e8120-290">When sending data using nx_secure_dtls_session_send, it is important to use the same IP address and port that were used to establish the DTLS session, unless there is a mechanism in place to move the session to a new address and UDP port on-the-fly (this is not common).</span></span>

<span data-ttu-id="e8120-291">Wszystkie dane wysyłane za pośrednictwem DTLS będą szyfrowane przez stos Secure DTLS i skonfigurowane procedury szyfrowania przed wysłaniem.</span><span class="sxs-lookup"><span data-stu-id="e8120-291">Any data sent over DTLS will be encrypted by the NX Secure DTLS stack and the configured encryption routines before being sent.</span></span>

### <a name="dtls-session-receive"></a><span data-ttu-id="e8120-292">Odbieranie sesji DTLS</span><span class="sxs-lookup"><span data-stu-id="e8120-292">DTLS Session Receive</span></span>

<span data-ttu-id="e8120-293">Po rozpoczęciu sesji DTLS aplikacja może zacząć odbierać dane przy użyciu usługi \***nx_secure_Dtls_session_receive** _.</span><span class="sxs-lookup"><span data-stu-id="e8120-293">Once the DTLS session has started, the application may begin receiving data using the \***nx_secure_Dtls_session_receive** _ service.</span></span> <span data-ttu-id="e8120-294">Podobnie jak w przypadku wysyłania sesji DTLS, ta usługa jest taka sama w użyciu do _ *_nx_udp_socket_receive_* \*, z tą różnicą, że dane przychodzące są odszyfrowywane i weryfikowane przez stos DTLS przed zwróceniem w strukturze pakietów.</span><span class="sxs-lookup"><span data-stu-id="e8120-294">Like the DTLS Session send, this service is identical in use to _\*_nx_udp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the DTLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="e8120-295">Zamykanie sesji TLS</span><span class="sxs-lookup"><span data-stu-id="e8120-295">TLS Session Close</span></span>

<span data-ttu-id="e8120-296">Po zakończeniu sesji DTLS zarówno klient, jak i serwer programu DTLS muszą wysłać Alert CloseNotify po drugiej stronie w celu zamknięcia sesji.</span><span class="sxs-lookup"><span data-stu-id="e8120-296">Once a DTLS session is complete, both the DTLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="e8120-297">Obie strony muszą odebrać i przetworzyć alert, aby upewnić się, że pomyślnie zamknięto sesję.</span><span class="sxs-lookup"><span data-stu-id="e8120-297">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="e8120-298">Jeśli host zdalny wyśle alert CloseNotify, wszystkie wywołania usługi \***nx_secure_dtls_session_receive** _ przetworzy alert, wyśle odpowiedni alert z powrotem do hosta zdalnego i zwróci wartość _ *_NX_SECURE_TLS_SESSION_CLOSED_* \*.</span><span class="sxs-lookup"><span data-stu-id="e8120-298">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_dtls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="e8120-299">Po zamknięciu sesji wszelkie dalsze próby wysłania lub odebrania danych z tą sesją DTLS zakończą się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="e8120-299">Once the session is closed, any further attempts to send or receive data with that DTLS session will fail.</span></span>

<span data-ttu-id="e8120-300">Jeśli aplikacja chce zamknąć sesję TLS, należy wywołać usługę \***nx_secure_dtls_session_end** _.</span><span class="sxs-lookup"><span data-stu-id="e8120-300">If the application wishes to close the TLS session, the \***nx_secure_dtls_session_end** _ service must be called.</span></span> <span data-ttu-id="e8120-301">Usługa wyśle alert CloseNotify i przetworzy CloseNotify odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="e8120-301">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="e8120-302">Jeśli odpowiedź nie zostanie odebrana, zostanie zwrócona wartość błędu _ \*_NX_SECURE_TLS_SESSION_CLOSE_FAIL_\*\*, co oznacza, że sesja DTLS nie została czysto ZAMKNIĘTA, możliwe naruszenie zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="e8120-302">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the DTLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tlsdtls-alerts"></a><span data-ttu-id="e8120-303">Alerty TLS/DTLS</span><span class="sxs-lookup"><span data-stu-id="e8120-303">TLS/DTLS Alerts</span></span>

<span data-ttu-id="e8120-304">Protokół TLS/DTLS został zaprojektowany w celu zapewnienia maksymalnego poziomu zabezpieczeń, dlatego każde errant zachowanie w protokole jest uznawane za potencjalne naruszenie zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="e8120-304">TLS/DTLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="e8120-305">Z tego powodu wszelkie błędy związane z przetwarzaniem komunikatów lub szyfrowaniem/odszyfrowywaniem są uznawane za błędy krytyczne, które natychmiast przerywają uzgadnianie lub sesję.</span><span class="sxs-lookup"><span data-stu-id="e8120-305">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="e8120-306">Podczas obsługi błędów w aplikacji lokalnej jest stosunkowo prosta, a host zdalny musi wiedzieć, że wystąpił błąd w celu prawidłowego obsłużenia tej sytuacji i zapobiegania wszelkim możliwym naruszeniom zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="e8120-306">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="e8120-307">Z tego powodu protokół TLS/DTLS wyśle komunikat o *alercie* do hosta zdalnego w przypadku jakiegokolwiek błędu.</span><span class="sxs-lookup"><span data-stu-id="e8120-307">For this reason, TLS/DTLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="e8120-308">Alerty są traktowane w taki sam sposób jak w przypadku innych komunikatów TLS/DTLS i są szyfrowane podczas sesji, co uniemożliwia osobie atakującej zbieranie informacji z typu dostarczonego alertu.</span><span class="sxs-lookup"><span data-stu-id="e8120-308">Alerts are treated in the same manner as any other TLS/DTLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="e8120-309">W trakcie uzgadniania wysyłane alerty są ograniczone do zakresu, aby ograniczyć ilość informacji, które mogą zostać uzyskane przez potencjalną osobę atakującą.</span><span class="sxs-lookup"><span data-stu-id="e8120-309">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="e8120-310">Alert CloseNotify używany do zamykania sesji TLS/DTLS jest jedynym alertem niekrytycznym.</span><span class="sxs-lookup"><span data-stu-id="e8120-310">The CloseNotify alert, used to close the TLS/DTLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="e8120-311">Mimo że jest on traktowany jako alert i wysyłany jako komunikat alertu, CloseNotify jest w przeciwieństwie do innych alertów, w tym nie wskazuje, że wystąpił błąd.</span><span class="sxs-lookup"><span data-stu-id="e8120-311">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

### <a name="tlsdtls-session-renegotiation-and-resumption"></a><span data-ttu-id="e8120-312">Ponowne negocjowanie i wznowienie sesji TLS/DTLS</span><span class="sxs-lookup"><span data-stu-id="e8120-312">TLS/DTLS Session Renegotiation and Resumption</span></span>

<span data-ttu-id="e8120-313">Protokół TLS obsługuje pojęcie "renegocjacji", która jest po prostu ponowną negocjacją parametrów sesji TLS w kontekście istniejącej sesji TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-313">TLS supports the notion of “renegotiation” which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span>

<span data-ttu-id="e8120-314">*Wznowienie* sesji protokołu TLS nie powinno być pomylone z ponowną *negocjacją* sesji pomimo pewnych podobieństw.</span><span class="sxs-lookup"><span data-stu-id="e8120-314">TLS session *resumption* should not be confused with session *renegotiation*, despite some similarities.</span></span> <span data-ttu-id="e8120-315">Gdy ponowne *negocjowanie* sesji obejmuje rozpoczęcie nowego uzgadniania w istniejącej sesji protokołu TLS, *wznowienie* sesji jest funkcją opcjonalną, która polega na ponownym uruchomieniu zamkniętej sesji TLS bez wykonywania pełnej uzgadniania protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-315">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span>

<span data-ttu-id="e8120-316">Secure DTLS obsługuje przychodzące żądania renegocjacji z hostów zdalnych.</span><span class="sxs-lookup"><span data-stu-id="e8120-316">NX Secure DTLS handles incoming renegotiation requests from remote hosts.</span></span> <span data-ttu-id="e8120-317">**Nie obsługuje** wznawiania sesji.</span><span class="sxs-lookup"><span data-stu-id="e8120-317">It does **not** support session resumption.</span></span> <span data-ttu-id="e8120-318">Dokładniejsze Omówienie tych funkcji można znaleźć w rozdziale 3 podręcznika użytkownika bezpiecznego protokołu TLS NetX.</span><span class="sxs-lookup"><span data-stu-id="e8120-318">A more complete discussion of these features can be found in Chapter 3 of the NetX Secure TLS User Guide.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="e8120-319">Warstwy protokołu</span><span class="sxs-lookup"><span data-stu-id="e8120-319">Protocol Layering</span></span>

<span data-ttu-id="e8120-320">Protokół TLS (i w związku z tym DTLS również) mieści się w stosie sieci między warstwą transportu (np. TCP lub UDP) i warstwą aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e8120-320">The TLS protocol (and therefore DTLS as well) fits into the networking stack between the transport layer (e.g. TCP or UDP) and the application layer.</span></span> <span data-ttu-id="e8120-321">Protokoły TLS są czasami uważane za protokół warstwy transportu (w związku z czym zabezpieczenia *warstwy transportowej* ), ale ponieważ działa jako aplikacja w odniesieniu do bazowych protokołów sieciowych, czasami pogrupowane w warstwę aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e8120-321">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="e8120-322">Protokół TLS wymaga protokołu warstwy transportowej, który obsługuje dostarczanie w kolejności i bezstratne, takie jak TCP.</span><span class="sxs-lookup"><span data-stu-id="e8120-322">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="e8120-323">Ze względu na to wymaganie protokół TLS nie może działać na podstawie protokołu UDP, ponieważ protokół UDP nie gwarantuje dostarczania datagramów.</span><span class="sxs-lookup"><span data-stu-id="e8120-323">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="e8120-324">*DTLS* jest zmodyfikowaną wersją protokołu TLS, która jest używana dla aplikacji, które wymagają zabezpieczeń TLS za pośrednictwem protokołu datagramu, takiego jak UDP.</span><span class="sxs-lookup"><span data-stu-id="e8120-324">*DTLS* is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span>

![Diagram warstw protokołu TLS.](media/image6.png)

<span data-ttu-id="e8120-326">**Rysunek 4 — warstwy protokołów TCP/IP, UDP i TLS/DTLS**</span><span class="sxs-lookup"><span data-stu-id="e8120-326">**Figure 4- TCP/IP, UDP and TLS/DTLS protocol layers**</span></span>

## <a name="network-communications-security-and-encryption"></a><span data-ttu-id="e8120-327">Bezpieczeństwo i szyfrowanie komunikacji sieciowej</span><span class="sxs-lookup"><span data-stu-id="e8120-327">Network Communications Security and Encryption</span></span>

<span data-ttu-id="e8120-328">Zabezpieczanie komunikacji za pośrednictwem sieci publicznych oraz Internet jest ważnym tematem i tematem ogromnej liczby książek, artykułów i rozwiązań.</span><span class="sxs-lookup"><span data-stu-id="e8120-328">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="e8120-329">Temat jest bogglingly złożony, ale może być zredukowany do prostego pomysłu: wysłanie informacji za pośrednictwem sieci, tak aby tylko przewidziany obiekt docelowy mógł uzyskać dostęp do tych informacji lub je zmienić.</span><span class="sxs-lookup"><span data-stu-id="e8120-329">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="e8120-330">Ten podział na trzy ważne koncepcje: utajnienie, integralność i uwierzytelnianie.</span><span class="sxs-lookup"><span data-stu-id="e8120-330">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="e8120-331">Protokół TLS/DTLS zapewnia rozwiązania dla wszystkich trzech.</span><span class="sxs-lookup"><span data-stu-id="e8120-331">The TLS/DTLS protocol provides solutions for all three.</span></span>

<span data-ttu-id="e8120-332">Szyfrowanie jest używane na różne sposoby zapewniania tajemnicy, integralności i uwierzytelniania w ramach protokołów TLS i DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-332">Encryption is used in different ways to provide secrecy, integrity, and authentication within the TLS and DTLS protocols.</span></span> <span data-ttu-id="e8120-333">Szyfrowanie musi być dostarczone do protokołu TLS lub DTLS podczas tworzenia sesji lub wystąpienia serwera, ponieważ protokół TLS zapewnia elastyczną platformę do korzystania z szyfrowania, a nie samego szyfrowania.</span><span class="sxs-lookup"><span data-stu-id="e8120-333">The encryption must be supplied to TLS or DTLS upon creation of a session or server instance as TLS provides a flexible framework for using encryption and not the encryption itself.</span></span> <span data-ttu-id="e8120-334">NetX Secure DTLS zapewnia niezbędne procedury szyfrowania dla większości aplikacji, dzięki czemu nie trzeba mieć potrzeby znajdowania odpowiedniego szyfrowania.</span><span class="sxs-lookup"><span data-stu-id="e8120-334">NetX Secure DTLS provides the necessary encryption routines for most applications so you do not have to be concerned about finding appropriate encryption.</span></span>

<span data-ttu-id="e8120-335">Bardziej szczegółowy opis tych tematów można znaleźć w rozdziale 3 podręcznika użytkownika bezpiecznego protokołu TLS NetX.</span><span class="sxs-lookup"><span data-stu-id="e8120-335">A more detailed description of these topics can be found in Chapter 3 of the NetX Secure TLS User Guide.</span></span>

## <a name="tls-and-dtls-extensions"></a><span data-ttu-id="e8120-336">Rozszerzenia TLS i DTLS</span><span class="sxs-lookup"><span data-stu-id="e8120-336">TLS and DTLS Extensions</span></span>

<span data-ttu-id="e8120-337">Protokoły TLS (i w związku z tym DTLS) udostępniają wiele rozszerzeń zapewniających dodatkowe funkcje dla określonych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e8120-337">TLS (and therefore DTLS) provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="e8120-338">Te rozszerzenia są zwykle wysyłane jako część komunikatów komunikacie ClientHello lub ServerHello, co oznacza, że host zdalny chce użyć rozszerzenia lub podać dodatkowe szczegóły do użycia podczas ustanawiania bezpiecznej sesji protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-338">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="e8120-339">NetX Secure DTLS obsługuje wszystkie rozszerzenia Znalezione w NetX Secure TLS, a pełny opis tych rozszerzeń można znaleźć w podręczniku użytkownika NetX Secure TLS, rozdział 3.</span><span class="sxs-lookup"><span data-stu-id="e8120-339">NetX Secure DTLS supports all of the extensions found in NetX Secure TLS, and a complete description of those can be found in the NetX Secure TLS User Guide, Chapter 3.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="e8120-340">Metody uwierzytelniania</span><span class="sxs-lookup"><span data-stu-id="e8120-340">Authentication Methods</span></span>

<span data-ttu-id="e8120-341">Protokoły TLS i DTLS zapewniają strukturę służącą do ustanawiania bezpiecznego połączenia między dwoma urządzeniami za pośrednictwem niezabezpieczonej sieci, ale część problemu świadczy tożsamość urządzenia na drugim końcu tego połączenia.</span><span class="sxs-lookup"><span data-stu-id="e8120-341">TLS and DTLS provide the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="e8120-342">Bez mechanizmu uwierzytelniania tożsamości hostów zdalnych, jest to prosta operacja dla osoby atakującej, która będzie stanowić zaufane urządzenie.</span><span class="sxs-lookup"><span data-stu-id="e8120-342">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="e8120-343">Początkowo może się wydawać, że korzystanie z adresów IP, sprzętowych adresów MAC lub systemu DNS zapewni stosunkowo wysoki poziom zaufania do identyfikowania hostów w sieci, ale z uwzględnieniem rodzaju technologii TCP/IP i prostoty, z jakimi adresami mogą być sfałszowane i wpisy DNS są uszkodzone (np</span><span class="sxs-lookup"><span data-stu-id="e8120-343">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="e8120-344">Istnieją różne mechanizmy, które mogą zapewnić tę dodatkową warstwę uwierzytelniania dla protokołu TLS, ale najbardziej typowym *certyfikatem cyfrowym.*</span><span class="sxs-lookup"><span data-stu-id="e8120-344">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="e8120-345">Inne mechanizmy obejmują klucze wstępne (PSK) i schematy haseł.</span><span class="sxs-lookup"><span data-stu-id="e8120-345">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="e8120-346">Digital instalowane</span><span class="sxs-lookup"><span data-stu-id="e8120-346">Digital Cerificates</span></span>

<span data-ttu-id="e8120-347">Certyfikaty cyfrowe są najczęściej spotykaną metodą uwierzytelniania hosta zdalnego w protokole TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-347">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="e8120-348">Zasadniczo certyfikat cyfrowy to dokument z określonym formatowaniem, który zawiera informacje o tożsamości dla urządzenia w sieci komputerowej.</span><span class="sxs-lookup"><span data-stu-id="e8120-348">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="e8120-349">Protokół TLS zwykle korzysta z formatu o nazwie X. 509, który jest standardem opracowanym przez międzynarodowy związek telekomunikacyjny, ale inne formaty certyfikatów mogą być używane, Jeśli hosty TLS mogą wyrazić zgodę na używany format.</span><span class="sxs-lookup"><span data-stu-id="e8120-349">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="e8120-350">X. 509 definiuje określony format certyfikatów i różnych kodowań, których można użyć do utworzenia dokumentu cyfrowego.</span><span class="sxs-lookup"><span data-stu-id="e8120-350">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="e8120-351">Większość certyfikatów X. 509 używanych z protokołem TLS jest zakodowana przy użyciu wariantu numeru ASN 1, innego standardu telekomunikacyjnego.</span><span class="sxs-lookup"><span data-stu-id="e8120-351">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="e8120-352">W ASN. 1 istnieje różne kodowanie cyfrowe, ale najpopularniejsze kodowanie certyfikatów TLS jest standardem Distinguished Encoding Rules (DER).</span><span class="sxs-lookup"><span data-stu-id="e8120-352">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="e8120-353">DER to uproszczony podzbiór podstawowych reguł kodowania ASN. 1, które zostały zaprojektowane jako niejednoznaczne, co ułatwia analizowanie.</span><span class="sxs-lookup"><span data-stu-id="e8120-353">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="e8120-354">W sieci, certyfikaty TLS są zwykle zakodowane w formacie binarnym DER i jest to format, który NetX bezpiecznego dla certyfikatów X. 509.</span><span class="sxs-lookup"><span data-stu-id="e8120-354">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="e8120-355">Certyfikaty binarne w formacie DER są używane w rzeczywistym protokole TLS, ale mogą być generowane i przechowywane w wielu różnych kodowaniach, z rozszerzeniami plików, takimi jak PEM, CRT i. p12.</span><span class="sxs-lookup"><span data-stu-id="e8120-355">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="e8120-356">Różne warianty są używane przez różne aplikacje od różnych producentów, ale ogólnie wszystkie mogą być konwertowane na algorytm DER przy użyciu szeroko dostępnych narzędzi.</span><span class="sxs-lookup"><span data-stu-id="e8120-356">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="e8120-357">Najbardziej typowymi alternatywami kodowania certyfikatów jest PEM.</span><span class="sxs-lookup"><span data-stu-id="e8120-357">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="e8120-358">Format PEM (z Privacy-Enhanced mail) jest zakodowaną w oparciu o wersję 64 kodowaniem algorytmu DER, która jest często używana, ponieważ kodowanie skutkuje tekstem drukowalnym, który można łatwo wysyłać przy użyciu poczty e-mail lub protokołów opartych na sieci Web.</span><span class="sxs-lookup"><span data-stu-id="e8120-358">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="e8120-359">Generowanie certyfikatu dla bezpiecznej aplikacji NetX jest zwykle poza zakresem tego podręcznika, ale narzędzie wiersza polecenia OpenSSL ([www.OpenSSL.org](http://www.openssl.org)) jest szeroko dostępne i może być konwertowane między większością formatów.</span><span class="sxs-lookup"><span data-stu-id="e8120-359">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="e8120-360">W zależności od aplikacji można generować własne certyfikaty, otrzymywać certyfikaty od producenta lub organizacji rządowej lub zakupić certyfikaty od komercyjnego urzędu certyfikacji.</span><span class="sxs-lookup"><span data-stu-id="e8120-360">Depending on your application, you may generate your own certificates, be provided certificates by a manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="e8120-361">Aby użyć certyfikatu cyfrowego w bezpiecznej aplikacji NetX, należy najpierw przekonwertować certyfikat na format binarny DER, a opcjonalnie przekonwertować skojarzony klucz prywatny ("wykładnik prywatny" dla RSA, na przykład) na format binarny, zazwyczaj w formacie PKCS # 1, który jest szyfrowany kluczem RSA.</span><span class="sxs-lookup"><span data-stu-id="e8120-361">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the “private exponent” for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key.</span></span> <span data-ttu-id="e8120-362">Po zakończeniu konwersji załadujesz certyfikat i klucz prywatny na urządzeniu.</span><span class="sxs-lookup"><span data-stu-id="e8120-362">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="e8120-363">Możliwe opcje obejmują używanie systemu plików opartego na technologii Flash lub generowanie macierzy C na podstawie danych (za pomocą narzędzia takiego jak "XXD" w systemie Linux) i kompilowanie certyfikatu i klucza w aplikacji jako danych stałych.</span><span class="sxs-lookup"><span data-stu-id="e8120-363">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as “xxd” from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="e8120-364">Po załadowaniu certyfikatu na urządzenie można użyć interfejsu API DTLS w celu skojarzenia certyfikatu z sesją DTLS lub serwerem.</span><span class="sxs-lookup"><span data-stu-id="e8120-364">Once your certificate is loaded onto the device, the DTLS API can be used to associate your certificate with a DTLS session or server.</span></span>

<span data-ttu-id="e8120-365">Aby uzyskać szczegółowe informacje i przykłady użycia certyfikatów X. 509 z NetX Secure DTLS, zobacz sekcję "Importowanie certyfikatów X. 509 do usługi NetX Secure" w podręczniku użytkownika NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-365">For details and examples on how to use X.509 certificates with NetX Secure DTLS, see the section “Importing X.509 certificates into NetX Secure” in the NetX Secure TLS User Guide.</span></span>

<span data-ttu-id="e8120-366">Aby uzyskać więcej informacji, zapoznaj się z następującymi usługami DTLS Services w dokumentacji interfejsu API:</span><span class="sxs-lookup"><span data-stu-id="e8120-366">Refer to the following DTLS services in the API reference for more information:</span></span>

- <span data-ttu-id="e8120-367">nx_secure_x509_certificate_initialize,</span><span class="sxs-lookup"><span data-stu-id="e8120-367">nx_secure_x509_certificate_initialize,</span></span>
- <span data-ttu-id="e8120-368">nx_secure_dtls_session_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="e8120-368">nx_secure_dtls_session_local_certificate_add,</span></span>
- <span data-ttu-id="e8120-369">nx_secure_dtls_server_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="e8120-369">nx_secure_dtls_server_local_certificate_add,</span></span>
- <span data-ttu-id="e8120-370">nx_secure_dtls_session_local_certificate_remove,</span><span class="sxs-lookup"><span data-stu-id="e8120-370">nx_secure_dtls_session_local_certificate_remove,</span></span>
- <span data-ttu-id="e8120-371">nx_secure_dtls_server_local_certificate_remove,</span><span class="sxs-lookup"><span data-stu-id="e8120-371">nx_secure_dtls_server_local_certificate_remove,</span></span>
- <span data-ttu-id="e8120-372">nx_secure_dtls_session_trusted_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="e8120-372">nx_secure_dtls_session_trusted_certificate_add,</span></span>
- <span data-ttu-id="e8120-373">nx_secure_dtls_server_trusted_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="e8120-373">nx_secure_dtls_server_trusted_certificate_add,</span></span>
- <span data-ttu-id="e8120-374">nx_secure_dtls_session_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="e8120-374">nx_secure_dtls_session_trusted_certificate_remove</span></span>
- <span data-ttu-id="e8120-375">nx_secure_dtls_server_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="e8120-375">nx_secure_dtls_server_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="e8120-376">Specyficzne dla certyfikatu klienta TLS</span><span class="sxs-lookup"><span data-stu-id="e8120-376">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="e8120-377">DTLS implementacje klientów zazwyczaj nie wymagają ładowania certyfikatu lokalnego na urządzeniu.</span><span class="sxs-lookup"><span data-stu-id="e8120-377">DTLS Client implementations generally do not require a local certificate to be loaded onto the device.</span></span> <span data-ttu-id="e8120-378">Certyfikat lokalny to certyfikat, który identyfikuje urządzenie lokalne.</span><span class="sxs-lookup"><span data-stu-id="e8120-378">A local certificate is a certificate that identifies the local device.</span></span> <span data-ttu-id="e8120-379">W związku z tym certyfikat lokalny zawiera informacje o tożsamości dla urządzenia, na którym załadowana jest aplikacja TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-379">Specifically, a local certificate provides identity information for the device upon which the TLS/DTLS application is loaded.</span></span> <span data-ttu-id="e8120-380">Wyjątkiem jest to, kiedy uwierzytelnianie certyfikatu klienta jest włączone, ale jest to mniej typowe.</span><span class="sxs-lookup"><span data-stu-id="e8120-380">The exception to this is when Client Certificate Authentication is enabled, but this is less common.</span></span>

<span data-ttu-id="e8120-381">Klient DTLS wymaga załadowania co najmniej jednego zaufanego certyfikatu (jeśli jest to wymagane) i miejsca na przydzielenie certyfikatu zdalnego.</span><span class="sxs-lookup"><span data-stu-id="e8120-381">A DTLS Client requires at least one trusted certificate to be loaded (more may be loaded if required), and space for a remote certificate to be allocated.</span></span> <span data-ttu-id="e8120-382">Zaufany certyfikat to certyfikat, który stanowi podstawę do zaufania i uwierzytelniania urządzenia zdalnego, bezpośrednio lub za pomocą infrastruktury kluczy publicznych (PKI).</span><span class="sxs-lookup"><span data-stu-id="e8120-382">A trusted certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="e8120-383">Katalog główny łańcucha zaufania jest zwykle nazywany urzędem certyfikacji lub certyfikatem urzędu certyfikacji.</span><span class="sxs-lookup"><span data-stu-id="e8120-383">The root of the chain of trust is usually called a Certification Authority or CA certificate.</span></span> <span data-ttu-id="e8120-384">Certyfikat zdalny odwołuje się do certyfikatu wysyłanego przez hosta zdalnego podczas uzgadniania TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-384">A remote certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="e8120-385">Zapewnia tożsamość dla tego hosta zdalnego i jest uwierzytelniany przez porównanie go z zaufanym certyfikatem na urządzeniu lokalnym.</span><span class="sxs-lookup"><span data-stu-id="e8120-385">It provides identity for that remote host and is authenticated by comparing it to a trusted certificate on the local device.</span></span>

<span data-ttu-id="e8120-386">Aby uzyskać więcej informacji na temat dodawania zaufanych certyfikatów i przydzielania miejsca dla certyfikatów zdalnych, zobacz Dokumentacja interfejsu API protokołu TLS dla następujących usług: nx_secure_dtls_session_create, nx_secure_dtls_session_trusted_certificate_add.</span><span class="sxs-lookup"><span data-stu-id="e8120-386">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_dtls_session_create, nx_secure_dtls_session_trusted_certificate_add.</span></span>

### <a name="tlsdtls-server-certificate-specifics"></a><span data-ttu-id="e8120-387">Specyficzne dla certyfikatu serwera TLS/DTLS</span><span class="sxs-lookup"><span data-stu-id="e8120-387">TLS/DTLS Server Certificate Specifics</span></span>

<span data-ttu-id="e8120-388">Implementacje serwera DTLS zazwyczaj nie wymagają "zaufanych" certyfikatów do załadowania na urządzenie lub certyfikaty zdalne do przydzielenia.</span><span class="sxs-lookup"><span data-stu-id="e8120-388">DTLS Server implementations generally do not require “trusted” certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="e8120-389">Wyjątek do tej sytuacji, gdy jest włączone uwierzytelnianie certyfikatu klienta.</span><span class="sxs-lookup"><span data-stu-id="e8120-389">The exception to this being when Client Certificate Authentication is enabled.</span></span>

<span data-ttu-id="e8120-390">Serwer TLS wymaga załadowania certyfikatu "Local" (lub "Identity"), aby serwer mógł udostępnić go klientowi zdalnemu podczas uzgadniania protokołu TLS w celu uwierzytelnienia serwera na komputerze klienckim.</span><span class="sxs-lookup"><span data-stu-id="e8120-390">A TLS Server requires a “local” (or “identity”) certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="e8120-391">Aby uzyskać więcej informacji na temat ładowania certyfikatów lokalnych do użycia z aplikacjami serwera NetX TLS, zobacz Dokumentacja interfejsu API dla następujących usług: nx_secure_dtls_server_local_certificate_add, nx_secure_dtls_server_local_certificate_remove.</span><span class="sxs-lookup"><span data-stu-id="e8120-391">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services: nx_secure_dtls_server_local_certificate_add, nx_secure_dtls_server_local_certificate_remove.</span></span>


### <a name="pre-shared-keys-psk"></a><span data-ttu-id="e8120-392">Klucze wstępne (PSK)</span><span class="sxs-lookup"><span data-stu-id="e8120-392">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="e8120-393">Alternatywny mechanizm zapewnienia uwierzytelniania tożsamości w protokole TLS jest pojęciem kluczy wstępnych (PSK).</span><span class="sxs-lookup"><span data-stu-id="e8120-393">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="e8120-394">Użycie ciphersuite PSK eliminuje konieczność wykonywania operacji szyfrowania klucza publicznego intensywnie korzystających z procesora, Boon dla urządzeń osadzonych z ograniczeniami zasobów.</span><span class="sxs-lookup"><span data-stu-id="e8120-394">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="e8120-395">PSK zastępuje certyfikat w uzgadnianiu TLS/DTLS i jest używany zamiast szyfrowanego wstępnego klucza tajnego do generowania kluczy sesji TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-395">The PSK replaces the certificate in the TLS/DTLS handshake and is used in place of the encrypted Pre-Master Secret for TLS/DTLS session key generation.</span></span>

<span data-ttu-id="e8120-396">Ciphersuites PSK jest ograniczony w tym sensie, że wspólny klucz tajny musi być obecny na obu urządzeniach przed ustanowieniem sesji TLS/DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-396">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS/DTLS session can be established.</span></span> <span data-ttu-id="e8120-397">Oznacza to, że urządzenia muszą zostać załadowane za pomocą tego klucza tajnego, przy użyciu niebezpiecznych środków innych niż połączenie protokołu TLS z certyfikatem PSK — PSKs może zostać zaktualizowany za pośrednictwem połączenia z kluczem PSK protokołu TLS, ale urządzenie musi być uruchamiane z kluczem PSK, który jest ładowany przez inny mechanizm.</span><span class="sxs-lookup"><span data-stu-id="e8120-397">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="e8120-398">Na przykład urządzenie czujnika i jego urządzenie bramy mogą zostać załadowane przy użyciu PSKs w fabryce przed wysyłką lub do załadowania klucza PSK przy użyciu standardowego połączenia TLS (z certyfikatem).</span><span class="sxs-lookup"><span data-stu-id="e8120-398">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="e8120-399">Ciphersuites PSK to kilka form, które opisano w dokumencie RFC 4279.</span><span class="sxs-lookup"><span data-stu-id="e8120-399">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="e8120-400">W pierwszej kolejności są używane klucze RSA lub Diffie-Hellman, które są używane w taki sam sposób, jak klucze publiczne przesyłane w certyfikacie w standardowym uzgadnianiu protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-400">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="e8120-401">Drugi formularz, który jest bardziej używany w środowisku z ograniczeniami zasobów, korzysta z klucza PSK, który jest używany do bezpośredniej generacji kluczy sesji (na przykład do użycia przez algorytm AES), unikając korzystania z kosztownych operacji RSA lub Diffie-Hellman.</span><span class="sxs-lookup"><span data-stu-id="e8120-401">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="e8120-402">NetX Secure obsługuje drugą formę klucza PSK ciphersuites, umożliwiając aplikacjom usuwanie wszystkich kodów kryptograficznych i użycie pamięci klucza publicznego.</span><span class="sxs-lookup"><span data-stu-id="e8120-402">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="e8120-403">Sam klucz PSK nie jest kluczem AES, ale może być traktowany jak hasło, z którego są generowane rzeczywiste klucze.</span><span class="sxs-lookup"><span data-stu-id="e8120-403">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="e8120-404">Istnieje kilka ograniczeń dotyczących tego, co może być wartością klucza PSK, ale dłuższe wartości zapewniają większe bezpieczeństwo (takie same jak w przypadku haseł).</span><span class="sxs-lookup"><span data-stu-id="e8120-404">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="e8120-405">Aby korzystać z klucza PSK w bezpiecznej aplikacji NetX, należy najpierw zdefiniować globalne makro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span><span class="sxs-lookup"><span data-stu-id="e8120-405">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="e8120-406">Zwykle odbywa się to za pomocą ustawień kompilatora, ale definicja może być również umieszczona w pliku nagłówkowym nx_secure_tls. h.</span><span class="sxs-lookup"><span data-stu-id="e8120-406">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="e8120-407">Po zdefiniowaniu makra obsługa klucza PSK ciphersuite zostanie skompilowana do aplikacji NetX Secure DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-407">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure DTLS application.</span></span>

<span data-ttu-id="e8120-408">W przypadku włączenia obsługi PSK, można użyć interfejsu API DTLS, aby skonfigurować PSKs dla swojej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e8120-408">With PSK support enabled, you can then use the DTLS API to set up PSKs for your application.</span></span> <span data-ttu-id="e8120-409">Każdy PSK będzie wymagał wartości PSK (rzeczywisty klucz tajny) — Zapewnij bezpieczną wartość), wartość "Identity" służącą do identyfikowania określonego klucza PSK oraz "wskazówkę tożsamości", która jest używana przez serwer TLS do wybierania określonej wartości klucza PSK.</span><span class="sxs-lookup"><span data-stu-id="e8120-409">Each PSK will require a PSK value (the actual secret “key” – keep this value safe), an “identity” value used to identify the specific PSK, and an “identity hint” that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="e8120-410">Sam PSK może być dowolną wartością binarną, ponieważ nigdy nie jest wysyłana za pośrednictwem połączenia sieciowego.</span><span class="sxs-lookup"><span data-stu-id="e8120-410">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="e8120-411">Wartość PSK może być dowolną wartością o długości do 64 bajtów.</span><span class="sxs-lookup"><span data-stu-id="e8120-411">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="e8120-412">Tożsamość i Wskazówka muszą być drukowalne ciągi znaków sformatowane przy użyciu kodowania UTF-8.</span><span class="sxs-lookup"><span data-stu-id="e8120-412">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="e8120-413">Wartości Identity i Hint mogą mieć długość do 128 bajtów.</span><span class="sxs-lookup"><span data-stu-id="e8120-413">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="e8120-414">Tożsamość i PSK tworzą unikatową parę, która jest ładowana na każde urządzenie w sieci, które musi komunikować się ze sobą.</span><span class="sxs-lookup"><span data-stu-id="e8120-414">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="e8120-415">"Wskazówka" jest używana głównie do definiowania profilów aplikacji w celu grupowania PSKs przez funkcję lub usługę.</span><span class="sxs-lookup"><span data-stu-id="e8120-415">The “hint” is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="e8120-416">Te wartości muszą być uzgadniane z wyprzedzeniem i są zależne od aplikacji.</span><span class="sxs-lookup"><span data-stu-id="e8120-416">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="e8120-417">Przykładowo aplikacja serwera wiersza polecenia OpenSSL (z włączonym PSK) używa domyślnego ciągu "Client_identity", który musi być dostarczony przez klienta TLS w celu kontynuowania uzgadniania TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-417">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string “Client_identity”, which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="e8120-418">Aby uzyskać więcej informacji na temat PSKs, zobacz Dokumentacja bezpiecznego interfejsu API NetX dla następujących usług: nx_secure_dtls_psk_add, nx_secure_dtls_server_psk_add.</span><span class="sxs-lookup"><span data-stu-id="e8120-418">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_dtls_psk_add, nx_secure_dtls_server_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="e8120-419">Importowanie certyfikatów X. 509 do NetX Secure</span><span class="sxs-lookup"><span data-stu-id="e8120-419">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="e8120-420">Certyfikaty cyfrowe są wymagane dla większości połączeń TLS w Internecie.</span><span class="sxs-lookup"><span data-stu-id="e8120-420">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="e8120-421">Certyfikaty zapewniają metodę uwierzytelniania wcześniej nieznanych hostów za pośrednictwem Internetu przy użyciu zaufanych wystawców, *zwykle nazywanych urzędami certyfikacji lub* urzędami certyfikacji.</span><span class="sxs-lookup"><span data-stu-id="e8120-421">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="e8120-422">Aby połączyć NetX bezpieczne urządzenie z usługą w chmurze komercyjnej (taką jak Amazon Web Services), należy zaimportować certyfikaty do aplikacji, ładując je na urządzenie.</span><span class="sxs-lookup"><span data-stu-id="e8120-422">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="e8120-423">Wraz z certyfikatami czasami potrzebny jest również *klucz prywatny* skojarzony z certyfikatem.</span><span class="sxs-lookup"><span data-stu-id="e8120-423">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="e8120-424">W niektórych aplikacjach (takich jak klient protokołu TLS, gdy uwierzytelnianie certyfikatu klienta nie jest używane) certyfikat będzie wystarczający, ale jeśli certyfikat jest używany do identyfikowania urządzenia, potrzebny będzie klucz prywatny.</span><span class="sxs-lookup"><span data-stu-id="e8120-424">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="e8120-425">Klucze prywatne są zwykle generowane podczas tworzenia certyfikatu i są przechowywane w osobnym pliku, często szyfrowane przy użyciu hasła.</span><span class="sxs-lookup"><span data-stu-id="e8120-425">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

<span data-ttu-id="e8120-426">Szczegółowy opis importowania certyfikatów do bezpiecznych aplikacji NetX można znaleźć w rozdziale 3 w podręczniku użytkownika NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-426">For a detailed description of importing certificates into NetX Secure applications, please refer to Chapter 3 in the NetX Secure TLS User Guide.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="e8120-427">Uwierzytelnianie certyfikatu klienta w protokole Secure TLS NetX</span><span class="sxs-lookup"><span data-stu-id="e8120-427">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="e8120-428">W przypadku korzystania z uwierzytelniania certyfikatu X. 509 protokół TLS/DTLS wymaga, aby wystąpienie serwera DTLS dostarczać certyfikat do identyfikacji, ale domyślnie wystąpienie klienta DTLS nie musi podawać certyfikatu do uwierzytelnienia przy użyciu innej formy uwierzytelniania (np. kombinacji nazwy użytkownika/hasła).</span><span class="sxs-lookup"><span data-stu-id="e8120-428">When using X.509 certificate authentication, the TLS/DTLS protocol requires that the DTLS Server instance provide a certificate for identification, but by default the DTLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="e8120-429">Jest to zgodne z najbardziej typowym wykorzystaniem protokołu TLS w Internecie dla witryn sieci Web.</span><span class="sxs-lookup"><span data-stu-id="e8120-429">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="e8120-430">Na przykład witryna handlu detalicznego w trybie online musi udowodnić potencjalnemu klientowi korzystanie z przeglądarki sieci Web, że serwer jest wiarygodny, ale użytkownik użyje nazwy logowania/hasła w celu uzyskania dostępu do określonego konta.</span><span class="sxs-lookup"><span data-stu-id="e8120-430">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="e8120-431">Jednak domyślny przypadek nie zawsze jest pożądany, więc protokół TLS/DTLS opcjonalnie zezwala na wystąpienie serwera DTLS o zażądanie certyfikatu od klienta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="e8120-431">However, the default case is not always desirable, so TLS/DTLS optionally allows for the DTLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="e8120-432">Po włączeniu tej funkcji serwer DTLS wyśle do klienta DTLS komunikat CertificateRequest podczas uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="e8120-432">When this feature is enabled, the DTLS Server will send a CertificateRequest message to the DTLS Client during the handshake.</span></span> <span data-ttu-id="e8120-433">Klient musi odpowiedzieć własnym certyfikatem, a komunikat CertificateVerify zawierający token kryptograficzny wskazujący, że klient jest właścicielem zgodnego klucza prywatnego skojarzonego z tym certyfikatem.</span><span class="sxs-lookup"><span data-stu-id="e8120-433">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="e8120-434">Jeśli weryfikacja nie powiedzie się lub certyfikat nie jest połączony z zaufanym certyfikatem na serwerze, uzgadnianie TLS nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="e8120-434">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="e8120-435">Istnieją dwa oddzielne przypadki uwierzytelniania certyfikatu klienta w protokole TLS — w poniższych sekcjach omówiono oba przypadki.</span><span class="sxs-lookup"><span data-stu-id="e8120-435">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-dtls-clients"></a><span data-ttu-id="e8120-436">Uwierzytelnianie certyfikatu klienta dla klientów DTLS</span><span class="sxs-lookup"><span data-stu-id="e8120-436">Client Certificate Authentication for DTLS Clients</span></span>

<span data-ttu-id="e8120-437">Klient DTLS może próbować nawiązać połączenie z serwerem, który żąda certyfikatu do uwierzytelnienia klienta.</span><span class="sxs-lookup"><span data-stu-id="e8120-437">A DTLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="e8120-438">W takim przypadku klient musi dostarczyć certyfikat do serwera i upewnić się, że jest właścicielem zgodnego klucza prywatnego lub serwer zakończy uzgadnianie DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-438">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the DTLS handshake.</span></span>

<span data-ttu-id="e8120-439">W NetX Secure DTLS nie ma specjalnej konfiguracji do obsługi tej funkcji, ale aplikacja będzie musiała podać lokalny certyfikat identyfikacyjny dla wystąpienia klienta TLS przy użyciu usługi *nx_secure_tls_session_local_certificate_add* .</span><span class="sxs-lookup"><span data-stu-id="e8120-439">In NetX Secure DTLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_session_local_certificate_add* service.</span></span> <span data-ttu-id="e8120-440">Jeśli aplikacja nie udostępnia żadnego certyfikatu, ale serwer zdalny używa uwierzytelniania certyfikatu klienta i żąda certyfikatu, uzgadnianie DTLS zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="e8120-440">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the DTLS handshake will fail.</span></span> <span data-ttu-id="e8120-441">Aby można było wykonać uzgadnianie DTLS, certyfikat dostarczony do sesji DTLS z *nx_secure_dtls_session_local_certificate_add* musi być rozpoznawany przez serwer zdalny.</span><span class="sxs-lookup"><span data-stu-id="e8120-441">The certificate provided to the DTLS Session with *nx_secure_dtls_session_local_certificate_add* must be recognized by the remote server in order to complete the DTLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="e8120-442">Uwierzytelnianie certyfikatu klienta dla serwerów TLS</span><span class="sxs-lookup"><span data-stu-id="e8120-442">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="e8120-443">Przypadek serwera DTLS dla uwierzytelniania certyfikatu klienta jest nieco bardziej skomplikowany niż przypadek klienta DTLS ze względu na opcjonalną funkcję.</span><span class="sxs-lookup"><span data-stu-id="e8120-443">The DTLS Server case for Client Certificate Authentication is slightly more complex than the DTLS Client case due to the feature being optional.</span></span> <span data-ttu-id="e8120-444">W takim przypadku serwer TLS musi jawnie zażądać certyfikatu ze zdalnego klienta TLS, a następnie przetworzyć komunikat CertificateVerify, aby sprawdzić, czy Klient zdalny jest właścicielem pasującego klucza prywatnego, a następnie serwer musi sprawdzić, czy certyfikat dostarczony przez klienta może być śledzony do certyfikatu w lokalnym magazynie zaufanych certyfikatów.</span><span class="sxs-lookup"><span data-stu-id="e8120-444">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="e8120-445">W przypadku wystąpień serwera Secure TLS NetX uwierzytelnianie certyfikatu klienta jest kontrolowane przez *nx_secure_dtls_server_x509_client_verify_configure* i *nx_secure_dtls_server_x509_client_verify_disable* usług.</span><span class="sxs-lookup"><span data-stu-id="e8120-445">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by the *nx_secure_dtls_server_x509_client_verify_configure* and *nx_secure_dtls_server_x509_client_verify_disable* services.</span></span>

<span data-ttu-id="e8120-446">Aby włączyć uwierzytelnianie certyfikatu klienta, aplikacja musi wywoływać *nx_secure_dtls_server_x509_client_verify_configure* z wystąpieniem sesji serwera DTLS przed wywołaniem *nx_secure_dtls_server_start*.</span><span class="sxs-lookup"><span data-stu-id="e8120-446">To enable Client Certificate Authentication, an application must call *nx_secure_dtls_server_x509_client_verify_configure* with the DTLS Server session instance before calling *nx_secure_dtls_server_start*.</span></span> <span data-ttu-id="e8120-447">Weryfikacja wymaga przydzielenia miejsca na przychodzące certyfikaty klienta podane jako parametr do *nx_secure_dtls_server_x509_client_verify_configure.*</span><span class="sxs-lookup"><span data-stu-id="e8120-447">The verification requires space to be allocated for incoming client certificates which is provided as a parameter to *nx_secure_dtls_server_x509_client_verify_configure.*</span></span> <span data-ttu-id="e8120-448">Należy pamiętać, że bufor musi być wystarczająco duży, aby pomieścić maksymalny rozmiar łańcucha certyfikatów dostarczony przez klienta *pomnożonego przez liczbę sesji serwera DTLS*.</span><span class="sxs-lookup"><span data-stu-id="e8120-448">Note that the buffer must be large enough to hold the maximum-size certificate chain provided by a client *times the number of DTLS server sessions*.</span></span> <span data-ttu-id="e8120-449">Każda sesja serwera wymaga miejsca, które zostanie przydzielony z pojedynczego dostarczonego buforu.</span><span class="sxs-lookup"><span data-stu-id="e8120-449">Each server session requires space which will be allocated from the single provided buffer.</span></span> <span data-ttu-id="e8120-450">Upewnij się, że bufor jest wystarczająco duży lub wystąpi błąd, jeśli podany łańcuch certyfikatów klienta jest zbyt duży.</span><span class="sxs-lookup"><span data-stu-id="e8120-450">Make sure the buffer is large enough or an error will occur if the provided Client certificate chain is too large.</span></span>

<span data-ttu-id="e8120-451">Po włączeniu uwierzytelniania certyfikatu klienta serwer DTLS żąda certyfikatu z klienta zdalnego DTLS podczas uzgadniania DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-451">When Client Certificate Authentication is enabled, the DTLS Server will request a certificate from the remote DTLS Client during the DTLS handshake.</span></span> <span data-ttu-id="e8120-452">W programie NetX Secure DTLS Server certyfikat klienta jest sprawdzany pod kątem magazynu zaufanych certyfikatów utworzonych przy użyciu *nx_secure_dtls_server_trusted_certificate_add* przez następujący łańcuch wystawcy X. 509.</span><span class="sxs-lookup"><span data-stu-id="e8120-452">In NetX Secure DTLS Server, the Client certificate is checked against the store of trusted certificates created with *nx_secure_dtls_server_trusted_certificate_add* by following the X.509 issuer chain.</span></span> <span data-ttu-id="e8120-453">Klient zdalny musi dostarczyć łańcuch, który łączy jego certyfikat tożsamości z certyfikatem w zaufanym magazynie lub uzgadnianie DTLS zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="e8120-453">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the DTLS handshake will fail.</span></span> <span data-ttu-id="e8120-454">Ponadto jeśli przetwarzanie komunikatu CertificateVerify nie powiedzie się, uzgadnianie DTLS również zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="e8120-454">Additionally, if the CertificateVerify message processing fails, the DTLS handshake will also fail.</span></span>

<span data-ttu-id="e8120-455">Metody podpisu używane dla metody CertificateVerify są ustalone dla protokołów TLS w wersji 1,0 i TLS w wersji 1,1 i są określone przez serwer TLS w wersji TLS 1,2, na podstawie którego jest oparty NetX Secure DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-455">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2, upon which NetX Secure DTLS is based.</span></span> <span data-ttu-id="e8120-456">W przypadku DTLS 1,2 metody podpisywania są ogólnie zgodne z odpowiednimi metodami podanymi w tabeli metod kryptograficznych, ale zazwyczaj RSA z algorytmem SHA-256 (patrz sekcja "Kryptografia w NetX Secure TLS"), aby uzyskać więcej informacji na temat inicjowania protokołu TLS przy użyciu metod kryptograficznych).</span><span class="sxs-lookup"><span data-stu-id="e8120-456">For DTLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section “Cryptography in NetX Secure TLS” for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="e8120-457">Kryptografia w protokole Secure TLS NetX</span><span class="sxs-lookup"><span data-stu-id="e8120-457">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="e8120-458">TLS definiuje protokół, w którym Kryptografia może być używana do zabezpieczania komunikacji sieciowej.</span><span class="sxs-lookup"><span data-stu-id="e8120-458">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="e8120-459">W związku z tym pozostawi rzeczywiste kryptografie do użycia w postaci otwartej dla użytkowników protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-459">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="e8120-460">Specyfikacja wymaga tylko jednego ciphersuite do zaimplementowania — w przypadku protokołu TLS 1,2, że ciphersuite jest TLS_RSA_WITH_AES_128_CBC_SHA, wskazując użycie RSA dla operacji klucza publicznego, AES w trybie CBC z 128-bitowymi kluczami dla szyfrowania sesji i algorytmem SHA-1 dla skrótów uwierzytelniania komunikatów.</span><span class="sxs-lookup"><span data-stu-id="e8120-460">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="e8120-461">Jest zgodny z protokołem TLS 1,2, NetX Secure domyślnie włącza obowiązkowy TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite, ale biorąc pod uwagę liczbę możliwych implementacji dla każdej z metod kryptograficznych ze względu na możliwości sprzętowe i inne zagadnienia, NetX Secure zapewnia ogólny interfejs API kryptografii, który umożliwia użytkownikowi określenie metod kryptograficznych, które mają być używane z protokołem TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-461">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

> [!NOTE]
> <span data-ttu-id="e8120-462">Mechanizm ogólnego interfejsu API kryptografii umożliwia również użytkownikom zaimplementowanie własnych ciphersuites, ale jest to zalecane dla zaawansowanych użytkowników, którzy znają ciphersuites TLS i rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="e8120-462">The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="e8120-463">Skontaktuj się z przedstawicielem programu Express Logic, Jeśli interesuje Cię obsługę własnych ciphersuites.</span><span class="sxs-lookup"><span data-stu-id="e8120-463">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

<span data-ttu-id="e8120-464">Zapoznaj się ze szczegółowymi informacjami na temat sposobu konfigurowania metod kryptograficznych dla usługi DTLS, w rozdziale 3 podręcznika użytkownika NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-464">Please see the NetX Secure TLS User Guide, Chapter 3 for a detailed discussion about how to configure cryptographic methods for DTLS.</span></span> <span data-ttu-id="e8120-465">Ten sam proces dotyczy protokołów TLS i DTLS.</span><span class="sxs-lookup"><span data-stu-id="e8120-465">The same process applies to both TLS and DTLS.</span></span>
