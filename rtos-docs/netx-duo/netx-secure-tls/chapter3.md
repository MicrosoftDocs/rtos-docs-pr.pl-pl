---
title: Rozdział 3 — Opis funkcjonalny usługi Azure RTO NetX Secure
description: Ten rozdział zawiera opis funkcjonalny protokołu Secure TLS NetX.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: c28ad0255f99986a4ddfe5faefad81e70840e5e0
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/22/2021
ms.locfileid: "104821589"
---
# <a name="chapter-3---functional-description-of-azure-rtos-netx-secure"></a><span data-ttu-id="ac926-103">Rozdział 3 — Opis funkcjonalny usługi Azure RTO NetX Secure</span><span class="sxs-lookup"><span data-stu-id="ac926-103">Chapter 3 - Functional description of Azure RTOS NetX Secure</span></span>

## <a name="execution-overview"></a><span data-ttu-id="ac926-104">Przegląd wykonywania</span><span class="sxs-lookup"><span data-stu-id="ac926-104">Execution Overview</span></span>

<span data-ttu-id="ac926-105">Ten rozdział zawiera opis funkcjonalny usługi Azure RTO NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-105">This chapter contains a functional description of Azure RTOS NetX Secure TLS.</span></span> <span data-ttu-id="ac926-106">Istnieją dwa podstawowe typy wykonywania programu w aplikacji NetX Secure TLS: inicjalizacja i wywołania interfejsu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-106">There are two primary types of program execution in a NetX Secure TLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="ac926-107">*Zabezpieczenia NetX zakładają istnienie ThreadX i NetX/NetXDuo. Z ThreadX wymaga wykonania wątku, zawieszenia, okresowe czasomierze i wzajemnych wykluczeń. Z NetX/NetXDuo wymaga sieci TCP/IP i sterowników.*</span><span class="sxs-lookup"><span data-stu-id="ac926-107">*NetX Secure assumes the existence of ThreadX and NetX/NetXDuo. From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities. From NetX/NetXDuo it requires the TCP/IP networking facilities and drivers.*</span></span>

## <a name="transport-layer-security-tls-and-secure-sockets-layer-ssl"></a><span data-ttu-id="ac926-108">Transport Layer Security (TLS) i Secure Sockets Layer (SSL)</span><span class="sxs-lookup"><span data-stu-id="ac926-108">Transport Layer Security (TLS) and Secure Sockets Layer (SSL)</span></span>

<span data-ttu-id="ac926-109">Składnik Secure Network Protocol NetX Secure to Transport Layer Security implementacja protokołu TLS, zgodnie z opisem w RFC 2246 (wersja 1,0), 4346 (wersja 1,1), 5246 (wersja 1,2) i 8446 (wersja 1,3).</span><span class="sxs-lookup"><span data-stu-id="ac926-109">The secure network protocol component of NetX secure is an implementation of the Transport Layer Security (TLS) protocol as described in RFCs 2246 (version 1.0), 4346 (version 1.1), 5246 (version 1.2) and 8446 (version 1.3).</span></span> <span data-ttu-id="ac926-110">Uwzględniono również procedury obsługi dla podstawowego X. 509 (RFC 5280).</span><span class="sxs-lookup"><span data-stu-id="ac926-110">Also included are support routines for basic X.509 (RFC 5280).</span></span>

<span data-ttu-id="ac926-111">NetX Secure TLS obsługuje protokół TLS w wersji 1,2 i 1,3.</span><span class="sxs-lookup"><span data-stu-id="ac926-111">NetX Secure TLS supports TLS versions 1.2 and 1.3.</span></span> <span data-ttu-id="ac926-112">Implementacje są dostępne dla obecnie przestarzałych protokołów TLS 1,0 i TLS 1,1, ale muszą być jawnie zainicjowane i nie są zalecane do użycia w nowych produktach.</span><span class="sxs-lookup"><span data-stu-id="ac926-112">Implementations are provided for the now-deprecated TLS 1.0 and TLS 1.1, but they must be explicitly initialized and are not recommended for use in new products.</span></span>

<span data-ttu-id="ac926-113">*Secure Sockets Layer* (SSL) była oryginalną nazwą protokołu TLS, zanim stała się standardem RFC 2246 i "SSL" jest często używana jako nazwa ogólna dla protokołów TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-113">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and "SSL" is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="ac926-114">Ostatnia wersja protokołu SSL to 3,0, a protokół TLS 1,0 jest czasami określany jako wersja SSL 3,1.</span><span class="sxs-lookup"><span data-stu-id="ac926-114">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="ac926-115">Wszystkie wersje oficjalnego protokołu "SSL" są uznawane za przestarzałe i niezabezpieczone, a obecnie NetX Secure nie zapewnia implementacji protokołu SSL.</span><span class="sxs-lookup"><span data-stu-id="ac926-115">All versions of the official "SSL" protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="ac926-116">TLS określa protokół do generowania *kluczy sesji* , które są tworzone podczas *uzgadniania* protokołu TLS między klientem i serwerem TLS, a te klucze są używane do szyfrowania danych wysyłanych przez aplikację podczas sesji TLS *.*</span><span class="sxs-lookup"><span data-stu-id="ac926-116">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="ac926-117">Dane protokołu TLS są podzielone na *rekordy* , które są równoważne koncepcji dla pakietu TCP.</span><span class="sxs-lookup"><span data-stu-id="ac926-117">TLS data is divided into *records* which are equivalent in concept to a TCP packet.</span></span> <span data-ttu-id="ac926-118">Każdy rekord TLS ma nagłówek, a zaszyfrowane rekordy TLS również mają stopkę (skrót sumy kontrolnej).</span><span class="sxs-lookup"><span data-stu-id="ac926-118">Every TLS record has a header, and TLS encrypted records also have a footer (checksum hash).</span></span> <span data-ttu-id="ac926-119">Rekordy uzgadniania protokołu TLS mają dodatkowy nagłówek hermetyzowany w większym rekordzie TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-119">TLS handshake records have an additional header encapsulated within the larger TLS record.</span></span> <span data-ttu-id="ac926-120">Rekord TLS jest hermetyzowany przez protokół sieciowy warstwy transportu w taki sam sposób, w jaki pakiet protokołu TCP jest hermetyzowany przez pakiet IP.</span><span class="sxs-lookup"><span data-stu-id="ac926-120">The TLS record is encapsulated by the  transport layer network protocol in the same manner that a TCP packet is encapsulated by an IP packet.</span></span>

### <a name="tls-13"></a><span data-ttu-id="ac926-121">TLS 1,3</span><span class="sxs-lookup"><span data-stu-id="ac926-121">TLS 1.3</span></span>

<span data-ttu-id="ac926-122">W sierpniu 2018 Specyfikacja TLS 1,3 została sfinalizowana.</span><span class="sxs-lookup"><span data-stu-id="ac926-122">In August 2018, the TLS 1.3 specification was finalized.</span></span> <span data-ttu-id="ac926-123">Nowa wersja protokołu to dość znacząca aktualizacja, która zmienia podstawowe aspekty zabezpieczeń i wydajności protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-123">The new version of the protocol is a fairly significant update that changes some fundamental aspects of the underlying security and performance of TLS.</span></span> <span data-ttu-id="ac926-124">Jednak te zmiany są znacznie niewidoczne dla typowego użytkownika protokołu TLS, ponieważ dotyczą przede wszystkim do komputera stanu uzgadniania TLS i generowania klucza sesji.</span><span class="sxs-lookup"><span data-stu-id="ac926-124">However, these changes are largely invisible to the typical TLS user since they apply primarily to the TLS handshake state machine and session key generation.</span></span> <span data-ttu-id="ac926-125">Dodano również kilka opcjonalnych funkcji i rozszerzeń.</span><span class="sxs-lookup"><span data-stu-id="ac926-125">A number of optional features and extensions were added as well.</span></span> <span data-ttu-id="ac926-126">Poniżej znajduje się podsumowanie zmian i ich wpływu na funkcjonalność protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-126">The following is a summary of the changes and how they impact TLS functionality.</span></span>

- <span data-ttu-id="ac926-127">Komputer stanu uzgadniania został zoptymalizowany przez usunięcie całej wymiany komunikatów przez serwer.</span><span class="sxs-lookup"><span data-stu-id="ac926-127">The handshake state machine was optimized by removing an entire exchange of messages by the server.</span></span>
- <span data-ttu-id="ac926-128">Generowanie klucza zostało zaktualizowane w celu użycia znormalizowanej procedury o nazwie HKDF (funkcja wyprowadzania klucza opartego na procesorze HMAC) i łączy klucze sesji ze wszystkimi komunikatami uzgadniania (zamiast kilku parametrów wyboru).</span><span class="sxs-lookup"><span data-stu-id="ac926-128">Key generation was updated to use a standardized routine called HKDF (HMAC-based Key Derivation Function) and ties the session keys to all of the handshake messages (instead of a few select parameters).</span></span>
- <span data-ttu-id="ac926-129">Wszystkie protokoły TLS 1,2 i wcześniejsze ciphersuites są przestarzałe i nie są zgodne z protokołem TLS 1,3.</span><span class="sxs-lookup"><span data-stu-id="ac926-129">All TLS 1.2 and earlier ciphersuites are deprecated and are incompatible with TLS 1.3.</span></span> <span data-ttu-id="ac926-130">Podobnie wszystkie ciphersuites TLS 1,3 są bezużyteczne z poprzednimi wersjami.</span><span class="sxs-lookup"><span data-stu-id="ac926-130">Similarly, all TLS 1.3 ciphersuites are unusable with previous versions.</span></span>
- <span data-ttu-id="ac926-131">Wszystkie protokoły TLS 1,3 ciphersuites zapewniają doskonałe utajnienie przekazywania (PFS) przy użyciu kluczy tymczasowych<sup>6</sup></span><span class="sxs-lookup"><span data-stu-id="ac926-131">All TLS 1.3 ciphersuites provide Perfect Forward Secrecy (PFS) using ephemeral keys<sup>6</sup></span></span> 
- <span data-ttu-id="ac926-132">Protokół TLS 1,3 usuwa "kod uwierzytelniania wiadomości" (MAC) w każdym rekordzie na korzyść przy użyciu szyfrów AEAD<sup>7</sup></span><span class="sxs-lookup"><span data-stu-id="ac926-132">TLS 1.3 removes the "message authentication code" (MAC) in each record in favor of using AEAD<sup>7</sup> ciphers</span></span>
- <span data-ttu-id="ac926-133">Dodano kilka dodatkowych funkcji opcjonalnych, w tym 0-RTT (czas błądzenia zero), co pozwala na wysyłanie danych aplikacji podczas uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-133">Some additional optional features were added, including 0-RTT (Zero Round Trip Time) which allows for application data to be sent during the handshake.</span></span> <span data-ttu-id="ac926-134">0 — RTT jest czysto opcjonalny i nie jest obecnie obsługiwany w usłudze Azure RTO TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-134">0-RTT is purely optional and is not currently supported in Azure RTOS TLS.</span></span>

<span data-ttu-id="ac926-135">Protokół TLS 1,3 nie ma znacząco wpływu na aplikacje użytkownika.</span><span class="sxs-lookup"><span data-stu-id="ac926-135">TLS 1.3 does not significantly affect user applications.</span></span> <span data-ttu-id="ac926-136">Interfejs API pozostaje dokładnie taki sam między wersjami, a ciphersuites są oznaczane, aby można było użyć pojedynczej tabeli ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="ac926-136">The API remains exactly the same between versions, and ciphersuites are marked so a single ciphersuite table may be used.</span></span>

<span data-ttu-id="ac926-137">Aby można było korzystać z protokołu TLS 1,3, makro NX_SECURE_TLS_ENABLE_TLS_1_3 musi być zdefiniowane globalnie.</span><span class="sxs-lookup"><span data-stu-id="ac926-137">In order to use TLS 1.3, the macro NX_SECURE_TLS_ENABLE_TLS_1_3 must be globally defined.</span></span> <span data-ttu-id="ac926-138">Protokół TLS 1,3 jest domyślnie wyłączony w usłudze Azure RTO TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-138">TLS 1.3 is disabled by default in Azure RTOS TLS.</span></span>

6. <span data-ttu-id="ac926-139">Klucze "tymczasowych" to asymetryczne pary kluczy, które są generowane podczas uzgadniania protokołu TLS i używane do wymiany kluczy tajnych tylko dla tej sesji.</span><span class="sxs-lookup"><span data-stu-id="ac926-139">“Ephemeral” keys are asymmetric key pairs that are generated during the TLS handshake and used for the secrets exchange for only that session.</span></span> <span data-ttu-id="ac926-140">Para kluczy jest odrzucana po użyciu — uniemożliwia to osobie atakującej dostęp do zaszyfrowanych danych w rejestrowanej sesji TLS, nawet jeśli w przyszłości zostanie naruszony klucz prywatny certyfikatu, a tym samym "doskonałe utajnienie przekazywania dalej".</span><span class="sxs-lookup"><span data-stu-id="ac926-140">They key pair is discarded after use – this prevents an attacker from being able to access encrypted data in a recorded TLS session even if a certificate private key is compromised at any time in the future – hence “Perfect Forward Secrecy”.</span></span>

7. <span data-ttu-id="ac926-141">Uwierzytelnione szyfrowanie za pomocą skojarzonych danych — tryb szyfrowania, taki jak AES, który łączy szyfrowanie i sprawdzanie integralności w ramach jednej operacji, eliminując konieczność oddzielnego skrótu danych do sprawdzania integralności.</span><span class="sxs-lookup"><span data-stu-id="ac926-141">Authenticated Encryption with Associated Data – a mode for ciphers like AES that combines encryption and integrity checking in a single operation, eliminating the need for a separate hash of the data for integrity checking.</span></span>

### <a name="tls-record-header"></a><span data-ttu-id="ac926-142">Nagłówek rekordu TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-142">TLS Record header</span></span>

<span data-ttu-id="ac926-143">Każdy prawidłowy rekord TLS musi mieć nagłówek TLS, jak pokazano w błędzie.</span><span class="sxs-lookup"><span data-stu-id="ac926-143">Any valid TLS record must have a TLS header, as shown in Error!</span></span> <span data-ttu-id="ac926-144">Nie znaleziono źródła odwołania.</span><span class="sxs-lookup"><span data-stu-id="ac926-144">Reference source not found.</span></span>

![Diagram nagłówka rekordu TLS.](media/image2.png)

<span data-ttu-id="ac926-146">Rysunek 1 — nagłówek rekordu TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-146">Figure 1 - TLS record header</span></span>

<span data-ttu-id="ac926-147">Pola nagłówka rekordu TLS są zdefiniowane w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="ac926-147">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="ac926-148">Pole nagłówka TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-148">TLS Header Field</span></span> | <span data-ttu-id="ac926-149">Przeznaczenie</span><span class="sxs-lookup"><span data-stu-id="ac926-149">Purpose</span></span>     |
| ---------------- | ------------- |
| <span data-ttu-id="ac926-150">**8-bitowy typ komunikatu**</span><span class="sxs-lookup"><span data-stu-id="ac926-150">**8-bit Message Type**</span></span> | <span data-ttu-id="ac926-151">To pole zawiera typ wysyłanego rekordu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-151">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="ac926-152">Prawidłowe typy są następujące:</span><span class="sxs-lookup"><span data-stu-id="ac926-152">Valid types are as follows:</span></span><br /><span data-ttu-id="ac926-153">-ChangeCipherSpec<sup>8</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="ac926-153">- ChangeCipherSpec<sup>8</sup>: 0x14</span></span><br /><span data-ttu-id="ac926-154">-Alert: 0x15</span><span class="sxs-lookup"><span data-stu-id="ac926-154">- Alert: 0x15</span></span><br /><span data-ttu-id="ac926-155">-Uzgadnianie: 0x16</span><span class="sxs-lookup"><span data-stu-id="ac926-155">- Handshake: 0x16</span></span><br /><span data-ttu-id="ac926-156">-Dane aplikacji: 0x17</span><span class="sxs-lookup"><span data-stu-id="ac926-156">- Application Data: 0x17</span></span> |
| <span data-ttu-id="ac926-157">**16-bitowa wersja protokołu**</span><span class="sxs-lookup"><span data-stu-id="ac926-157">**16-bit Protocol Version**</span></span> | <span data-ttu-id="ac926-158">To pole zawiera wersję protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-158">This field contains the TLS protocol version.</span></span> <span data-ttu-id="ac926-159">Prawidłowe wartości są następujące:</span><span class="sxs-lookup"><span data-stu-id="ac926-159">Valid values are as follows:</span></span><br /><span data-ttu-id="ac926-160">-SSL 3,0:0x0300</span><span class="sxs-lookup"><span data-stu-id="ac926-160">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="ac926-161">-TLS 1,0:0x0301</span><span class="sxs-lookup"><span data-stu-id="ac926-161">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="ac926-162">-TLS 1,1:0x0302</span><span class="sxs-lookup"><span data-stu-id="ac926-162">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="ac926-163">-TLS 1,2:0x0303</span><span class="sxs-lookup"><span data-stu-id="ac926-163">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="ac926-164">- **TLS 1,3 <sup>9</sup>**: **0x0303**</span><span class="sxs-lookup"><span data-stu-id="ac926-164">- **TLS 1.3 <sup>9</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="ac926-165">**16-bitowa Długość**</span><span class="sxs-lookup"><span data-stu-id="ac926-165">**16-bit Length**</span></span> | <span data-ttu-id="ac926-166">To pole zawiera długość danych hermetyzowanych w rekordzie TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-166">This field contains the length of the data encapsulated in the TLS record.</span></span> |

8. <span data-ttu-id="ac926-167">W protokole TLS 1,3 komunikat ChangeCipherSpec nie jest już używany, mimo że może być przesłany ze względu na zgodność, w takim przypadku komunikat jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="ac926-167">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

9. <span data-ttu-id="ac926-168">Protokół TLS 1,3 ma technicznie wartość 0x0304, jeśli ten schemat był kontynuowany, ale został zmieniony w taki sposób, aby miał rzeczywistą wersję protokołu w rozszerzeniu, więc wszystkie rekordy protokołu TLS 1,3 używają 0x0303 w polach wersji protokołu w celu zapewnienia zgodności z poprzednimi wersjami.</span><span class="sxs-lookup"><span data-stu-id="ac926-168">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="tls-handshake-record-header"></a><span data-ttu-id="ac926-169">Nagłówek rekordu uzgadniania protokołu TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-169">TLS Handshake Record header</span></span>

<span data-ttu-id="ac926-170">Każdy prawidłowy rekord uzgadniania TLS musi mieć nagłówek uzgadniania TLS, jak pokazano na rysunku 2.</span><span class="sxs-lookup"><span data-stu-id="ac926-170">Any valid TLS handshake record must have a TLS Handshake header, as shown in Figure 2.</span></span>

![Diagram nagłówka rekordu uzgadniania protokołu TLS.](media/image3.png)

<span data-ttu-id="ac926-172">Rysunek 2 — nagłówek rekordu uzgadniania TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-172">Figure 2 - TLS Handshake record header</span></span>

<span data-ttu-id="ac926-173">Pola nagłówka rekordu uzgadniania protokołu TLS są zdefiniowane w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="ac926-173">The fields of the TLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="ac926-174">Pole nagłówka TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-174">TLS Header Field</span></span> | <span data-ttu-id="ac926-175">Przeznaczenie</span><span class="sxs-lookup"><span data-stu-id="ac926-175">Purpose</span></span> |
| ---------------- |----------------------- |
| <span data-ttu-id="ac926-176">**8-bitowy typ komunikatu**</span><span class="sxs-lookup"><span data-stu-id="ac926-176">**8-bit Message Type**</span></span> | <span data-ttu-id="ac926-177">To pole zawiera typ wysyłanego rekordu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-177">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="ac926-178">Prawidłowe typy są następujące:</span><span class="sxs-lookup"><span data-stu-id="ac926-178">Valid types are as follows:</span></span><br /><span data-ttu-id="ac926-179">-ChangeCipherSpec<sup>10</sup>: 0x14</span><span class="sxs-lookup"><span data-stu-id="ac926-179">- ChangeCipherSpec<sup>10</sup>: 0x14</span></span><br /><span data-ttu-id="ac926-180">-Alert: 0x15</span><span class="sxs-lookup"><span data-stu-id="ac926-180">- Alert: 0x15</span></span><br /><span data-ttu-id="ac926-181">-Uzgadnianie: 0x16</span><span class="sxs-lookup"><span data-stu-id="ac926-181">- Handshake: 0x16</span></span><br /><span data-ttu-id="ac926-182">-Dane aplikacji: 0x17</span><span class="sxs-lookup"><span data-stu-id="ac926-182">- Application Data: 0x17</span></span> |
| <span data-ttu-id="ac926-183">**16-bitowa wersja protokołu**</span><span class="sxs-lookup"><span data-stu-id="ac926-183">**16-bit Protocol Version**</span></span> | <span data-ttu-id="ac926-184">To pole zawiera wersję protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-184">This field contains the TLS protocol version.</span></span> <span data-ttu-id="ac926-185">Prawidłowe wartości są następujące:</span><span class="sxs-lookup"><span data-stu-id="ac926-185">Valid values are as follows:</span></span><br /><span data-ttu-id="ac926-186">-SSL 3,0:0x0300</span><span class="sxs-lookup"><span data-stu-id="ac926-186">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="ac926-187">-TLS 1,0:0x0301</span><span class="sxs-lookup"><span data-stu-id="ac926-187">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="ac926-188">-TLS 1,1:0x0302</span><span class="sxs-lookup"><span data-stu-id="ac926-188">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="ac926-189">-TLS 1,2:0x0303</span><span class="sxs-lookup"><span data-stu-id="ac926-189">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="ac926-190">- **TLS 1,3 <sup>11</sup>**: **0x0303**</span><span class="sxs-lookup"><span data-stu-id="ac926-190">- **TLS 1.3 <sup>11</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="ac926-191">**16-bitowa Długość**</span><span class="sxs-lookup"><span data-stu-id="ac926-191">**16-bit Length**</span></span>    | <span data-ttu-id="ac926-192">To pole zawiera długość danych hermetyzowanych w rekordzie TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-192">This field contains the length of the data encapsulated in the TLS record.</span></span> |
| <span data-ttu-id="ac926-193">**Typ uzgadniania 8-bitowego**</span><span class="sxs-lookup"><span data-stu-id="ac926-193">**8-bit Handshake Type**</span></span> | <span data-ttu-id="ac926-194">To pole zawiera typ komunikatu uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-194">This field contains the handshake message type.</span></span> <span data-ttu-id="ac926-195">Prawidłowe wartości są następujące (\* **pogrubienie** komunikatów zostało dodane w protokole TLS 1,3):</span><span class="sxs-lookup"><span data-stu-id="ac926-195">Valid values are as follows (\*messages in **bold** were added in TLS 1.3):</span></span><br /><span data-ttu-id="ac926-196">-HelloRequest: 0x00</span><span class="sxs-lookup"><span data-stu-id="ac926-196">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="ac926-197">-Komunikacie ClientHello: 0x01</span><span class="sxs-lookup"><span data-stu-id="ac926-197">- ClientHello: 0x01</span></span><br /><span data-ttu-id="ac926-198">-ServerHello: 0x02</span><span class="sxs-lookup"><span data-stu-id="ac926-198">- ServerHello: 0x02</span></span><br /><span data-ttu-id="ac926-199">- **HelloVerifyRequest**: **0x03**</span><span class="sxs-lookup"><span data-stu-id="ac926-199">- **HelloVerifyRequest**: **0x03**</span></span><br /><span data-ttu-id="ac926-200">- **NewSessionTicket**: **0x04**</span><span class="sxs-lookup"><span data-stu-id="ac926-200">- **NewSessionTicket**: **0x04**</span></span><br /><span data-ttu-id="ac926-201">- **EndOfEarlyData**: **0x05**</span><span class="sxs-lookup"><span data-stu-id="ac926-201">- **EndOfEarlyData**: **0x05**</span></span><br /><span data-ttu-id="ac926-202">- **EncryptedExtensions**: **0x08**</span><span class="sxs-lookup"><span data-stu-id="ac926-202">- **EncryptedExtensions**: **0x08**</span></span><br /><span data-ttu-id="ac926-203">-Certificate: 0x0B</span><span class="sxs-lookup"><span data-stu-id="ac926-203">- Certificate: 0x0B</span></span><br /><span data-ttu-id="ac926-204">- ServerKeyExchange: 0x0C</span><span class="sxs-lookup"><span data-stu-id="ac926-204">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="ac926-205">-CertificateRequest: 0x0D</span><span class="sxs-lookup"><span data-stu-id="ac926-205">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="ac926-206">- ServerHelloDone: 0x0E</span><span class="sxs-lookup"><span data-stu-id="ac926-206">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="ac926-207">- CertificateVerify: 0x0F</span><span class="sxs-lookup"><span data-stu-id="ac926-207">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="ac926-208">-ClientKeyExchange: 0x10</span><span class="sxs-lookup"><span data-stu-id="ac926-208">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="ac926-209">-Zakończono: 0x14</span><span class="sxs-lookup"><span data-stu-id="ac926-209">- Finished: 0x14</span></span><br /><span data-ttu-id="ac926-210">- **Aktualizacja**: **0x18**</span><span class="sxs-lookup"><span data-stu-id="ac926-210">- **KeyUpdate**: **0x18**</span></span><br /><span data-ttu-id="ac926-211">- **MessageHash**: **0xFE**</span><span class="sxs-lookup"><span data-stu-id="ac926-211">- **MessageHash**: **0xFE**</span></span> |
| <span data-ttu-id="ac926-212">**Długość 24-bitowa**</span><span class="sxs-lookup"><span data-stu-id="ac926-212">**24-bit Length**</span></span>    | <span data-ttu-id="ac926-213">To pole zawiera długość danych komunikatu uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-213">This field contains the length of the handshake message data.</span></span> |

10. <span data-ttu-id="ac926-214">W protokole TLS 1,3 komunikat ChangeCipherSpec nie jest już używany, mimo że może być przesłany ze względu na zgodność, w takim przypadku komunikat jest ignorowany.</span><span class="sxs-lookup"><span data-stu-id="ac926-214">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

11. <span data-ttu-id="ac926-215">Protokół TLS 1,3 ma technicznie wartość 0x0304, jeśli ten schemat był kontynuowany, ale został zmieniony w taki sposób, aby miał rzeczywistą wersję protokołu w rozszerzeniu, więc wszystkie rekordy protokołu TLS 1,3 używają 0x0303 w polach wersji protokołu w celu zapewnienia zgodności z poprzednimi wersjami.</span><span class="sxs-lookup"><span data-stu-id="ac926-215">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="the-tls-handshake-and-tls-session"></a><span data-ttu-id="ac926-216">Uzgadnianie TLS i sesja TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-216">The TLS Handshake and TLS Session</span></span>

<span data-ttu-id="ac926-217">Typowy uzgadnianie TLS (wersje 1.0-1.2) przedstawiono na rysunku 3.</span><span class="sxs-lookup"><span data-stu-id="ac926-217">A typical TLS handshake (versions 1.0-1.2) is shown in Figure 3.</span></span> <span data-ttu-id="ac926-218">Uzgadnianie TLS rozpoczyna się, gdy klient protokołu TLS wyśle komunikat *komunikacie ClientHello* do serwera TLS, wskazujący na to, że wolisz uruchomić sesję protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-218">A TLS handshake begins when the TLS Client sends a *ClientHello* message to a TLS server, indicating its desire to start a TLS session.</span></span> <span data-ttu-id="ac926-219">Komunikat zawiera informacje o szyfrowaniu, którego klient ma używać dla sesji, wraz z informacjami użytymi do wygenerowania kluczy sesji w dalszej części uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-219">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="ac926-220">Do momentu wygenerowania kluczy sesji wszystkie komunikaty uzgadniania TLS nie są szyfrowane.</span><span class="sxs-lookup"><span data-stu-id="ac926-220">Until the session keys are generated, all messages in the TLS handshake are not encrypted.</span></span> <span data-ttu-id="ac926-221">TLS 1,3 zmienia się nieco uzgadnianie — szczegóły są przedstawione w następnej sekcji.</span><span class="sxs-lookup"><span data-stu-id="ac926-221">TLS 1.3 changes the handshake somewhat – details are presented in the next section.</span></span>

<span data-ttu-id="ac926-222">Serwer TLS reaguje na komunikacie ClientHello z komunikatem ServerHello, wskazując na wybór opcji szyfrowania dostarczonych przez klienta.</span><span class="sxs-lookup"><span data-stu-id="ac926-222">The TLS Server responds to the ClientHello with a ServerHello message, indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="ac926-223">ServerHello następuje komunikat certyfikatu, w którym serwer udostępnia certyfikat cyfrowy do uwierzytelniania tożsamości klienta.</span><span class="sxs-lookup"><span data-stu-id="ac926-223">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client.</span></span> <span data-ttu-id="ac926-224">Na koniec serwer wysyła komunikat ServerHelloDone, aby wskazać, że nie ma więcej komunikatów do wysłania.</span><span class="sxs-lookup"><span data-stu-id="ac926-224">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="ac926-225">Serwer może opcjonalnie wysyłać inne komunikaty po ServerHello, a w niektórych przypadkach może nie wysłać komunikatu certyfikatu, w związku z czym jest konieczna wiadomość ServerHelloDone.</span><span class="sxs-lookup"><span data-stu-id="ac926-225">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message, hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="ac926-226">Gdy klient otrzyma wszystkie komunikaty serwera, ma wystarczającą ilość informacji do wygenerowania kluczy sesji.</span><span class="sxs-lookup"><span data-stu-id="ac926-226">Once the client has received all the server's messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="ac926-227">TLS robi to przez utworzenie udostępnionego bitu danych losowych nazywanych *wstępnie głównym kluczem tajnym*, który jest stałym rozmiarem i jest używany jako inicjator do generowania wszystkich kluczy wymaganych po włączeniu szyfrowania.</span><span class="sxs-lookup"><span data-stu-id="ac926-227">TLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="ac926-228">Wstępnie główny klucz tajny jest szyfrowany przy użyciu algorytmu klucza publicznego (np. RSA) określonego w komunikatach Hello (zobacz poniżej, aby uzyskać informacje o algorytmach klucza publicznego) i klucz publiczny dostarczony przez serwer w jego certyfikacie.</span><span class="sxs-lookup"><span data-stu-id="ac926-228">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="ac926-229">Opcjonalna funkcja TLS o nazwie klucze wstępne (PSK) umożliwia ciphersuites, które nie korzystają z certyfikatu, ale zamiast tego używają wartości tajnej współużytkowanej przez hosty (zwykle za pomocą fizycznego transferu lub innej zabezpieczonej metody).</span><span class="sxs-lookup"><span data-stu-id="ac926-229">An optional TLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="ac926-230">Wspólny klucz tajny służy do generowania wstępnego klucza tajnego, a nie przy użyciu zaszyfrowanej wiadomości w celu wysłania wstępnie głównego klucza tajnego.</span><span class="sxs-lookup"><span data-stu-id="ac926-230">The shared secret is used to generate the Pre-Master Secret instead of using an encrypted message to send the Pre-Master Secret.</span></span> <span data-ttu-id="ac926-231">Zapoznaj się z sekcją dotyczącą wstępnie udostępnionych kluczy poniżej.</span><span class="sxs-lookup"><span data-stu-id="ac926-231">See the section on Pre-Shared Keys below.</span></span>

<span data-ttu-id="ac926-232">Zaszyfrowany wstępnie główny klucz tajny jest wysyłany do serwera w komunikacie ClientKeyExchange.</span><span class="sxs-lookup"><span data-stu-id="ac926-232">The encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="ac926-233">Serwer, po odebraniu komunikatu ClientKeyExchange, odszyfrowuje wstępnie główny klucz tajny przy użyciu jego klucza prywatnego i kontynuuje generowanie kluczy sesji równolegle z klientem TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-233">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS client.</span></span>

<span data-ttu-id="ac926-234">Po wygenerowaniu kluczy sesji wszystkie dalsze komunikaty mogą być szyfrowane przy użyciu algorytmu klucza prywatnego (np. AES) wybranego w komunikatach Hello.</span><span class="sxs-lookup"><span data-stu-id="ac926-234">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="ac926-235">Jeden końcowy komunikat niezaszyfrowany o nazwie ChangeCipherSpec jest wysyłany przez klienta i serwer, aby wskazać, że wszystkie dalsze komunikaty będą szyfrowane.</span><span class="sxs-lookup"><span data-stu-id="ac926-235">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="ac926-236">Pierwszy szyfrowany komunikat Wysłany przez klienta i serwer jest również końcowym komunikatem uzgadniania protokołu TLS o nazwie zakończony.</span><span class="sxs-lookup"><span data-stu-id="ac926-236">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="ac926-237">Ten komunikat zawiera skrót wszystkich odebranych i wysłanych komunikatów uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-237">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="ac926-238">Ten skrót służy do sprawdzania, czy żaden z komunikatów w uzgadnianiu nie został naruszony ani uszkodzony (ze wskazaniem potencjalnego naruszenia zabezpieczeń).</span><span class="sxs-lookup"><span data-stu-id="ac926-238">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="ac926-239">Po odebraniu ukończonych komunikatów i sprawdzeniu wartości skrótu uzgadniania rozpocznie się sesja TLS, a aplikacja zaczyna wysyłać i odbierać dane.</span><span class="sxs-lookup"><span data-stu-id="ac926-239">Once the Finished messages are received and the handshake hashes are verified, the TLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="ac926-240">Wszystkie dane wysyłane po obu stronach podczas sesji TLS są najpierw tworzone przy użyciu algorytmu wyznaczania wartości skrótu wybranego w komunikatach powitalnych (w celu zapewnienia integralności komunikatów) i szyfrowany przy użyciu wybranego algorytmu klucza prywatnego z wygenerowanymi kluczami sesji.</span><span class="sxs-lookup"><span data-stu-id="ac926-240">All data sent by either side during the TLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="ac926-241">Na koniec sesja TLS może zostać zakończona pomyślnie tylko wtedy, gdy klient lub serwer wybierze tę opcję.</span><span class="sxs-lookup"><span data-stu-id="ac926-241">Finally, a TLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="ac926-242">Obcięta sesja jest uznawana za naruszenie zabezpieczeń (ponieważ osoba atakująca może próbować uniemożliwić odbieranie wszystkich danych), więc zostanie wysłane specjalne powiadomienie, gdy jedna strona chce zakończyć sesję, nazywaną alertem CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="ac926-242">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="ac926-243">Zarówno klient, jak i serwer muszą wysyłać i przetwarzać alert CloseNotify o pomyślnym zamknięciu sesji.</span><span class="sxs-lookup"><span data-stu-id="ac926-243">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![Diagram typowego uzgadniania protokołu TLS.](media/image4.png)

<span data-ttu-id="ac926-245">Rysunek 3 — typowe uzgadnianie protokołu TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-245">Figure 3- Typical TLS handshake</span></span>

### <a name="tls-13-handshake"></a><span data-ttu-id="ac926-246">Uzgadnianie protokołu TLS 1,3</span><span class="sxs-lookup"><span data-stu-id="ac926-246">TLS 1.3 Handshake</span></span>

<span data-ttu-id="ac926-247">TLS 1,3 to dość ważna remonty protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-247">TLS 1.3 is a fairly major overhaul of the TLS protocol.</span></span> <span data-ttu-id="ac926-248">Zdecydowana większość zmian została wprowadzona w celu zwiększenia bezpieczeństwa i wydajności.</span><span class="sxs-lookup"><span data-stu-id="ac926-248">The vast majority of the changes were made to the handshake to increase security and performance.</span></span> <span data-ttu-id="ac926-249">Typowy uzgadnianie TLS 1,3 przedstawiono na rysunku 4.</span><span class="sxs-lookup"><span data-stu-id="ac926-249">A typical TLS 1.3 handshake is shown in Figure 4.</span></span> <span data-ttu-id="ac926-250">Podstawową różnicę można zobaczyć w liczbie wymian między serwerem a klientem.</span><span class="sxs-lookup"><span data-stu-id="ac926-250">The primary difference can be seen in the number of exchanges between the server and client.</span></span>

<span data-ttu-id="ac926-251">W protokole TLS 1,2 i starszych, serwer wyśle dwa loty<sup>12</sup> komunikatów — najpierw ServerHello, a następnie komunikat ChangeCipherSpec przed wysłaniem zaszyfrowanego komunikatu zakończonego, który kończy uzgadnianie.</span><span class="sxs-lookup"><span data-stu-id="ac926-251">In TLS 1.2 and earlier, the server would send two flights<sup>12</sup> of messages – first the ServerHello and then a ChangeCipherSpec message before sending the encrypted Finished message that ends the handshake.</span></span> <span data-ttu-id="ac926-252">W protokole TLS 1,3 serwer wysyła wszystkie w pierwszym locie — ServerHello, rozszerzenia, certyfikat i gotowe.</span><span class="sxs-lookup"><span data-stu-id="ac926-252">In TLS 1.3, the server sends everything in the first flight – ServerHello, extensions, certificate, and Finished.</span></span> <span data-ttu-id="ac926-253">Komunikat ChangeCipherSpec został wyeliminowany, a serwer generuje swoje klucze sesji i uruchamia szyfrowane komunikaty uzgadniania bezpośrednio po ServerHello.</span><span class="sxs-lookup"><span data-stu-id="ac926-253">The ChangeCipherSpec message was eliminated and the server generates its session keys and starts encrypting handshake messages immediately following the ServerHello.</span></span>

<span data-ttu-id="ac926-254">Nowe rozwiązanie oznacza, że większa część uzgadniania TLS jest chroniona przez szyfrowanie, ograniczając ilość danych w postaci zwykłego tekstu, do których atakujący może uzyskać dostęp.</span><span class="sxs-lookup"><span data-stu-id="ac926-254">The new arrangement means that more of the TLS handshake is protected by encryption, limiting the amount of plaintext data an attacker can access.</span></span> <span data-ttu-id="ac926-255">Ponadto usunięcie drugiego lotu serwera (który był tylko ChangeCipherSpec po zakończeniu) oznacza, że klient protokołu TLS nie musi już czekać na rozpoczęcie przesyłania danych aplikacji — gdy tylko klient wyśle własny gotowy komunikat, sesja zostanie uruchomiona.</span><span class="sxs-lookup"><span data-stu-id="ac926-255">Additionally, the removal of the second server flight (which was just a ChangeCipherSpec followed by a Finished) means that a TLS client no longer needs to wait to start transmitting application data – as soon as the client sends its own Finished message the session is started.</span></span>

12. <span data-ttu-id="ac926-256">Samolotem jest po prostu kolekcja komunikatów TLS wysyłanych jednocześnie w grupie.</span><span class="sxs-lookup"><span data-stu-id="ac926-256">A flight is simply a collection of TLS messages sent simultaneously in a group.</span></span>

![Diagram uzgadniania TLS 1,3.](media/image5.png)

<span data-ttu-id="ac926-258">Rysunek 4 — uzgadnianie protokołu TLS 1,3</span><span class="sxs-lookup"><span data-stu-id="ac926-258">Figure 4 - TLS 1.3 Handshake</span></span>

> [!NOTE]
> <span data-ttu-id="ac926-259">*Protokół TLS 1,3 wprowadza również pojęcie "wczesne dane" i 0-RTT (czas błądzenia zero), co oznacza, że niektóre dane aplikacji mogą być wysyłane podczas pierwszego lotu komunikatów. Ta opcjonalna funkcja została dodana głównie jako Optymalizacja czasu odpowiedzi w przeglądarce sieci Web (np. w celu wysłania wczesnych nagłówków HTTP w celu rozpoczęcia renderowania strony). Począwszy od platformy Azure RTO 6,0, ta funkcja nie jest obsługiwana.*</span><span class="sxs-lookup"><span data-stu-id="ac926-259">*TLS 1.3 also introduced the notion of "Early data" and 0-RTT (Zero Round Trip Time), meaning that some application data can be sent in the first flight of messages. This optional feature was added primarily as an optimization for web browser responsiveness (e.g. to send early HTTP headers to start rendering a page). As of Azure RTOS 6.0 this feature is NOT supported.*</span></span>

### <a name="initialization"></a><span data-ttu-id="ac926-260">Inicjalizacja</span><span class="sxs-lookup"><span data-stu-id="ac926-260">Initialization</span></span>

<span data-ttu-id="ac926-261">Stos TCP/IP NetX lub NetXDuo musi być zainicjowany przed użyciem NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-261">The NetX or NetXDuo TCP/IP stack must be initialized prior to using NetX Secure TLS.</span></span> <span data-ttu-id="ac926-262">Zapoznaj się z podręcznikiem użytkownika NetX lub NetXDuo, aby uzyskać informacje na temat poprawnego inicjowania stosu TCP/IP.</span><span class="sxs-lookup"><span data-stu-id="ac926-262">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack.</span></span>

<span data-ttu-id="ac926-263">Po zainicjowaniu stosu TCP/IP NetX można włączyć protokół TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-263">Once the NetX TCP/IP stack has been initialized, TLS can be enabled.</span></span> <span data-ttu-id="ac926-264">Wewnętrznie cały ruch sieciowy i przetwarzanie protokołu TLS jest obsługiwany przez stos NetX/NetXDuo, bez konieczności interwencji użytkownika.</span><span class="sxs-lookup"><span data-stu-id="ac926-264">Internally, all TLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="ac926-265">Jednak protokół TLS ma określone wymagania, które muszą być obsługiwane niezależnie od bazowego stosu sieciowego.</span><span class="sxs-lookup"><span data-stu-id="ac926-265">However, TLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="ac926-266">Te parametry są przypisywane do bloku kontroli protokołu TLS o nazwie \***NX_SECURE_TLS_SESSION** _ przy użyciu usługi _ \*_nx_secure_tls_session_create_\*\*.</span><span class="sxs-lookup"><span data-stu-id="ac926-266">These parameters are assigned to the TLS control block called ***NX_SECURE_TLS_SESSION** _ using the _ *_nx_secure_tls_session_create_** service.</span></span>

<span data-ttu-id="ac926-267">Protokół TLS ma dwa tryby: serwer i klienta, z których każdy może być włączony w aplikacji (ale tylko jeden tryb na gniazdo NetX), a każdy z nich ma własne określone wymagania, szczegółowo poniżej.</span><span class="sxs-lookup"><span data-stu-id="ac926-267">TLS has two modes, Server and Client, either of which may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

<span data-ttu-id="ac926-268">W obu trybach NetX Secure TLS wymaga utworzenia gniazda TCP (\***NX_TCP_SOCKET** _) i skonfigurowania go na potrzeby komunikacji TCP z hostem zdalnym.</span><span class="sxs-lookup"><span data-stu-id="ac926-268">In either mode, NetX Secure TLS requires a TCP socket (\***NX_TCP_SOCKET** _) to be created and set up for TCP communications with the remote host.</span></span> <span data-ttu-id="ac926-269">Gniazdo TCP jest przypisane do wystąpienia sesji TLS z usługą _ \*_nx_secure_tls_session_start_\*\*, szczegółowo poniżej.</span><span class="sxs-lookup"><span data-stu-id="ac926-269">The TCP socket is assigned to a TLS session instance with the _ *_nx_secure_tls_session_start_*\* service, detailed below.</span></span>

### <a name="initialization--tls-server"></a><span data-ttu-id="ac926-270">Inicjowanie — Serwer TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-270">Initialization – TLS Server</span></span>

<span data-ttu-id="ac926-271">Oprócz gniazda TCP NetX tryb bezpiecznego serwera TLS wymaga *certyfikatu cyfrowego*, który jest dokumentem używanym do identyfikowania serwera TLS na potrzeby połączenia z klientem TLS, i certyfikatami odpowiadającymi *kluczem prywatnym*, zazwyczaj dla algorytmu szyfrowania RSA.</span><span class="sxs-lookup"><span data-stu-id="ac926-271">In addition to a TCP socket, NetX Secure TLS Server mode requires a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="ac926-272">Międzynarodowy związek telekomunikacyjny X. 509 standard określa format certyfikatu używany przez protokół TLS i istnieje wiele narzędzi do tworzenia certyfikatów cyfrowych X. 509.</span><span class="sxs-lookup"><span data-stu-id="ac926-272">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="ac926-273">W przypadku protokołu Secure TLS NetX certyfikat X. 509 musi być zakodowany binarnie przy użyciu formatu Distinguished Encoding Rules (DER) z numerem ASN. 1.</span><span class="sxs-lookup"><span data-stu-id="ac926-273">For NetX Secure TLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="ac926-274">Algorytm DER to standardowy format binarny protokołu TLS dla certyfikatów.</span><span class="sxs-lookup"><span data-stu-id="ac926-274">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="ac926-275">Klucz prywatny skojarzony z podanym certyfikatem musi mieć format PKCS # 1 DER-Encoded.</span><span class="sxs-lookup"><span data-stu-id="ac926-275">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="ac926-276">Klucz prywatny jest używany tylko na urządzeniu i nigdy nie będzie przesyłany przez sieć.</span><span class="sxs-lookup"><span data-stu-id="ac926-276">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="ac926-277">Utrzymuj bezpieczeństwo kluczy prywatnych, ponieważ zapewniają one zabezpieczenia komunikacji TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-277">Keep private keys safe as they provide the security for TLS communications!</span></span>

<span data-ttu-id="ac926-278">Aby można było zainicjować certyfikat serwera TLS, aplikacja musi udostępnić wskaźnik do buforu zawierającego certyfikat X. 509 szyfrowany algorytmem DER oraz opcjonalne dane klucza prywatnego PKCS # 1 RSA, używając usługi ***nx_secure_x509_certificate_intialize** _, która wypełnia strukturę _ *NX_SECURE_X509_CERT** z odpowiednimi danymi certyfikatu do użycia przez protokół TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-278">To initialize the TLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="ac926-279">Po zainicjowaniu certyfikatu serwera należy go dodać do bloku kontroli protokołu TLS przy użyciu usługi ***nx_secure_tls_local_certificate_add*** .</span><span class="sxs-lookup"><span data-stu-id="ac926-279">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_tls_local_certificate_add*** service.</span></span>

<span data-ttu-id="ac926-280">Po dodaniu certyfikatu serwera do bloku kontroli protokołu TLS gniazdo może być używane do nawiązywania bezpiecznego połączenia z serwerem protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-280">Once the server's certificate has been added to the TLS control block, the socket may be used to establish a secure TLS Server connection.</span></span>

### <a name="initialization--tls-client"></a><span data-ttu-id="ac926-281">Inicjowanie — klient TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-281">Initialization – TLS Client</span></span>

<span data-ttu-id="ac926-282">Bezpieczny tryb klienta protokołu TLS NetX wymaga *magazynu zaufanych certyfikatów*, który jest kolekcją certyfikatów cyfrowych X. 509 szyfrowanych z zaufanych urzędów certyfikacji (CA).</span><span class="sxs-lookup"><span data-stu-id="ac926-282">NetX Secure TLS Client mode requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA's).</span></span> <span data-ttu-id="ac926-283">Te certyfikaty są zakładane przez protokół TLS jako "zaufany" i stanowią podstawę do uwierzytelniania certyfikatów dostarczonych przez jednostki serwera TLS do NetX bezpiecznego klienta protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-283">These certificates are assumed by the TLS protocol to be "trusted" and serve as the basis for authenticating certificates provided by TLS server entities to NetX Secure TLS Client.</span></span>

<span data-ttu-id="ac926-284">Certyfikat zaufanego urzędu certyfikacji może być *podpisany z podpisem własnym* lub podpisany przez inny urząd certyfikacji, w którym to przypadku certyfikat jest nazywany *POśrednim urzędem certyfikacji* (ICA).</span><span class="sxs-lookup"><span data-stu-id="ac926-284">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="ac926-285">W typowej aplikacji TLS serwer udostępnia certyfikaty usługi ICA wraz z certyfikatem serwera, ale Jedynym wymaganiem do pomyślnego uwierzytelnienia jest to, że łańcuch wystawców (certyfikaty służące do podpisywania innych certyfikatów) może być śledzony z certyfikatu serwera z powrotem do certyfikatu zaufanego urzędu certyfikacji w zaufanym magazynie certyfikatów.</span><span class="sxs-lookup"><span data-stu-id="ac926-285">In a typical TLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="ac926-286">Ten łańcuch jest znany jako  *łańcuch zaufania* lub *łańcuch certyfikatów*.</span><span class="sxs-lookup"><span data-stu-id="ac926-286">This chain is known as a  *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="ac926-287">Aby zainicjować zaufany urząd certyfikacji lub certyfikat usługi ICA, aplikacja musi udostępnić wskaźnik do buforu zawierającego certyfikat X. 509 szyfrowany algorytmem DER przy użyciu usługi ***nx_secure_x509_certificate_intialize** _, która wypełnia strukturę _ *NX_SECURE_X509_CERT** z odpowiednimi danymi certyfikatu do użycia przez protokół TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-287">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="ac926-288">Zaufane certyfikaty, które zostały zainicjowane, są następnie dodawane do bloku kontroli protokołu TLS przy użyciu usługi ***nx_secure_tls_trusted_certificate_add*** .</span><span class="sxs-lookup"><span data-stu-id="ac926-288">Trusted certificates that have been initialized are then added to the TLS control block using the ***nx_secure_tls_trusted_certificate_add*** service.</span></span> <span data-ttu-id="ac926-289">Niepowodzenie dodania certyfikatu spowoduje niepowodzenie sesji klienta TLS, ponieważ nie będzie można uwierzytelnić protokołów protokołu TLS na potrzeby uwierzytelniania zdalnych hostów serwera TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-289">Failure to add a certificate will cause the TLS Client session to fail as there will be no way for the TLS protocol to authenticate remote TLS server hosts.</span></span>

<span data-ttu-id="ac926-290">Klient TLS potrzebuje również miejsca na przydzielenie certyfikatu serwera przychodzącego (przy założeniu, że nie jest używany tryb klucza wstępnego).</span><span class="sxs-lookup"><span data-stu-id="ac926-290">The TLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used).</span></span> <span data-ttu-id="ac926-291">Od NetX Secure TLS 5,12 nie jest już konieczne, aby aplikacja mogła przydzielić miejsce dla certyfikatu zdalnego.</span><span class="sxs-lookup"><span data-stu-id="ac926-291">As of NetX Secure TLS 5.12, it is no longer necessary for the application to allocate space for remote certificate.</span></span> <span data-ttu-id="ac926-292">Jednak Starsza opcja przydzielenia miejsca dla certyfikatu serwera jest nadal dostępna, a certyfikaty przypisane przez użytkownika będą używane przed wewnętrzną optymalizacją bufora certyfikatów <sup>13</sup> — zobacz usługę ***nx_secure_tls_remote_certificate_allocate*** , aby uzyskać więcej informacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-292">However, the legacy option to allocate space for a server certificate is still available and user-allocated certificates will be used before the internal certificate buffer optimization <sup>13</sup> – see the ***nx_secure_tls_remote_certificate_allocate*** service for more information.</span></span>

<span data-ttu-id="ac926-293">Po utworzeniu magazynu zaufanych certyfikatów i przydzieleniu miejsca na certyfikat serwera, gniazdo może być używane do nawiązywania bezpiecznego połączenia z klientem TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-293">Once the Trusted Certificate Store has been created and space for the server certificate has been allocated, the socket may be used to establish a secure TLS Client connection.</span></span>

13. <span data-ttu-id="ac926-294">Optymalizacja wykorzystuje "bufor pakietów" dostarczony przez aplikację użytkownika w sesji protokołu TLS przy użyciu *nx_secure_tls_session_packet_buffer_set* do przydzielenia struktur analizy X. 509 zamiast używania struktur dostarczonych przez użytkownika, które są używane we wcześniejszych wersjach NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-294">The optimization utilizes the “packet buffer” supplied by the user application to the tls session using *nx_secure_tls_session_packet_buffer_set* to allocate the X.509 parsing structures instead of using the user-supplied structures used in earlier versions of NetX Secure TLS.</span></span> <span data-ttu-id="ac926-295">Jest mało prawdopodobne, że napotkanie łańcucha certyfikatów przekracza rozmiar buforu pakietów, co oznacza, że można zwiększyć rozmiar buforu pakietów lub *nx_secure_tls _remote_certificate_allocate* może zostać użyty do przydzielenia większej ilości miejsca dla łańcucha certyfikatów.</span><span class="sxs-lookup"><span data-stu-id="ac926-295">There is an unlikely possibility of encountering a certificate chain exceeding the size of the packet buffer in which case either the packet buffer size may be increased or *nx_secure_tls _remote_certificate_allocate* may be used to allocate more space for the certificate chain.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="ac926-296">Wywołania interfejsu aplikacji</span><span class="sxs-lookup"><span data-stu-id="ac926-296">Application Interface Calls</span></span>

<span data-ttu-id="ac926-297">NetX Secure TLS aplikacje zwykle powodują wywołania funkcji z wątków aplikacji uruchomionych w ramach ThreadX RTO.</span><span class="sxs-lookup"><span data-stu-id="ac926-297">NetX Secure TLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="ac926-298">Niektóre inicjalizacje, szczególnie w przypadku źródłowych protokołów komunikacji sieciowej (np. TCP i IP), mogą być wywoływane z programu \*\**tx_application_define *.**</span><span class="sxs-lookup"><span data-stu-id="ac926-298">Some initialization, particularly for the underlying network communications protocols (e.g. TCP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="ac926-299">Więcej informacji na temat inicjowania komunikacji sieciowej można znaleźć w podręczniku użytkownika NetX/NetXDuo.</span><span class="sxs-lookup"><span data-stu-id="ac926-299">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="ac926-300">Protokół TLS znacznie wykorzystuje procedury szyfrowania, które są operacjami intensywnie wykorzystującymi procesor.</span><span class="sxs-lookup"><span data-stu-id="ac926-300">TLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="ac926-301">Zwykle te operacje będą wykonywane w kontekście wywołania wątku.</span><span class="sxs-lookup"><span data-stu-id="ac926-301">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="tls-session-start"></a><span data-ttu-id="ac926-302">Rozpoczęcie sesji TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-302">TLS Session Start</span></span>

<span data-ttu-id="ac926-303">Aby można było działać, protokół TLS wymaga podstawowego protokołu sieciowego warstwy transportowej.</span><span class="sxs-lookup"><span data-stu-id="ac926-303">TLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="ac926-304">Zazwyczaj używany jest protokół TCP.</span><span class="sxs-lookup"><span data-stu-id="ac926-304">The protocol typically used is TCP.</span></span> <span data-ttu-id="ac926-305">Aby można było ustanowić NetX bezpieczną sesję TLS, należy ustanowić połączenie TCP za pomocą interfejsu API NetX/NetXDuo TCP.</span><span class="sxs-lookup"><span data-stu-id="ac926-305">In order to establish a NetX Secure TLS session, a TCP connection must be established using the NetX/NetXDuo TCP API.</span></span> <span data-ttu-id="ac926-306">Należy utworzyć **NX_TCP_SOCKET** i nawiązać połączenie za pomocą **_nx_tcp_server_socket_listen_*_ i _*_nx_tcp_server_socket_accept_*_ usług (dla serwera TLS) lub _\* usługi _nx_tcp_client_socket_connect_*\* (dla klienta TLS).</span><span class="sxs-lookup"><span data-stu-id="ac926-306">An **NX_TCP_SOCKET** must be created and a connection established using the **_nx_tcp_server_socket_listen_*_ and _*_nx_tcp_server_socket_accept_*_ services (for TLS Server) or the _*_nx_tcp_client_socket_connect_** service (for TLS Client).</span></span>

<span data-ttu-id="ac926-307">Po nawiązaniu połączenia TCP gniazdo TCP jest następnie przesyłane do usługi ***nx_secure_tls_session_start*** .</span><span class="sxs-lookup"><span data-stu-id="ac926-307">Once a TCP connection has been established, the TCP socket is then passed to the ***nx_secure_tls_session_start*** service.</span></span>

### <a name="tls-packet-allocation"></a><span data-ttu-id="ac926-308">Alokacja pakietów TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-308">TLS Packet Allocation</span></span>

<span data-ttu-id="ac926-309">NetX Secure TLS używa tej samej struktury pakietów co NetX/NetXDuo TCP (***NX_PACKET** _), z wyjątkiem tego, że zamiast wywoływania usługi _*_nx_packet_allocate_\*_ , należy wywołać usługę _ \*_nx_secure_tls_packet_allocate_\*\*, aby miejsce na nagłówek TLS mogło być prawidłowo przydzieloną.</span><span class="sxs-lookup"><span data-stu-id="ac926-309">NetX Secure TLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_tls_packet_allocate_** service must be called so that space for the TLS header may be allocated properly.</span></span>

### <a name="tls-session-send"></a><span data-ttu-id="ac926-310">Wysyłanie sesji protokołu TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-310">TLS Session Send</span></span>

<span data-ttu-id="ac926-311">Po rozpoczęciu sesji TLS aplikacja może wysyłać dane przy użyciu usługi \***nx_secure_tls_session_send** _.</span><span class="sxs-lookup"><span data-stu-id="ac926-311">Once the TLS session has started, the application may send data using the \***nx_secure_tls_session_send** _ service.</span></span> <span data-ttu-id="ac926-312">Usługa Send jest taka sama jak w przypadku usługi _*_nx_tcp_socket_send_*_ , pobierając _*_NX_PACKETą_*_ strukturę danych zawierającą wysyłane dane, tylko te dane zostaną zaszyfrowane przez stos bezpiecznego protokołu TLS przed wysłaniem, a pakiet musi zostać alokowany przy użyciu _ *_nx_secure_tls_packet_allocate_* \*.</span><span class="sxs-lookup"><span data-stu-id="ac926-312">The send service is identical in use to the _*_nx_tcp_socket_send_*_ service, taking an _*_NX_PACKET_*_ data structure containing the data being sent, only that data will be encrypted by the NX Secure TLS stack before being sent, and the packet must be allocated using _\*_nx_secure_tls_packet_allocate_\*\*.</span></span>

### <a name="tls-session-receive"></a><span data-ttu-id="ac926-313">Odbieranie sesji TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-313">TLS Session Receive</span></span>

<span data-ttu-id="ac926-314">Po rozpoczęciu sesji TLS aplikacja może zacząć odbierać dane przy użyciu usługi \***nx_secure_tls_session_receive** _.</span><span class="sxs-lookup"><span data-stu-id="ac926-314">Once the TLS session has started, the application may begin receiving data using the \***nx_secure_tls_session_receive** _ service.</span></span> <span data-ttu-id="ac926-315">Podobnie jak w przypadku wysyłania sesji TLS, ta usługa jest identyczna z użyciem do _ *_nx_tcp_socket_receive_* \*, z tą różnicą, że dane przychodzące są odszyfrowywane i weryfikowane przez stos TLS przed zwróceniem w strukturze pakietów.</span><span class="sxs-lookup"><span data-stu-id="ac926-315">Like the TLS Session send, this service is identical in use to _\*_nx_tcp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the TLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="ac926-316">Zamykanie sesji TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-316">TLS Session Close</span></span>

<span data-ttu-id="ac926-317">Po zakończeniu sesji TLS zarówno klient protokołu TLS, jak i serwer muszą wysłać Alert CloseNotify po drugiej stronie w celu zamknięcia sesji.</span><span class="sxs-lookup"><span data-stu-id="ac926-317">Once a TLS session is complete, both the TLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="ac926-318">Obie strony muszą odebrać i przetworzyć alert, aby upewnić się, że pomyślnie zamknięto sesję.</span><span class="sxs-lookup"><span data-stu-id="ac926-318">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="ac926-319">Jeśli host zdalny wyśle alert CloseNotify, wszystkie wywołania usługi \***nx_secure_tls_session_receive** _ przetworzy alert, wyśle odpowiedni alert z powrotem do hosta zdalnego i zwróci wartość _ *_NX_SECURE_TLS_SESSION_CLOSED_* \*.</span><span class="sxs-lookup"><span data-stu-id="ac926-319">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_tls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="ac926-320">Po zamknięciu sesji wszelkie dalsze próby wysłania lub odebrania danych z tą sesją TLS zakończą się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="ac926-320">Once the session is closed, any further attempts to send or receive data with that TLS session will fail.</span></span>

<span data-ttu-id="ac926-321">Jeśli aplikacja chce zamknąć sesję TLS, należy wywołać usługę \***nx_secure_tls_session_end** _.</span><span class="sxs-lookup"><span data-stu-id="ac926-321">If the application wishes to close the TLS session, the \***nx_secure_tls_session_end** _ service must be called.</span></span> <span data-ttu-id="ac926-322">Usługa wyśle alert CloseNotify i przetworzy CloseNotify odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="ac926-322">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="ac926-323">Jeśli odpowiedź nie zostanie odebrana, zostanie zwrócona wartość błędu _ \*_NX_SECURE_TLS_SESSION_CLOSE_FAIL_\*\*, co oznacza, że sesja TLS nie została czysto ZAMKNIĘTA, możliwe naruszenie zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="ac926-323">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the TLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tls-alerts"></a><span data-ttu-id="ac926-324">Alerty protokołu TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-324">TLS Alerts</span></span>

<span data-ttu-id="ac926-325">Protokół TLS został zaprojektowany w celu zapewnienia maksymalnego poziomu zabezpieczeń, dlatego każde zachowanie errant w protokole jest uznawane za potencjalne naruszenie zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="ac926-325">TLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="ac926-326">Z tego powodu wszelkie błędy związane z przetwarzaniem komunikatów lub szyfrowaniem/odszyfrowywaniem są uznawane za błędy krytyczne, które natychmiast przerywają uzgadnianie lub sesję.</span><span class="sxs-lookup"><span data-stu-id="ac926-326">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="ac926-327">Podczas obsługi błędów w aplikacji lokalnej jest stosunkowo prosta, a host zdalny musi wiedzieć, że wystąpił błąd w celu prawidłowego obsłużenia tej sytuacji i zapobiegania wszelkim możliwym naruszeniom zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="ac926-327">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="ac926-328">Z tego powodu protokół TLS wyśle komunikat o *alercie* do hosta zdalnego w przypadku jakiegokolwiek błędu.</span><span class="sxs-lookup"><span data-stu-id="ac926-328">For this reason, TLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="ac926-329">Alerty są traktowane w taki sam sposób jak inne komunikaty TLS i szyfrowane podczas sesji, aby zapobiec zbieraniu informacji przez osobę atakującą z typu dostarczonego alertu.</span><span class="sxs-lookup"><span data-stu-id="ac926-329">Alerts are treated in the same manner as any other TLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="ac926-330">W trakcie uzgadniania wysyłane alerty są ograniczone do zakresu, aby ograniczyć ilość informacji, które mogą zostać uzyskane przez potencjalną osobę atakującą.</span><span class="sxs-lookup"><span data-stu-id="ac926-330">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="ac926-331">Alert CloseNotify używany do zamykania sesji TLS jest jedynym alertem niekrytycznym.</span><span class="sxs-lookup"><span data-stu-id="ac926-331">The CloseNotify alert, used to close the TLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="ac926-332">Mimo że jest on traktowany jako alert i wysyłany jako komunikat alertu, CloseNotify jest w przeciwieństwie do innych alertów, w tym nie wskazuje, że wystąpił błąd.</span><span class="sxs-lookup"><span data-stu-id="ac926-332">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

<span data-ttu-id="ac926-333">Wartość alertu i "poziom" (poziomy to "ostrzeżenie" i "krytyczny" — większość alertów protokołu TLS jest "krytyczna") zdefiniowanych w specyfikacjach RFC protokołu TLS i wskazuje typ błędu, który wystąpił.</span><span class="sxs-lookup"><span data-stu-id="ac926-333">The alert value and "level" (levels are "warning" and "fatal" – most TLS alerts are "fatal") are defined in the TLS RFCs and indicate the type of error that occurred.</span></span> <span data-ttu-id="ac926-334">Większość alertów protokołu TLS innych niż CloseNotify może być traktowana jako wskazanie potencjalnego problemu z zabezpieczeniami i spowoduje przerwanie sesji TLS lub uzgadnianie.</span><span class="sxs-lookup"><span data-stu-id="ac926-334">Most TLS Alerts other than CloseNotify can be considered an indication of a potential security issue and will result in the TLS session or handshake being aborted.</span></span> <span data-ttu-id="ac926-335">Jeśli dowolne wywołanie API protokołu TLS zwróci wartość **NX_SECURE_TLS_ALERT_RECEIVED** (0x114), usługa interfejsu API **_nx_secure_tls_session_alert_value_get_** (Nowość w NetX SECURE TLS w wersji 5,12) może zostać użyta do pobrania wartości alertu TLS i poziomu dla aplikacji do użycia w przypadku wszelkich decyzji dotyczących odpowiedzi na problemy z zabezpieczeniami.</span><span class="sxs-lookup"><span data-stu-id="ac926-335">If any TLS API call returns **NX_SECURE_TLS_ALERT_RECEIVED** (0x114), the API service **_nx_secure_tls_session_alert_value_get_** (new in NetX Secure TLS version 5.12) may be used to retrieve the TLS alert value and level for the application to use for any decisions regarding responses to security issues.</span></span> <span data-ttu-id="ac926-336">W większości przypadków każdy alert otrzymany z hosta zdalnego innego niż CloseNotify powinien być traktowany jako błąd krytyczny, chociaż istnieje kilka excptions — Aby uzyskać więcej informacji, zobacz specyfikacje RFC protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-336">In most cases, any alert received from the remote host other than CloseNotify should be considered a fatal error, though there are some excptions – see the TLS RFCs for more information.</span></span>

### <a name="tls-session-renegotiation"></a><span data-ttu-id="ac926-337">Ponowne negocjowanie sesji TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-337">TLS Session Renegotiation</span></span>

<span data-ttu-id="ac926-338">Protokół TLS obsługuje pojęcie "renegocjacji", która jest po prostu ponowną negocjacją parametrów sesji TLS w kontekście istniejącej sesji TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-338">TLS supports the notion of "renegotiation" which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span> <span data-ttu-id="ac926-339">To oznacza, że nowe komunikaty uzgadniania są szyfrowane i uwierzytelniane przy użyciu istniejącej sesji.</span><span class="sxs-lookup"><span data-stu-id="ac926-339">What this means in practice is that the new handshake messages are encrypted and authenticated using the existing session.</span></span> <span data-ttu-id="ac926-340">Ponowna negocjacja jest używana, gdy host TLS chce generować nowe parametry sesji (np. generować nowe klucze sesji TLS) bez konieczności kończenia istniejącej sesji.</span><span class="sxs-lookup"><span data-stu-id="ac926-340">Renegotiation is used when a TLS host wants to generate new session parameters (e.g. generate new TLS session keys) without having to complete the existing session.</span></span> <span data-ttu-id="ac926-341">Na przykład ponowne negocjowanie może być pożądane, gdy zasady zabezpieczeń aplikacji określają, że klucze sesji są używane tylko przez ograniczony czas, ale sesja TLS pozostaje aktywna poza tym czasem.</span><span class="sxs-lookup"><span data-stu-id="ac926-341">For example, renegotiation may be desirable when security policies for an application dictate that session keys are only used for a limited time but a TLS session remains active beyond that time.</span></span>

<span data-ttu-id="ac926-342">Jednym problemem związanym z ponowną negocjacją sesji jest to, że protokół TLS jest narażony na określony atak typu man-in-the-Middle, w którym osoba atakująca może przekonać serwer do zainicjowania renegocjacji z nowymi parametrami, dzięki czemu osoba atakująca będzie mogła przejąć daną sesję TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-342">One issue with session renegotiation is that is makes TLS vulnerable to a specific Man-in-the-Middle attack where an attacker can convince a server to initiate a renegotiation with new parameters, thus allowing the attacker to hijack the TLS session.</span></span> <span data-ttu-id="ac926-343">Aby uniknąć tego problemu, wprowadzono rozszerzenie "oznaczenie bezpiecznego ponownego negocjowania" (Zobacz błąd sekcji). **Nie znaleziono źródła odwołania.**</span><span class="sxs-lookup"><span data-stu-id="ac926-343">To mitigate this issue, the Secure Renegotiation Indication extension was introduced (see section **Error! Reference source not found.**</span></span> <span data-ttu-id="ac926-344">sekcja).</span><span class="sxs-lookup"><span data-stu-id="ac926-344">section).</span></span>

<span data-ttu-id="ac926-345">Protokół Secure TLS NetX całkowicie obsługuje ponowną negocjację sesji oraz rozszerzenie zabezpieczeń dotyczące bezpiecznego ponownego negocjowania.</span><span class="sxs-lookup"><span data-stu-id="ac926-345">NetX Secure TLS completely supports session renegotiation and the Secure Renegotiation Indication extension.</span></span>

<span data-ttu-id="ac926-346">Podczas otrzymywania danych z hosta zdalnego renegotations (i rozszerzenie) są obsługiwane automatycznie bez interakcji z aplikacją.</span><span class="sxs-lookup"><span data-stu-id="ac926-346">When receiving data from a remote host, renegotations (and the extension) are handled automatically without application interaction.</span></span> <span data-ttu-id="ac926-347">Jeśli pożądane jest powiadomienie dotyczące ponownych negocjacji sesji, do usługi *nx_secure_tls_session_renegotiate_callback_set* może zostać dostarczone wywołanie zwrotne renegocjacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-347">If notification about session renegotiations is desired, a renegotiation callback may be supplied with the *nx_secure_tls_session_renegotiate_callback_set* service.</span></span> <span data-ttu-id="ac926-348">Wywołanie zwrotne zostanie wywołane po każdym ponownym negocjowaniu żądania przez hosta zdalnego, co umożliwi aplikacji wykonanie akcji w razie potrzeby.</span><span class="sxs-lookup"><span data-stu-id="ac926-348">The callback will be invoked whenever a renegotiation is requested by the remote host, allowing the application to take action if desired.</span></span>

<span data-ttu-id="ac926-349">Aby zainicjować ponowną negocjację z aktywnej sesji protokołu TLS, po prostu Wywołaj usługę *nx_secure_tls_session_renegotiate* na ŻĄDANEJ sesji TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-349">To initiate a renegotiation from an active TLS session, simply invoke the *nx_secure_tls_session_renegotiate* service on the desired TLS session.</span></span>

### <a name="tls-session-resumption"></a><span data-ttu-id="ac926-350">Wznawianie sesji protokołu TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-350">TLS Session Resumption</span></span>

<span data-ttu-id="ac926-351">Wznowienie sesji protokołu TLS nie powinno być pomylone z ponowną negocjacją sesji pomimo pewnych podobieństw.</span><span class="sxs-lookup"><span data-stu-id="ac926-351">TLS session resumption should not be confused with session renegotiation, despite some similarities.</span></span> <span data-ttu-id="ac926-352">Gdy ponowne *negocjowanie* sesji obejmuje rozpoczęcie nowego uzgadniania w istniejącej sesji protokołu TLS, *wznowienie* sesji jest funkcją opcjonalną, która polega na ponownym uruchomieniu zamkniętej sesji TLS bez wykonywania pełnej uzgadniania protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-352">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span> <span data-ttu-id="ac926-353">Aby to osiągnąć, implementacja protokołu TLS może buforować parametry sesji i klucze, kojarząc je z *identyfikatorem sesji,* unikatowym identyfikatorem dostarczonym w pierwotnym uzgadnianiu.</span><span class="sxs-lookup"><span data-stu-id="ac926-353">To achieve this, a TLS implementation may cache the session parameters and keys, associating them with a *session ID,* a unique identifier supplied in the original handshake.</span></span> <span data-ttu-id="ac926-354">Dostarczając identyfikator sesji do serwera TLS, klient wskazuje, że poprzednia sesja protokołu TLS między hostami istniała i zakończyła się trochę czasu w przeszłości, i że klient nadal ma stan, aby ponownie ustanowić sesję z ograniczoną uzgadnianiem.</span><span class="sxs-lookup"><span data-stu-id="ac926-354">By supplying a session ID to a TLS server, a client indicates that a previous TLS session between the hosts existed and completed some time in the past, and that the client still possesses the state to re-establish the session with a reduced handshake.</span></span> <span data-ttu-id="ac926-355">Ponieważ klucze sesji są teoretycznie nadal tajne i są znane tylko przez dwóch komunikujących hosta, serwer może uruchomić nową sesję protokołu TLS i pominąć większość normalnej uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-355">Since the session keys are theoretically still secret and only known by the two communicating host, the server can start a new TLS session and bypass most of the normal handshake.</span></span>

<span data-ttu-id="ac926-356">Wznawianie sesji może być przydatne, aby uniknąć potencjalnych operacji klucza publicznego używanych do udostępniania głównego klucza tajnego generacji kluczy i weryfikowania sygnatur certyfikatów, ale wymaga również, aby parametry sesji, klucze i stan crypotgraphic były utrzymywane w pamięci dla wszystkich możliwych sesji (co najmniej dla konfigurowalnego przedziału czasu).</span><span class="sxs-lookup"><span data-stu-id="ac926-356">Session resumption can be useful to avoid the potentially expensive public-key operations used to share the key generation master secret and verify certificate signatures, but it also requires that the session parameters, keys, and crypotgraphic state be maintained in memory for all possible sessions (at least for a configurable time window).</span></span>

<span data-ttu-id="ac926-357">Bieżąca wersja NetX Secure TLS nie obsługuje wznawiania sesji — identyfikator sesji jest po prostu ignorowany przez serwery TLS i klienci TLS zawsze muszą podawać identyfikator sesji o wartości NULL, który powoduje, że serwer ma wykonać pełną uzgadnianie.</span><span class="sxs-lookup"><span data-stu-id="ac926-357">The current version of NetX Secure TLS does not support session resumption – the session ID is simply ignored by TLS servers and TLS clients always supply a NULL session ID which prompts the server to perform a complete handshake.</span></span> <span data-ttu-id="ac926-358">Brak wznowienia sesji nie powinien powodować problemów między procesami, ponieważ jest to całkowicie opcjonalna funkcja, a wszystkie implementacje protokołu TLS muszą domyślnie mieć wartość Ukończ uzgadnianie, jeśli identyfikator sesji jest równy NULL lub nie został rozpoznany.</span><span class="sxs-lookup"><span data-stu-id="ac926-358">The lack of session resumption should cause no inter-operability issues as it is a completely optional feature and all TLS implementations must default to a complete handshake should the session ID be NULL or unrecognized.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="ac926-359">Warstwy protokołu</span><span class="sxs-lookup"><span data-stu-id="ac926-359">Protocol Layering</span></span>

<span data-ttu-id="ac926-360">Protokół TLS pasuje do stosu sieciowego między warstwą transportu (np. TCP) i warstwą aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-360">The TLS protocol fits into the networking stack between the transport layer (e.g. TCP) and the application layer.</span></span> <span data-ttu-id="ac926-361">Protokół TLS jest czasami traktowany jako oparty na protokole transportowym (transport *Layer* Security), ale ponieważ działa jako aplikacja w odniesieniu do podstawowych protokołów sieciowych (takich jak TCP), ale czasami jest zgrupowana na warstwę aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-361">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols (such as TCP) it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="ac926-362">Protokół TLS wymaga protokołu warstwy transportowej, który obsługuje dostarczanie w kolejności i bezstratne, takie jak TCP.</span><span class="sxs-lookup"><span data-stu-id="ac926-362">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="ac926-363">Ze względu na to wymaganie protokół TLS nie może działać na podstawie protokołu UDP, ponieważ protokół UDP nie gwarantuje dostarczania datagramów.</span><span class="sxs-lookup"><span data-stu-id="ac926-363">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="ac926-364">Oddzielny protokół o nazwie *DTLS,* który jest zmodyfikowaną wersją protokołu TLS, jest używany w przypadku aplikacji wymagających zabezpieczeń TLS za pośrednictwem protokołu datagramu, takiego jak UDP.</span><span class="sxs-lookup"><span data-stu-id="ac926-364">A separate protocol called *DTLS,* which is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span> <span data-ttu-id="ac926-365">NetX Secure obsługuje DTLS, ale Dokumentacja dla DTLS jest oddzielona od tego dokumentu.</span><span class="sxs-lookup"><span data-stu-id="ac926-365">NetX Secure supports DTLS, but documentation for DTLS is separate from this document.</span></span>

![Diagram warstw protokołu TCP/IP i TLS.](media/image6.png)

<span data-ttu-id="ac926-367">Rysunek 5 — warstwy protokołów TCP/IP i TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-367">Figure 5- TCP/IP and TLS protocol layers</span></span>

## <a name="network-communications-security"></a><span data-ttu-id="ac926-368">Zabezpieczenia komunikacji sieciowej</span><span class="sxs-lookup"><span data-stu-id="ac926-368">Network Communications Security</span></span>

<span data-ttu-id="ac926-369">Zabezpieczanie komunikacji za pośrednictwem sieci publicznych oraz Internet jest ważnym tematem i tematem ogromnej liczby książek, artykułów i rozwiązań.</span><span class="sxs-lookup"><span data-stu-id="ac926-369">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="ac926-370">Temat jest bogglingly złożony, ale może być zredukowany do prostego pomysłu: wysłanie informacji za pośrednictwem sieci, tak aby tylko przewidziany obiekt docelowy mógł uzyskać dostęp do tych informacji lub je zmienić.</span><span class="sxs-lookup"><span data-stu-id="ac926-370">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="ac926-371">Ten podział na trzy ważne koncepcje: utajnienie, integralność i uwierzytelnianie.</span><span class="sxs-lookup"><span data-stu-id="ac926-371">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="ac926-372">Protokół TLS zawiera rozwiązania dla wszystkich trzech.</span><span class="sxs-lookup"><span data-stu-id="ac926-372">The TLS protocol provides solutions for all three.</span></span>

### <a name="secrecy"></a><span data-ttu-id="ac926-373">Są</span><span class="sxs-lookup"><span data-stu-id="ac926-373">Secrecy</span></span>

<span data-ttu-id="ac926-374">Podczas wysyłania danych przez sieć często ważne jest, aby dane nie były uzyskiwane przez złośliwą jednostkę.</span><span class="sxs-lookup"><span data-stu-id="ac926-374">When sending data over a network, it is often important that the data cannot be obtained by a malicious entity.</span></span> <span data-ttu-id="ac926-375">Jeśli dane są wysyłane za pośrednictwem połączenia TCP/IP, każda osoba mająca dostęp do sieci będzie mogła odczytywać te dane przy użyciu łatwo dostępnych narzędzi sieciowych.</span><span class="sxs-lookup"><span data-stu-id="ac926-375">If data is sent over a TCP/IP connection, anyone with access to the network will be able to read that data using easily-available networking tools.</span></span> <span data-ttu-id="ac926-376">Aby zapobiec uzyskiwaniu tych danych, należy je zakodować, aby nie można było ich odczytać z wyjątkiem zamierzonego celu — jest to *utajnienie.*</span><span class="sxs-lookup"><span data-stu-id="ac926-376">To prevent that data from being obtained, it must be encoded such that it cannot be read except by the intended target – this is *secrecy.*</span></span> <span data-ttu-id="ac926-377">W protokole TLS algorytmy szyfrowania, takie jak RSA i AES, zapewniają tajemnicę.</span><span class="sxs-lookup"><span data-stu-id="ac926-377">In TLS, encryption algorithms such as RSA and AES provide secrecy.</span></span>

### <a name="integrity"></a><span data-ttu-id="ac926-378">Integralność</span><span class="sxs-lookup"><span data-stu-id="ac926-378">Integrity</span></span>

<span data-ttu-id="ac926-379">Czasami utajnienie ochrony danych odbywa się za pośrednictwem sieci, co jest niewystarczające.</span><span class="sxs-lookup"><span data-stu-id="ac926-379">Sometimes, secrecy is not enough to protect data travelling over a network.</span></span> <span data-ttu-id="ac926-380">W niektórych przypadkach może być możliwe, aby złośliwa jednostka mogła zmienić zawartość pakietu TCP bez konieczności znajomości tego, co zawiera pakiet.</span><span class="sxs-lookup"><span data-stu-id="ac926-380">In some cases, it may be possible for a malicious entity to alter the contents of a TCP packet without needing to know what that packet contains.</span></span> <span data-ttu-id="ac926-381">Zaszyfrowane dane można zmienić, renderowanie nieprawidłowego lub zmiany parametrów komunikatu prowadzącego do dowolnych wyników, które osoba atakująca może chcieć osiągnąć.</span><span class="sxs-lookup"><span data-stu-id="ac926-381">Encrypted data can be altered, rendering the decryption invalid or changing the parameters of the message leading to whatever result the attacker may be interested in achieving.</span></span> <span data-ttu-id="ac926-382">W sieci firma Microsoft nie może zapobiec zmianie danych podczas przesyłania przez osobę atakującą, ale możemy udostępnić mechanizm, aby dowiedzieć się, czy dane zostały zmienione.</span><span class="sxs-lookup"><span data-stu-id="ac926-382">On the network, we cannot prevent an attacker from changing data in transit, but we can provide a mechanism to know whether or not the data has been changed.</span></span> <span data-ttu-id="ac926-383">Gdy dane są zmieniane podczas przesyłania, będą znane i można odrzucić dane.</span><span class="sxs-lookup"><span data-stu-id="ac926-383">When data is changed in transit, it will be known and the data can be rejected.</span></span> <span data-ttu-id="ac926-384">Jest to koncepcja *spójna*.</span><span class="sxs-lookup"><span data-stu-id="ac926-384">This concept is *integrity*.</span></span> <span data-ttu-id="ac926-385">W protokole TLS integralność jest zapewniana przez klasę procedur kryptograficznych znanych jako *funkcje skrótu*.</span><span class="sxs-lookup"><span data-stu-id="ac926-385">In TLS, integrity is provided by a class of cryptographic routines known as *hash functions*.</span></span> <span data-ttu-id="ac926-386">Niektóre przykłady funkcji mieszania to MD5 i SHA-1.</span><span class="sxs-lookup"><span data-stu-id="ac926-386">Some examples of hash functions are MD5 and SHA-1.</span></span>

### <a name="authentication"></a><span data-ttu-id="ac926-387">Authentication</span><span class="sxs-lookup"><span data-stu-id="ac926-387">Authentication</span></span>

<span data-ttu-id="ac926-388">Trzecia ważna koncepcja zabezpieczeń komunikacji sieciowej polega na tym, że dane powinny być przekazywane tylko do zamierzonego celu.</span><span class="sxs-lookup"><span data-stu-id="ac926-388">The third important concept in network communications security is the idea that data should only be communicated to the intended target.</span></span> <span data-ttu-id="ac926-389">Osoba atakująca może próbować stworzyć jako uprawniony podmiot do odbierania danych przeznaczonych dla innego hosta.</span><span class="sxs-lookup"><span data-stu-id="ac926-389">An attacker may attempt to pose as a legitimate entity to receive data intended for another host.</span></span> <span data-ttu-id="ac926-390">Nawet jeśli dane są wysyłane z mechanizmami zachowania poufności i integralności, osoba atakująca może nadal mieć możliwość osiągnięcia żądanego wyniku (bezpieczeństwo komunikacji) przez ten proces.</span><span class="sxs-lookup"><span data-stu-id="ac926-390">Even if the data is being sent with secrecy and integrity mechanisms in place, the attacker may still be able to achieve the desired result (a compromise of secure communications) through this deception.</span></span> <span data-ttu-id="ac926-391">Aby tego uniknąć, mechanizm jest wymagany do potwierdzenia tożsamości hosta zdalnego przed wysłaniem poufnych danych.</span><span class="sxs-lookup"><span data-stu-id="ac926-391">To prevent this, a mechanism is needed to prove the identity of a remote host before any sensitive data is sent.</span></span> <span data-ttu-id="ac926-392">Proces potwierdzania tożsamości hosta zdalnego jest *uwierzytelniany.*</span><span class="sxs-lookup"><span data-stu-id="ac926-392">The process of proving the identity of a remote host is *authentication.*</span></span> <span data-ttu-id="ac926-393">W protokole TLS uwierzytelnianie jest zapewniane przy użyciu certyfikatów cyfrowych, funkcji skrótu i mechanizmu zwanego *podpisami cyfrowymi* , które korzystają z właściwości szyfrowania klucza publicznego (opisanych poniżej).</span><span class="sxs-lookup"><span data-stu-id="ac926-393">In TLS, authentication is provided using digital certificates, hash functions, and a mechanism called *digital signatures* which utilizes a property of public-key encryption (described below).</span></span> <span data-ttu-id="ac926-394">Za pomocą *klucza wstępnego* (PSK) można również uzyskać ograniczoną, ale przydatną formę uwierzytelniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-394">A limited but useful form of authentication can also be provided with a *pre-shared key* (PSK).</span></span>

## <a name="tls-encryption"></a><span data-ttu-id="ac926-395">Szyfrowanie TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-395">TLS Encryption</span></span>

<span data-ttu-id="ac926-396">Protokół TLS jest strukturą zapewniającą bezpieczną komunikację sieciową za pośrednictwem Internetu wykorzystującego szyfrowanie.</span><span class="sxs-lookup"><span data-stu-id="ac926-396">The TLS protocol is a framework for providing secure network communications over the Internet utilizing encryption.</span></span> <span data-ttu-id="ac926-397">Szyfrowanie jest ogólnie zdefiniowane jako proces kodowania danych w taki sposób, że uzyskanie oryginalnych danych (lub informacji o tych danych) jest bardziej trudne, bez *klucza*.</span><span class="sxs-lookup"><span data-stu-id="ac926-397">Encryption is generally defined as the process of encoding data in such a way that obtaining the original data (or information about that data) is exceedingly difficult without a *key*.</span></span> <span data-ttu-id="ac926-398">W systemach komputerowych szyfrowanie jest oparte na złożonych matematykach, takich jak ograniczone pola i można je klasyfikować do dwóch typów: *klucza prywatnego* (lub *szyfrowania symetrycznego*) i *klucza publicznego* (lub *szyfrowania asymetrycznego*).</span><span class="sxs-lookup"><span data-stu-id="ac926-398">In computer systems encryption is based on complex mathematics such as finite fields and can be classified into two types: *private key* (or *symmetric encryption*) and *public key* (or *asymmetric encryption*).</span></span> <span data-ttu-id="ac926-399">Przykładami szyfrowania klucza prywatnego są AES (Advanced Encryption Standard) i RC4 (Rivest cipher 4).</span><span class="sxs-lookup"><span data-stu-id="ac926-399">Examples of private key encryption are AES (Advanced Encryption Standard) and RC4 (Rivest Cipher 4).</span></span> <span data-ttu-id="ac926-400">Przykładami szyfrowania klucza publicznego są RSA (Rivest, Shamir, Adleson) i Diffie-Hellman szyfrów.</span><span class="sxs-lookup"><span data-stu-id="ac926-400">Examples of public-key encryption are the RSA (Rivest, Shamir, Adleson) and Diffie-Hellman ciphers.</span></span>

<span data-ttu-id="ac926-401">Protokół TLS wykorzystuje zarówno procedury szyfrowania klucza prywatnego, jak i klucza publicznego, aby zapewnić balans wydajności, zabezpieczenia i elastyczność.</span><span class="sxs-lookup"><span data-stu-id="ac926-401">The TLS protocol makes use of both private key and public key encryption routines to provide a balance of performance, security, and flexibility.</span></span>

### <a name="private-key-encryption"></a><span data-ttu-id="ac926-402">Szyfrowanie Private-Key</span><span class="sxs-lookup"><span data-stu-id="ac926-402">Private-Key Encryption</span></span>

<span data-ttu-id="ac926-403">Szyfrowanie klucza prywatnego jest używane przez tysiące lat.</span><span class="sxs-lookup"><span data-stu-id="ac926-403">Private-key encryption has been in use for thousands of years.</span></span> <span data-ttu-id="ac926-404">Podstawowe szyfrowanie podstawiania (gdzie litera lub wyraz jest zastępowana przez inną niepokrewną literę lub słowo) to najstarsze znane przykłady szyfrowania, ale z pojawieniu szyfrowanie klucza prywatnego w wieku informacji znacznie Ulepszono.</span><span class="sxs-lookup"><span data-stu-id="ac926-404">Basic substitution ciphers (where a letter or word is replaced by another unrelated letter or word) are the earliest known examples of encryption, but with the advent of the information age private key encryption has significantly improved.</span></span>

<span data-ttu-id="ac926-405">Szyfr klucza prywatnego używa "klucza", który jest po prostu wartością (która może być słowem, frazą lub cyfrą w ogólnym przypadku), która jest używana do dodanego sposobu kodowania niektórych danych, tak aby tylko jednostka, która miała dostęp do tego klucza, mogła zdekodować dane w zrozumiały sposób.</span><span class="sxs-lookup"><span data-stu-id="ac926-405">A private key cipher uses a "key" which is simply a value (which could be a word, phrase, or number in the general case) that is used to somehow encode some data so that only an entity that had access to that key could decode the data in a meaningful way.</span></span> <span data-ttu-id="ac926-406">Klucz służy do szyfrowania i odszyfrowywania danych, a tym samym *szyfrowania symetrycznego*.</span><span class="sxs-lookup"><span data-stu-id="ac926-406">The key is used for both encryption and decryption of the data, hence the other name *symmetric encryption*.</span></span>

<span data-ttu-id="ac926-407">Szyfry klucza prywatnego są generalnie szybkie i stosunkowo proste do zaimplementowania, nawet jeśli te matematyczne przekroczenia są bardziej skomplikowane.</span><span class="sxs-lookup"><span data-stu-id="ac926-407">Private key ciphers are generally fast and fairly simple to implement, even if the mathematics involved are exceedingly complex.</span></span> <span data-ttu-id="ac926-408">Z tego powodu protokół TLS używa szyfrów kluczy prywatnych do masowej bezpiecznej komunikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-408">For this reason, TLS uses private key ciphers for the bulk of secure communications.</span></span>

<span data-ttu-id="ac926-409">Jednak szyfrowanie klucza prywatnego ma problem podczas próby zastosowania go do ogólnej komunikacji sieciowej komputera: klucz musi być współużytkowany między obiema komputerami próbującymi komunikować się.</span><span class="sxs-lookup"><span data-stu-id="ac926-409">However, private key encryption has a problem when we try to apply it to general computer network communications: the key must be shared between both machines trying to communicate.</span></span> <span data-ttu-id="ac926-410">Ogólnie rzecz biorąc, niepraktyczne i często nie można prawidłowo komunikować klucza prywatnego między dwoma komputerami w Internecie, ponieważ może być zakładany, że ruch sieciowy może być uzyskiwany przez dowolną liczbę jednostek w różnych przeskokach, które są wykonywane podczas routingu przez Internet.</span><span class="sxs-lookup"><span data-stu-id="ac926-410">In the general case, it is impractical and often impossible to communicate a private key securely between two machines on the Internet, as it can be assumed that the network traffic can be obtained by any number of entities in the various hops that data takes when being routed through the Internet.</span></span> <span data-ttu-id="ac926-411">Jeśli klucz jest uzyskiwany przez złośliwą jednostkę, wszystkie dane zaszyfrowane za pomocą tego klucza zostaną naruszone.</span><span class="sxs-lookup"><span data-stu-id="ac926-411">If the key is obtained by a malicious entity, all data encrypted using that key is compromised.</span></span> <span data-ttu-id="ac926-412">Ponieważ większość maszyn w Internecie ma tylko połączenie sieciowe, a nie inny bezpieczny kanał na potrzeby komunikacji, wysyłanie kluczy przez sieć jest tantamount do wysyłania nieszyfrowanych danych — nie zapewnia żadnych zabezpieczeń.</span><span class="sxs-lookup"><span data-stu-id="ac926-412">As most machines on the Internet have only a network connection and not another secure channel for communications, sending keys over the network is tantamount to sending the data unencrypted – it provides no security.</span></span>

<span data-ttu-id="ac926-413">Z tego powodu szyfrowanie klucza prywatnego nie jest wystarczające do wdrożenia protokołu zabezpieczeń komunikacji sieciowej ogólnego przeznaczenia.</span><span class="sxs-lookup"><span data-stu-id="ac926-413">For this reason, private key encryption is not sufficient to implement a general-purpose network communications security protocol.</span></span> <span data-ttu-id="ac926-414">Jest to miejsce, w którym może pomóc szyfrowanie klucza publicznego.</span><span class="sxs-lookup"><span data-stu-id="ac926-414">This is where Public Key encryption can help.</span></span>

<span data-ttu-id="ac926-415">NetX Secure TLS obsługuje szyfrowanie klucza prywatnego AES.</span><span class="sxs-lookup"><span data-stu-id="ac926-415">NetX Secure TLS supports AES private-key encryption.</span></span>

### <a name="public-key-encryption"></a><span data-ttu-id="ac926-416">Szyfrowanie Public-Key</span><span class="sxs-lookup"><span data-stu-id="ac926-416">Public-Key Encryption</span></span>

<span data-ttu-id="ac926-417">W przeciwieństwie do szyfrowania klucza prywatnego szyfrowanie klucza publicznego to dość nowe pojęcie, które zostało opracowane w 1970 r.</span><span class="sxs-lookup"><span data-stu-id="ac926-417">Unlike private key encryption, public key encryption is a fairly new concept, having been developed in the 1970's.</span></span> <span data-ttu-id="ac926-418">W przypadku użycia koncepcji zwanej "funkcjami" podlewek "i" pułapki ", stwierdzono, że istnieje sposób udostępniania klucza przez sieć bez naruszania zabezpieczeń zaszyfrowanych danych.</span><span class="sxs-lookup"><span data-stu-id="ac926-418">Using a concept known as "trap-door functions" in mathematics, it was discovered that there was a way to share a key over a network without compromising the security of then encrypted data.</span></span>

<span data-ttu-id="ac926-419">Sposób działania szyfrowania klucza publicznego polega na tym, że klucz (w powyższym sensie szyfrowania kluczem prywatnym) jest podzielony na dwie części, *klucz prywatny* i *klucz publiczny*, z którego jest pobierana nazwa klucza publicznego.</span><span class="sxs-lookup"><span data-stu-id="ac926-419">The way public key encryption works is that the key (in the private-key encryption sense described above) is split into two parts, a *private key* and a *public key*, from where public key encryption gets its name.</span></span> <span data-ttu-id="ac926-420">Koncepcja polega na tym, że jeden z tych kluczy (zazwyczaj klucz publiczny) jest używany do szyfrowania, podczas gdy drugi jest używany do odszyfrowywania.</span><span class="sxs-lookup"><span data-stu-id="ac926-420">The concept is that one of these keys (typically the public key) is used for encryption, while the other is used for decryption.</span></span> <span data-ttu-id="ac926-421">Ta wartość asymetrii kluczy jest przyczyną drugiej nazwy szyfrowania klucza publicznego: *szyfrowania asymetrycznego*.</span><span class="sxs-lookup"><span data-stu-id="ac926-421">This asymmetry of keys is the reason for the other name for public key encryption: *asymmetric encryption*.</span></span>

<span data-ttu-id="ac926-422">Matematyka za szyfrowaniem klucza publicznego jest dość złożona, ale pomysłem jest, że klucz publiczny może być używany *tylko* do szyfrowania i uzyskanie tego klucza nie zezwala na uzyskiwanie zaszyfrowanych danych.</span><span class="sxs-lookup"><span data-stu-id="ac926-422">The mathematics behind public key encryption are fairly complex, but the idea is that the public key can *only* be used for encryption, and obtaining that key does not allow encrypted data to be obtained.</span></span> <span data-ttu-id="ac926-423">Z kolei klucz prywatny jest jedynym sposobem odszyfrowania danych zaszyfrowanych przy użyciu klucza publicznego.</span><span class="sxs-lookup"><span data-stu-id="ac926-423">The private key, in turn, is the only way to decrypt data encrypted using the public key.</span></span> <span data-ttu-id="ac926-424">W ten sposób przez utrzymywanie tajnego klucza prywatnego każda osoba, która chce bezpiecznie komunikować się z właścicielem tego klucza prywatnego, musi tylko szyfrować dane przy użyciu odpowiedniego klucza publicznego z wiedzą, że tylko ktoś w posiadaniu tego klucza prywatnego może uzyskać bezpieczne dane.</span><span class="sxs-lookup"><span data-stu-id="ac926-424">Thus, by keeping the private key secret, anyone wishing to communicate securely with the owner of that private key need only encrypt their data with the corresponding public key with the knowledge that only someone in possession of that private key can obtain the secure data.</span></span>

<span data-ttu-id="ac926-425">NetX Secure TLS obsługuje szyfrowanie klucza publicznego RSA.</span><span class="sxs-lookup"><span data-stu-id="ac926-425">NetX Secure TLS supports RSA public-key encryption.</span></span>

> [!IMPORTANT] 
> <span data-ttu-id="ac926-426">*Klucz RSA to bardzo duże użycie procesora, jeśli jest używana implementacja RSA oprogramowania. Większe rozmiary kluczy zwiększają moc obliczeniową wymaganą przez współczynnik kwadratowy — w przypadku dwukrotnego wzrostu rozmiaru klucza.*</span><span class="sxs-lookup"><span data-stu-id="ac926-426">*RSA is a very processor-intensive operation if the software RSA implementation is used. Larger key sizes increase the processing power required by a square factor – 4X slower for a 2X increase in key size.*</span></span>

### <a name="public-key-authentication"></a><span data-ttu-id="ac926-427">Uwierzytelnianie Public-Key</span><span class="sxs-lookup"><span data-stu-id="ac926-427">Public-Key Authentication</span></span>

<span data-ttu-id="ac926-428">Interesujący efekt działania koncepcji szyfrowania klucza publicznego polega na tym, że można go użyć do zapewnienia uwierzytelniania oraz szyfrowania przez wykonanie operacji w odwrotnej postaci: szyfrowanie przy użyciu klucza *prywatnego* i odszyfrowywanie przy użyciu klucza *publicznego* .</span><span class="sxs-lookup"><span data-stu-id="ac926-428">An interesting side-effect of the public-key encryption concept is that it can be used to provide authentication as well as encryption by doing the operation in reverse: encrypting using the *private* key and decrypting using the *public* key.</span></span> <span data-ttu-id="ac926-429">Rzeczywisty mechanizm wykonywania tej czynności zależy od używanego algorytmu klucza publicznego, ale koncepcja jest taka sama.</span><span class="sxs-lookup"><span data-stu-id="ac926-429">The actual mechanism for doing this depends on the public key algorithm being used, but the concept is the same.</span></span>

<span data-ttu-id="ac926-430">W celu uwierzytelnienia przy użyciu uwierzytelniania za pomocą klucza publicznego właściciel klucza prywatnego szyfruje niektóre dane (zazwyczaj skrót kryptograficzny danych do uwierzytelnienia) przy użyciu tego klucza prywatnego.</span><span class="sxs-lookup"><span data-stu-id="ac926-430">To authenticate using public key authentication, the owner of a private key encrypts some piece of data (typically a cryptographic hash of the data to be authenticated) using that private key.</span></span> <span data-ttu-id="ac926-431">Następnie ktoś chcący uwierzytelniać dane pochodzące od właściciela klucza prywatnego za pomocą skojarzonego klucza publicznego do odszyfrowania danych — w przypadku pomyślnego odszyfrowania i zaakceptowania przez użytkownika wiarygodności tego klucza publicznego użytkownik może mieć pewność, że dane pochodzą od właściciela klucza prywatnego.</span><span class="sxs-lookup"><span data-stu-id="ac926-431">Then, someone wishing to authenticate that the data came from the owner of the private key uses the associated public key to decrypt the data – if the decryption is successful, and assuming the user trusted the validity of that public key, then the user can be certain that the data came from the owner of the private key.</span></span>

<span data-ttu-id="ac926-432">W protokole TLS uwierzytelnianie klucza publicznego służy do sprawdzania poprawności certyfikatu cyfrowego dostarczonego przez serwer TLS (oraz opcjonalnie klienta protokołu TLS) przy użyciu kluczy publicznych z zaufanego magazynu certyfikatów.</span><span class="sxs-lookup"><span data-stu-id="ac926-432">In TLS, public key authentication is used to verify the validity of a digital certificate provided by a TLS server (and optionally the TLS client) using public keys from the trusted certificate store.</span></span> <span data-ttu-id="ac926-433">Certyfikat jest sprawdzany pod kątem klucza publicznego w magazynie, a dane w certyfikacie są używane do sprawdzenia tożsamości serwera.</span><span class="sxs-lookup"><span data-stu-id="ac926-433">The certificate is checked against a public key in the store and the data in the certificate is used to check the identity of the server.</span></span>

<span data-ttu-id="ac926-434">NetX Secure TLS obsługuje uwierzytelnianie RSA.</span><span class="sxs-lookup"><span data-stu-id="ac926-434">NetX Secure TLS supports RSA authentication.</span></span>

### <a name="cryptographic-hashing"></a><span data-ttu-id="ac926-435">Mieszanie kryptograficzne</span><span class="sxs-lookup"><span data-stu-id="ac926-435">Cryptographic Hashing</span></span>

<span data-ttu-id="ac926-436">Szyfrowanie nie jest jedyną operacją kryptograficzną używaną w protokole TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-436">Encryption is not the only cryptographic operation used in TLS.</span></span> <span data-ttu-id="ac926-437">Aby zapewnić integralność komunikatów podczas sesji TLS, należy uzyskać sumę kontrolną, aby upewnić się, że zawartość komunikatu nie została naruszona.</span><span class="sxs-lookup"><span data-stu-id="ac926-437">In order to provide message integrity during a TLS session, a checksum is needed to ensure that the message contents have not been tampered with.</span></span> <span data-ttu-id="ac926-438">Jednak prostą sumę kontrolną (używaną w protokole TCP) nie wystarczą do zagwarantowania akceptowalnego poziomu integralności, ponieważ może on być łatwo przeczytany przez osobę atakującą.</span><span class="sxs-lookup"><span data-stu-id="ac926-438">However, a simple checksum (as is used in TCP) is insufficient to guarantee an acceptable level of integrity as it can be easily subverted by a knowledgeable attacker.</span></span> <span data-ttu-id="ac926-439">Mechanizm używany przez protokół TLS w celu zapewnienia integralności komunikatów jest znany jako *skrót kryptograficzny*.</span><span class="sxs-lookup"><span data-stu-id="ac926-439">The mechanism used by TLS to provide message integrity is known as a *cryptographic hash*.</span></span>

<span data-ttu-id="ac926-440">Szyfrowanie jest kodowaniem 1:1 — to oznacza, że wszystkie oryginalne dane można uzyskać z zaszyfrowanych danych.</span><span class="sxs-lookup"><span data-stu-id="ac926-440">Encryption is a 1:1 encoding – that is, the entirety of the original data can be obtained from the encrypted data.</span></span> <span data-ttu-id="ac926-441">Jednak skrót mapuje dowolną ilość danych do wartości o ustalonym rozmiarze, podobnie jak suma kontrolna.</span><span class="sxs-lookup"><span data-stu-id="ac926-441">However, a hash maps an arbitrary amount of data into a fixed size value, just like a checksum.</span></span> <span data-ttu-id="ac926-442">W przeciwieństwie do prostej sumy kontrolnej, skrót jest specjalnie zaprojektowany w celu ograniczenia *kolizji*, gdzie różne dane wejściowe są w tym samym wyniku.</span><span class="sxs-lookup"><span data-stu-id="ac926-442">Unlike a simple checksum, a hash is specifically designed to reduce *collisions*, where different input data result in the same output.</span></span> <span data-ttu-id="ac926-443">W przypadku prostej sumy kontrolnej, jeśli bit zostanie przerzucony z 1 do 0 i inny bit od 0 do 1, suma kontrolna jest taka sama.</span><span class="sxs-lookup"><span data-stu-id="ac926-443">In a simple checksum, if a bit is flipped from 1 to 0 and another bit from 0 to 1, the checksum is the same.</span></span> <span data-ttu-id="ac926-444">W przypadku użycia skrótu kryptograficznego dane wyjściowe różnią się znacznie, co utrudnia osobie atakującej zmianę danych skrótów i wykonywanie operacji skrótu dla zmienionych danych nadal będzie miało taką samą wartość (i w związku z tym fałszywe sprawdzanie integralności tych danych).</span><span class="sxs-lookup"><span data-stu-id="ac926-444">With a cryptographic hash, the output would differ significantly, making it difficult for an attacker to change the hashed data and have the hash operation on the changed data still result in the same value (and thus falsely verifying the integrity of that data).</span></span>

<span data-ttu-id="ac926-445">Protokół TLS używa wielu różnych algorytmów wyznaczania wartości skrótu w celu zapewnienia integralności komunikatów, komunikatów aplikacji i komunikatów kontroli protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-445">TLS uses a number of different hash algorithms to provide integrity for messages, both application messages and TLS control messages.</span></span> <span data-ttu-id="ac926-446">Należą do nich MD5, SHA-1 i SHA-256.</span><span class="sxs-lookup"><span data-stu-id="ac926-446">These include MD5, SHA-1 and SHA-256.</span></span>

<span data-ttu-id="ac926-447">NetX Secure TLS obsługuje funkcję mieszania MD5, SHA-1 i SHA-256.</span><span class="sxs-lookup"><span data-stu-id="ac926-447">NetX Secure TLS supports MD5, SHA-1, and SHA-256 hashing.</span></span>

## <a name="tls-extensions"></a><span data-ttu-id="ac926-448">Rozszerzenia protokołu TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-448">TLS Extensions</span></span>

<span data-ttu-id="ac926-449">Protokół TLS udostępnia wiele rozszerzeń zapewniających dodatkowe funkcje dla niektórych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-449">TLS provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="ac926-450">Te rozszerzenia są zwykle wysyłane jako część komunikatów komunikacie ClientHello lub ServerHello, co oznacza, że host zdalny chce użyć rozszerzenia lub podać dodatkowe szczegóły do użycia podczas ustanawiania bezpiecznej sesji protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-450">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="ac926-451">Ogólnie rzecz biorąc, rozszerzenia udostępniają opcjonalne parametry do protokołu TLS na początku uzgadniania, które kierują operacje dokonywania.</span><span class="sxs-lookup"><span data-stu-id="ac926-451">In general, extensions provide optional parameters to TLS at the beginning of the handshake that guide the proceeding operations.</span></span> <span data-ttu-id="ac926-452">Niektóre rozszerzenia wymagają wprowadzenia do aplikacji lub podejmowania decyzji, podczas gdy inne są obsługiwane automatycznie.</span><span class="sxs-lookup"><span data-stu-id="ac926-452">Some extensions require application input or decision making, while others are handled automatically.</span></span>

<span data-ttu-id="ac926-453">W poniższej tabeli opisano rozszerzenia protokołu TLS aktualnie obsługiwane przez NetX Secure TLS:</span><span class="sxs-lookup"><span data-stu-id="ac926-453">The following table describes the TLS extensions currently supported by NetX Secure TLS:</span></span>

| <span data-ttu-id="ac926-454">**Nazwa rozszerzenia**</span><span class="sxs-lookup"><span data-stu-id="ac926-454">**Extension Name**</span></span>              | <span data-ttu-id="ac926-455">**Opis**</span><span class="sxs-lookup"><span data-stu-id="ac926-455">**Description**</span></span>              |
| ------------------------------- |----------------------------- |
| <span data-ttu-id="ac926-456">Wskazanie bezpiecznego ponownego negocjowania</span><span class="sxs-lookup"><span data-stu-id="ac926-456">Secure Renegotiation Indication</span></span> | <span data-ttu-id="ac926-457">To rozszerzenie ogranicza ataki typu man-in-the-Middle, które mogą wystąpić podczas uzgadniania renegocjacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-457">This extension mitigates a Man-in-the-Middle attack vulnerability that could occur during a renegotiation handshake.</span></span>|
| <span data-ttu-id="ac926-458">Oznaczanie nazwy serwera</span><span class="sxs-lookup"><span data-stu-id="ac926-458">Server Name Indication</span></span>          | <span data-ttu-id="ac926-459">To rozszerzenie umożliwia klientowi protokołu TLS dostarczenie określonej nazwy DNS serwerowi TLS, co umożliwia serwerowi wybranie poprawnych poświadczeń (zakłada, że serwer ma wiele certyfikatów tożsamości i punktu wejścia sieci).</span><span class="sxs-lookup"><span data-stu-id="ac926-459">This extension allows a TLS Client to supply a specific DNS name to a TLS Server, allowing the server to select the correct credentials (assumes the server has multiple identity certificates and network entrypoints).</span></span> |
| <span data-ttu-id="ac926-460">Algorytmy sygnatur</span><span class="sxs-lookup"><span data-stu-id="ac926-460">Signature Algorithms</span></span>            | <span data-ttu-id="ac926-461">To rozszerzenie umożliwia klientowi protokołu TLS udostępnienie listy akceptowalnych algorytmów sygnatur i wyznaczania wartości skrótu na serwerze TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-461">This extension enables a TLS Client to provide a list of acceptable signature and hash algorithms to a TLS Server.</span></span> |

<span data-ttu-id="ac926-462">Omówienie obsługiwanych rozszerzeń protokołu TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-462">Overview of supported TLS Extensions</span></span>

### <a name="secure-renegotiation-indication"></a><span data-ttu-id="ac926-463">Wskazanie bezpiecznego ponownego negocjowania</span><span class="sxs-lookup"><span data-stu-id="ac926-463">Secure Renegotiation Indication</span></span>

<span data-ttu-id="ac926-464">Protokół TLS obsługuje uzgadnianie w ramach istniejącej sesji TLS przy użyciu ustanowionej sesji do szyfrowania komunikatów uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-464">TLS supports the notion of performing a handshake within an existing TLS session, thereby using the established session to encrypt the handshake messages.</span></span> <span data-ttu-id="ac926-465">Ten proces umożliwia ponowne ustanowienie kluczy sesji kryptograficznej bez kończenia sesji TLS (patrz sekcja "renegocjowanie sesji TLS").</span><span class="sxs-lookup"><span data-stu-id="ac926-465">This process allows the cryptographic session keys to be re-established without ending the TLS session (see section "TLS Session Renegotiation").</span></span>

<span data-ttu-id="ac926-466">Niestety, gdy protokół TLS był używany do ponownej negocjacji przez jakiś czas, okazało się, że wystąpił Luka w zabezpieczeniach ataku typu man-in-the-Middle, który korzystał z funkcji renegocjacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-466">Unfortunately, after TLS had been using renegotiation for some time, it was discovered that there was a vulnerability to a Man-in-the-Middle attack that exploited the renegotiation feature.</span></span> <span data-ttu-id="ac926-467">Aby zamknąć luki w zabezpieczeniach, wprowadzono rozszerzenie "oznaczenie bezpiecznego ponownego negocjowania".</span><span class="sxs-lookup"><span data-stu-id="ac926-467">To close the vulnerability, the Secure Renegotiation Indication extension was introduced.</span></span> <span data-ttu-id="ac926-468">W związku z tym rozszerzenie Secure renegocjacji używa skrótu gotowego komunikatu z ustalonego połączenia, aby sprawdzić, czy oryginalne hosty uczestniczą w uzgadnianiu renegocjacji — w związku z tym skrót jest używany jako token weryfikacyjny w założeniu, że osoba atakująca nie będzie w stanie sfałszować skrótu (co wymagałoby dostępu do kluczy sesji).</span><span class="sxs-lookup"><span data-stu-id="ac926-468">Essentially, the Secure Renegotiation extension uses the Finished message hash from the established connection to verify that the original hosts are participating in the renegotiation handshake – essentially the hash is used as a verification token under the assumption that an attacker would not be able to forge the hash (which would require access to the session keys).</span></span>

<span data-ttu-id="ac926-469">NetX Secure TLS obsługuje automatyczne ponowne negocjowanie i domyślnie używa rozszerzenia Secure renegocjacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-469">NetX Secure TLS handles renegotiation automatically and uses the Secure Renegotiation Extension by default.</span></span> <span data-ttu-id="ac926-470">Interakcja aplikacji nie jest wymagana.</span><span class="sxs-lookup"><span data-stu-id="ac926-470">No application interaction is required.</span></span>

### <a name="server-name-indication"></a><span data-ttu-id="ac926-471">Oznaczanie nazwy serwera</span><span class="sxs-lookup"><span data-stu-id="ac926-471">Server Name Indication</span></span>

<span data-ttu-id="ac926-472">Podczas uzgadniania protokołu TLS klient protokołu TLS oczekuje serwera zdalnego, aby zapewnić certyfikat tożsamości, aby klient mógł uwierzytelnić serwer.</span><span class="sxs-lookup"><span data-stu-id="ac926-472">During the TLS handshake, a TLS Client expects a remote server to provide an identity certificate so the client can authenticate the server.</span></span> <span data-ttu-id="ac926-473">Mogą jednak wystąpić sytuacje, w których serwer dostarczy wiele różnych usług z różnymi serwerami wirtualnymi z każdym unikatowymi tożsamościami.</span><span class="sxs-lookup"><span data-stu-id="ac926-473">However, there may be some cases where a server will provide multiple different services with different "virtual" servers each having unique identities.</span></span> <span data-ttu-id="ac926-474">W przypadku pojedynczego serwera z wieloma tożsamościami klient protokołu TLS może podać określoną nazwę DNS, która będzie używana przez serwer do wybrania odpowiednich poświadczeń — mechanizm dostarczania tej nazwy jest rozszerzeniem Oznaczanie nazwy serwera (SNI).</span><span class="sxs-lookup"><span data-stu-id="ac926-474">In the case of a single server with multiple identities, a TLS client can supply a specific DNS name that the server will use to select the proper credentials – the mechanism for supplying this name is the Server Name Indication (SNI) extension.</span></span>

<span data-ttu-id="ac926-475">W przypadku aplikacji używającej rozszerzenia SNI wymagane jest pewne interakcje.</span><span class="sxs-lookup"><span data-stu-id="ac926-475">For an application using the SNI extension, some interaction is required.</span></span> <span data-ttu-id="ac926-476">W przypadku klientów TLS aplikacja musi podać nazwę DNS do wysłania do serwera zdalnego.</span><span class="sxs-lookup"><span data-stu-id="ac926-476">For TLS Clients, the application must supply a DNS name to be sent to the remote server.</span></span> <span data-ttu-id="ac926-477">W przypadku serwerów TLS aplikacja musi odczytać nazwę DNS z rozszerzenia i wybrać odpowiedni certyfikat, aby wysłać z powrotem do klienta.</span><span class="sxs-lookup"><span data-stu-id="ac926-477">For TLS Servers, the application must read the DNS name from the extension and select an appropriate certificate to send back to the client.</span></span>

<span data-ttu-id="ac926-478">W poniższych sekcjach zawarto więcej szczegółowych informacji na temat używania rozszerzenia SNI w NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-478">The following sections provide more detail on how to use the SNI extension in NetX Secure TLS.</span></span>

### <a name="sni-extension--tls-client"></a><span data-ttu-id="ac926-479">Rozszerzenie SNI — klient TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-479">SNI Extension – TLS Client</span></span>

<span data-ttu-id="ac926-480">Klient usługi NetX Secure TLS chcący użyć rozszerzenia SNI musi podać nazwę DNS, która ma zostać dostarczona podczas uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-480">A NetX Secure TLS Client wishing to use the SNI extension must provide a DNS name to TLS to be supplied during the handshake.</span></span> <span data-ttu-id="ac926-481">Ta nazwa musi zostać zainicjowana i dostarczona przed rozpoczęciem sesji TLS od momentu wysłania rozszerzenia w komunikacie komunikacie ClientHello, który uruchamia proces uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-481">This name must be initialized and supplied prior to starting a TLS session since the extension is sent in the ClientHello message which starts the handshake process.</span></span>

<span data-ttu-id="ac926-482">Poniższy fragment kodu ilustruje użycie rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="ac926-482">The following code snippet illustrates the use of the extension.</span></span> <span data-ttu-id="ac926-483">Najpierw obiekt NX_SECURE_X509_DNS_NAME jest inicjowany z żądaną nazwą serwera.</span><span class="sxs-lookup"><span data-stu-id="ac926-483">First, a NX_SECURE_X509_DNS_NAME object is initialized with the desired server name.</span></span> <span data-ttu-id="ac926-484">Następnie, przed rozpoczęciem sesji TLS, nazwa jest dostarczana do protokołu TLS przy użyciu interfejsu API rozszerzenia SNI.</span><span class="sxs-lookup"><span data-stu-id="ac926-484">Then, prior to starting the TLS session, the name is provided to TLS using the SNI extension API.</span></span> <span data-ttu-id="ac926-485">Po ustawieniu nazwy nie są wymagane żadne dalsze akcje.</span><span class="sxs-lookup"><span data-stu-id="ac926-485">Once the name is set, no further action is required.</span></span> <span data-ttu-id="ac926-486">Zobacz informacje o interfejsie API w rozdziale 4</span><span class="sxs-lookup"><span data-stu-id="ac926-486">See the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="ac926-487">Opis usług NetX Secure Services, aby uzyskać więcej informacji na temat poszczególnych funkcji.</span><span class="sxs-lookup"><span data-stu-id="ac926-487">Description of NetX Secure Services for more information on the individual functions.</span></span>

```C
/* The dns_name variable will contain our desired server name. */
UINT status;
NX_SECURE_X509_DNS_NAME dns_name;

/* Initialize the server DNS name. */
status = nx_secure_x509_dns_name_initialize(&dns_name, "www.example.com", 
                                            strlen("www.example.com"));


/* Initialize SNI extension in previously-initialized TLS Session. */
status = nx_secure_tls_session_sni_extension_set(&client_tls_session, &dns_name);

/* Now start the TLS session, starting with establishing the TCP connection – if 
   TLS is started before initializing the SNI extension, the extension will not be 
   sent in the ClientHello message! */
status = nx_tcp_client_socket_connect(&client_socket, IP_ADDRESS(1, 2, 3, 4), 443, 
                                      5 * NX_IP_PERIODIC_RATE);

status = nx_secure_tls_session_start(&client_tls_session, &client_socket, 
                                     NX_WAIT_FOREVER);
```
### <a name="sni-extension--tls-server"></a><span data-ttu-id="ac926-488">Rozszerzenie SNI — serwer TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-488">SNI Extension – TLS Server</span></span>

<span data-ttu-id="ac926-489">Po stronie serwera TLS rozszerzenie SNI może być przetwarzane przez aplikację w celu wybrania odpowiednich poświadczeń (np. certyfikatów) do dostarczenia klientom zdalnym podczas uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-489">On the TLS Server side, the SNI extension may be processed by the application in order to select proper credentials (e.g. certificate) to provide to the remote client during the handshake.</span></span> <span data-ttu-id="ac926-490">W tym celu aplikacja musi dostarczyć wywołanie zwrotne sesji, które jest wywoływane po odebraniu komunikatu komunikacie ClientHello.</span><span class="sxs-lookup"><span data-stu-id="ac926-490">To do this, the application must supply a session callback which is invoked following the receipt of a ClientHello message.</span></span>

<span data-ttu-id="ac926-491">Przykładowy kod dla interfejsu API nx_secure_tls_session_server_callback_set (patrz strona 122) ilustruje analizowanie przychodzącego rozszerzenia SNI przy użyciu wywołania zwrotnego serwera.</span><span class="sxs-lookup"><span data-stu-id="ac926-491">The example code for the nx_secure_tls_session_server_callback_set API  (see page 122) illustrates the parsing of an incoming SNI extension using a server callback.</span></span> <span data-ttu-id="ac926-492">Zasadniczo serwer TLS odbiera komunikacie ClientHello i wywołuje wywołanie zwrotne.</span><span class="sxs-lookup"><span data-stu-id="ac926-492">Essentially, the TLS Server receives a ClientHello and invokes the callback.</span></span> <span data-ttu-id="ac926-493">Następnie aplikacja używa interfejsu API *nx_secure_tls_session_sni_extension_parse* , aby przeanalizować dane rozszerzenia dostarczone do wywołania zwrotnego, aby znaleźć rozszerzenie SNI i zwrócić podaną nazwę DNS (należy zauważyć, że rozszerzenie obsługuje tylko pojedynczą nazwę DNS).</span><span class="sxs-lookup"><span data-stu-id="ac926-493">Then the application uses the *nx_secure_tls_session_sni_extension_parse* API to parse the extension data provided to the callback to find the SNI extension and return the supplied DNS name (note that the extension only supports a single DNS name).</span></span> <span data-ttu-id="ac926-494">Po uzyskaniu nazwy aplikacja używa jej do znajdowania i wysyłania odpowiedniego certyfikatu tożsamości serwera (i łańcucha wystawcy, jeśli ma zastosowanie).</span><span class="sxs-lookup"><span data-stu-id="ac926-494">Once the name is obtained, the application uses it to find and send the appropriate server identity certificate (and issuer chain if applicable).</span></span>

### <a name="signature-algorithms-extension"></a><span data-ttu-id="ac926-495">Rozszerzenie algorytmów sygnatur</span><span class="sxs-lookup"><span data-stu-id="ac926-495">Signature Algorithms Extension</span></span>

<span data-ttu-id="ac926-496">To rozszerzenie jest specyficzne dla protokołu TLS 1,2 i umożliwia klientowi protokołu TLS udostępnienie listy akceptowalnych par algorytmów sygnatur i wyznaczania wartości skrótu, które są akceptowane do użycia podczas generowania i weryfikowania podpisów cyfrowych.</span><span class="sxs-lookup"><span data-stu-id="ac926-496">This extension is specific to TLS 1.2 and allows a TLS Client to provide a list of acceptable signature and hash algorithm pairs that are acceptable for use in generating and verifying digital signatures.</span></span> <span data-ttu-id="ac926-497">Lista jest generowana automatycznie przez NetX bezpiecznego protokołu TLS dla klientów TLS przy użyciu tabeli szyfru dostarczonej do *nx_secure_tls_session_create*.</span><span class="sxs-lookup"><span data-stu-id="ac926-497">The list is generated automatically by NetX Secure TLS for TLS Clients using the cipher table supplied to *nx_secure_tls_session_create*.</span></span> <span data-ttu-id="ac926-498">Interakcja aplikacji nie jest wymagana.</span><span class="sxs-lookup"><span data-stu-id="ac926-498">No application interaction is required.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="ac926-499">Metody uwierzytelniania</span><span class="sxs-lookup"><span data-stu-id="ac926-499">Authentication Methods</span></span>

<span data-ttu-id="ac926-500">Protokół TLS oferuje strukturę służącą do ustanawiania bezpiecznego połączenia między dwoma urządzeniami za pośrednictwem niezabezpieczonej sieci, ale część problemu ma na celu zapoznania się z tożsamością urządzenia na drugim końcu tego połączenia.</span><span class="sxs-lookup"><span data-stu-id="ac926-500">TLS provides the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="ac926-501">Bez mechanizmu uwierzytelniania tożsamości hostów zdalnych, jest to prosta operacja dla osoby atakującej, która będzie stanowić zaufane urządzenie.</span><span class="sxs-lookup"><span data-stu-id="ac926-501">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="ac926-502">Początkowo może się wydawać, że korzystanie z adresów IP, sprzętowych adresów MAC lub systemu DNS zapewni stosunkowo wysoki poziom zaufania do identyfikowania hostów w sieci, ale z uwzględnieniem rodzaju technologii TCP/IP i prostoty, z jakimi adresami mogą być sfałszowane i wpisy DNS są uszkodzone (np</span><span class="sxs-lookup"><span data-stu-id="ac926-502">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="ac926-503">Istnieją różne mechanizmy, które mogą zapewnić tę dodatkową warstwę uwierzytelniania dla protokołu TLS, ale najbardziej typowym *certyfikatem cyfrowym.*</span><span class="sxs-lookup"><span data-stu-id="ac926-503">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="ac926-504">Inne mechanizmy obejmują klucze wstępne (PSK) i schematy haseł.</span><span class="sxs-lookup"><span data-stu-id="ac926-504">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="ac926-505">Digital instalowane</span><span class="sxs-lookup"><span data-stu-id="ac926-505">Digital Cerificates</span></span>

<span data-ttu-id="ac926-506">Certyfikaty cyfrowe są najczęściej spotykaną metodą uwierzytelniania hosta zdalnego w protokole TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-506">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="ac926-507">Zasadniczo certyfikat cyfrowy to dokument z określonym formatowaniem, który zawiera informacje o tożsamości dla urządzenia w sieci komputerowej.</span><span class="sxs-lookup"><span data-stu-id="ac926-507">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="ac926-508">Protokół TLS zwykle korzysta z formatu o nazwie X. 509, który jest standardem opracowanym przez międzynarodowy związek telekomunikacyjny, ale inne formaty certyfikatów mogą być używane, Jeśli hosty TLS mogą wyrazić zgodę na używany format.</span><span class="sxs-lookup"><span data-stu-id="ac926-508">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="ac926-509">X. 509 definiuje określony format certyfikatów i różnych kodowań, których można użyć do utworzenia dokumentu cyfrowego.</span><span class="sxs-lookup"><span data-stu-id="ac926-509">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="ac926-510">Większość certyfikatów X. 509 używanych z protokołem TLS jest zakodowana przy użyciu wariantu numeru ASN 1, innego standardu telekomunikacyjnego.</span><span class="sxs-lookup"><span data-stu-id="ac926-510">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="ac926-511">W ASN. 1 istnieje różne kodowanie cyfrowe, ale najpopularniejsze kodowanie certyfikatów TLS jest standardem Distinguished Encoding Rules (DER).</span><span class="sxs-lookup"><span data-stu-id="ac926-511">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="ac926-512">DER to uproszczony podzbiór podstawowych reguł kodowania ASN. 1, które zostały zaprojektowane jako niejednoznaczne, co ułatwia analizowanie.</span><span class="sxs-lookup"><span data-stu-id="ac926-512">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="ac926-513">W sieci, certyfikaty TLS są zwykle zakodowane w formacie binarnym DER i jest to format, który NetX bezpiecznego dla certyfikatów X. 509.</span><span class="sxs-lookup"><span data-stu-id="ac926-513">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="ac926-514">Certyfikaty binarne w formacie DER są używane w rzeczywistym protokole TLS, ale mogą być generowane i przechowywane w wielu różnych kodowaniach, z rozszerzeniami plików, takimi jak PEM, CRT i. p12.</span><span class="sxs-lookup"><span data-stu-id="ac926-514">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="ac926-515">Różne warianty są używane przez różne aplikacje od różnych producentów, ale ogólnie wszystkie mogą być konwertowane na algorytm DER przy użyciu szeroko dostępnych narzędzi.</span><span class="sxs-lookup"><span data-stu-id="ac926-515">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="ac926-516">Najbardziej typowymi alternatywami kodowania certyfikatów jest PEM.</span><span class="sxs-lookup"><span data-stu-id="ac926-516">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="ac926-517">Format PEM (z Privacy-Enhanced mail) jest zakodowaną w oparciu o wersję 64 kodowaniem algorytmu DER, która jest często używana, ponieważ kodowanie skutkuje tekstem drukowalnym, który można łatwo wysyłać przy użyciu poczty e-mail lub protokołów opartych na sieci Web.</span><span class="sxs-lookup"><span data-stu-id="ac926-517">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="ac926-518">Generowanie certyfikatu dla bezpiecznej aplikacji NetX jest zwykle poza zakresem tego podręcznika, ale narzędzie wiersza polecenia OpenSSL ([www.OpenSSL.org](http://www.openssl.org)) jest szeroko dostępne i może być konwertowane między większością formatów.</span><span class="sxs-lookup"><span data-stu-id="ac926-518">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="ac926-519">W zależności od aplikacji można generować własne certyfikaty, otrzymywać certyfikaty od producenta lub organizacji rządowej lub zakupić certyfikaty od komercyjnego urzędu certyfikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-519">Depending on your application, you may generate your own certificates, be provided certificates by a  manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="ac926-520">Aby użyć certyfikatu cyfrowego w bezpiecznej aplikacji NetX, musisz najpierw przekonwertować certyfikat na format binarny DER, a opcjonalnie przekonwertować skojarzony klucz prywatny ("wykładnik prywatny" dla RSA, na przykład) na format binarny, zazwyczaj w formacie PKCS # 1 — sformatowany klucz RSA lub klucz ECC szyfrowany algorytmem DER.</span><span class="sxs-lookup"><span data-stu-id="ac926-520">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the "private exponent" for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key or a DER-encoded ECC key.</span></span> <span data-ttu-id="ac926-521">Po zakończeniu konwersji załadujesz certyfikat i klucz prywatny na urządzeniu.</span><span class="sxs-lookup"><span data-stu-id="ac926-521">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="ac926-522">Możliwe opcje obejmują używanie systemu plików opartego na technologii Flash lub generowanie macierzy C na podstawie danych (za pomocą narzędzia takiego jak "XXD" w systemie Linux) i kompilowanie certyfikatu i klucza w aplikacji jako danych stałych.</span><span class="sxs-lookup"><span data-stu-id="ac926-522">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as "xxd" from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="ac926-523">Po załadowaniu certyfikatu na urządzenie można użyć interfejsu API protokołu TLS do skojarzenia certyfikatu z sesją TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-523">Once your certificate is loaded onto the device, the TLS API can be used to associate your certificate with a TLS session.</span></span>

<span data-ttu-id="ac926-524">Aby uzyskać szczegółowe informacje i przykłady użycia certyfikatów X. 509 z protokołem Secure TLS NetX, zobacz sekcję "Importowanie certyfikatów X. 509 do usługi NetX Secure".</span><span class="sxs-lookup"><span data-stu-id="ac926-524">For details and examples on how to use X.509 certificates with NetX Secure TLS, see the section "Importing X.509 certificates into NetX Secure".</span></span>

<span data-ttu-id="ac926-525">Aby uzyskać więcej informacji, zapoznaj się z następującymi usługami TLS w dokumentacji interfejsu API:</span><span class="sxs-lookup"><span data-stu-id="ac926-525">Refer to the following TLS services in the API reference for more information:</span></span>

- <span data-ttu-id="ac926-526">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="ac926-526">nx_secure_x509_certificate_initialize</span></span>
- <span data-ttu-id="ac926-527">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="ac926-527">nx_secure_tls_local_certificate_add</span></span>
- <span data-ttu-id="ac926-528">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="ac926-528">nx_secure_tls_local_certificate_remove</span></span>
- <span data-ttu-id="ac926-529">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="ac926-529">nx_secure_tls_remote_certificate_allocate</span></span>
- <span data-ttu-id="ac926-530">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="ac926-530">nx_secure_tls_trusted_certificate_add</span></span>
- <span data-ttu-id="ac926-531">nx_secure_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="ac926-531">nx_secure_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="ac926-532">Specyficzne dla certyfikatu klienta TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-532">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="ac926-533">Implementacje klientów TLS zwykle nie wymagają od "lokalnego" certyfikatu<sup>14</sup> do załadowania na urządzenie.</span><span class="sxs-lookup"><span data-stu-id="ac926-533">TLS Client implementations generally do not require a "local" certificate<sup>14</sup> to be loaded onto the device.</span></span> <span data-ttu-id="ac926-534">Wyjątkiem jest to, kiedy uwierzytelnianie certyfikatu klienta jest włączone, ale jest to znacznie mniej typowe.</span><span class="sxs-lookup"><span data-stu-id="ac926-534">The exception to this is when Client Certificate Authentication is enabled, but this is far less common.</span></span>

<span data-ttu-id="ac926-535">Klient TLS wymaga załadowania co najmniej jednego "zaufanego" certyfikatu<sup>15</sup> (w razie potrzeby może być załadowany) i miejsca na "zdalny" certyfikat<sup>16</sup> do przydzielenia.</span><span class="sxs-lookup"><span data-stu-id="ac926-535">A TLS Client requires at least one "trusted" certificate<sup>15</sup> to be loaded (more may be loaded if required), and space for a "remote" certificate<sup>16</sup> to be allocated.</span></span>

<span data-ttu-id="ac926-536">Aby uzyskać więcej informacji na temat dodawania zaufanych certyfikatów i przydzielania miejsca dla certyfikatów zdalnych, zobacz Dokumentacja interfejsu API protokołu TLS dla następujących usług: nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add.</span><span class="sxs-lookup"><span data-stu-id="ac926-536">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add.</span></span>

14. <span data-ttu-id="ac926-537">"Lokalny" certyfikat jest certyfikatem, który identyfikuje urządzenie lokalne — czyli zawiera informacje o tożsamości dla urządzenia, na którym załadowana jest aplikacja TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-537">A “local” certificate is a certificate that identifies the local device – that is, it provides identity information for the device upon which the TLS application is loaded.</span></span>

15. <span data-ttu-id="ac926-538">"Zaufany" certyfikat to certyfikat, który stanowi podstawę do zaufania i uwierzytelniania urządzenia zdalnego, bezpośrednio lub za pomocą infrastruktury kluczy publicznych (PKI).</span><span class="sxs-lookup"><span data-stu-id="ac926-538">A “trusted” certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="ac926-539">Katalog główny łańcucha zaufania jest zwykle nazywany "urzędem certyfikacji" lub certyfikatem urzędu certyfikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-539">The root of the chain of trust is usually called a “Certification Authority” or CA certificate.</span></span>

16. <span data-ttu-id="ac926-540">Certyfikat "zdalny" odnosi się do certyfikatu wysyłanego przez hosta zdalnego podczas uzgadniania TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-540">A “remote” certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="ac926-541">Zapewnia tożsamość dla tego hosta zdalnego i jest uwierzytelniany przez porównanie go z certyfikatem "zaufany" na urządzeniu lokalnym.</span><span class="sxs-lookup"><span data-stu-id="ac926-541">It provides identity for that remote host and is authenticated by comparing it to a “trusted” certificate on the local device.</span></span>

### <a name="tls-server-certificate-specifics"></a><span data-ttu-id="ac926-542">Specyficzne dla certyfikatu serwera TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-542">TLS Server Certificate Specifics</span></span>

<span data-ttu-id="ac926-543">Implementacje serwera TLS zwykle nie wymagają od "zaufanych" certyfikatów do załadowania na urządzenie lub certyfikaty zdalne do przydzielenia.</span><span class="sxs-lookup"><span data-stu-id="ac926-543">TLS Server implementations generally do not require "trusted" certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="ac926-544">Wyjątkiem od tego, kiedy jest włączone uwierzytelnianie certyfikatu klienta (jest to mniej typowe).</span><span class="sxs-lookup"><span data-stu-id="ac926-544">The exception to this being when Client Certificate Authentication is enabled (this is less common).</span></span>

<span data-ttu-id="ac926-545">Serwer TLS wymaga załadowania certyfikatu "Local", aby serwer mógł udostępnić go klientowi zdalnemu podczas uzgadniania protokołu TLS w celu uwierzytelnienia serwera na komputerze klienckim.</span><span class="sxs-lookup"><span data-stu-id="ac926-545">A TLS Server requires a "local" certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="ac926-546">Aby uzyskać więcej informacji na temat ładowania certyfikatów lokalnych do użycia z aplikacjami serwera NetX TLS, zobacz Dokumentacja interfejsu API dla następujących usług:</span><span class="sxs-lookup"><span data-stu-id="ac926-546">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services:</span></span> 
- <span data-ttu-id="ac926-547">nx_secure_tls_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="ac926-547">nx_secure_tls_local_certificate_add,</span></span> 
- <span data-ttu-id="ac926-548">nx_secure_tls_local_certificate_remove.</span><span class="sxs-lookup"><span data-stu-id="ac926-548">nx_secure_tls_local_certificate_remove.</span></span>

### <a name="pre-shared-keys-psk"></a><span data-ttu-id="ac926-549">Klucze wstępne (PSK)</span><span class="sxs-lookup"><span data-stu-id="ac926-549">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="ac926-550">Alternatywny mechanizm zapewnienia uwierzytelniania tożsamości w protokole TLS jest pojęciem kluczy wstępnych (PSK).</span><span class="sxs-lookup"><span data-stu-id="ac926-550">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="ac926-551">Użycie ciphersuite PSK eliminuje konieczność wykonywania operacji szyfrowania klucza publicznego intensywnie korzystających z procesora, Boon dla urządzeń osadzonych z ograniczeniami zasobów.</span><span class="sxs-lookup"><span data-stu-id="ac926-551">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="ac926-552">Klucz PSK zastępuje certyfikat w uzgadnianiu protokołu TLS i jest używany zamiast szyfrowanego wstępnego tajnego wpisu do generowania klucza sesji TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-552">The PSK replaces the certificate in the TLS handshake and is used in place of the encrypted Pre-Master Secret for TLS session key generation.</span></span>

<span data-ttu-id="ac926-553">Ciphersuites klucza PSK są ograniczone w tym sensie, że wspólny klucz tajny musi być obecny na obu urządzeniach przed ustanowieniem sesji TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-553">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS session can be established.</span></span> <span data-ttu-id="ac926-554">Oznacza to, że urządzenia muszą zostać załadowane za pomocą tego klucza tajnego, przy użyciu niebezpiecznych środków innych niż połączenie protokołu TLS z certyfikatem PSK — PSKs może zostać zaktualizowany za pośrednictwem połączenia z kluczem PSK protokołu TLS, ale urządzenie musi być uruchamiane z kluczem PSK, który jest ładowany przez inny mechanizm.</span><span class="sxs-lookup"><span data-stu-id="ac926-554">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="ac926-555">Na przykład urządzenie czujnika i jego urządzenie bramy mogą zostać załadowane przy użyciu PSKs w fabryce przed wysyłką lub do załadowania klucza PSK przy użyciu standardowego połączenia TLS (z certyfikatem).</span><span class="sxs-lookup"><span data-stu-id="ac926-555">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="ac926-556">Ciphersuites PSK to kilka form, które opisano w dokumencie RFC 4279.</span><span class="sxs-lookup"><span data-stu-id="ac926-556">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="ac926-557">W pierwszej kolejności są używane klucze RSA lub Diffie-Hellman, które są używane w taki sam sposób, jak klucze publiczne przesyłane w certyfikacie w standardowym uzgadnianiu protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-557">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="ac926-558">Drugi formularz, który jest bardziej używany w środowisku z ograniczeniami zasobów, korzysta z klucza PSK, który jest używany do bezpośredniej generacji kluczy sesji (na przykład do użycia przez algorytm AES), unikając korzystania z kosztownych operacji RSA lub Diffie-Hellman.</span><span class="sxs-lookup"><span data-stu-id="ac926-558">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="ac926-559">NetX Secure obsługuje drugą formę klucza PSK ciphersuites, umożliwiając aplikacjom usuwanie wszystkich kodów kryptograficznych i użycie pamięci klucza publicznego.</span><span class="sxs-lookup"><span data-stu-id="ac926-559">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="ac926-560">Sam klucz PSK nie jest kluczem AES, ale może być traktowany jak hasło, z którego są generowane rzeczywiste klucze.</span><span class="sxs-lookup"><span data-stu-id="ac926-560">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="ac926-561">Istnieje kilka ograniczeń dotyczących tego, co może być wartością klucza PSK, ale dłuższe wartości zapewniają większe bezpieczeństwo (takie same jak w przypadku haseł).</span><span class="sxs-lookup"><span data-stu-id="ac926-561">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="ac926-562">Aby korzystać z klucza PSK w bezpiecznej aplikacji NetX, należy najpierw zdefiniować globalne makro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span><span class="sxs-lookup"><span data-stu-id="ac926-562">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="ac926-563">Zwykle odbywa się to za pomocą ustawień kompilatora, ale definicja może być również umieszczona w pliku nagłówkowym nx_secure_tls. h.</span><span class="sxs-lookup"><span data-stu-id="ac926-563">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="ac926-564">Po zdefiniowaniu makra obsługa klucza PSK ciphersuite zostanie skompilowana do aplikacji NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-564">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure TLS application.</span></span>

<span data-ttu-id="ac926-565">W przypadku włączenia obsługi PSK, można użyć interfejsu API TLS do skonfigurowania PSKs dla aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-565">With PSK support enabled, you can then use the TLS API to set up PSKs for your application.</span></span> <span data-ttu-id="ac926-566">Każdy PSK będzie wymagał wartości PSK (rzeczywisty klucz tajny) — Zapewnij bezpieczną wartość), wartość "Identity" służącą do identyfikowania określonego klucza PSK oraz "wskazówkę tożsamości", która jest używana przez serwer TLS do wybierania określonej wartości klucza PSK.</span><span class="sxs-lookup"><span data-stu-id="ac926-566">Each PSK will require a PSK value (the actual secret "key" – keep this value safe), an "identity" value used to identify the specific PSK, and an "identity hint" that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="ac926-567">Sam PSK może być dowolną wartością binarną, ponieważ nigdy nie jest wysyłana za pośrednictwem połączenia sieciowego.</span><span class="sxs-lookup"><span data-stu-id="ac926-567">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="ac926-568">Wartość PSK może być dowolną wartością o długości do 64 bajtów.</span><span class="sxs-lookup"><span data-stu-id="ac926-568">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="ac926-569">Tożsamość i Wskazówka muszą być drukowalne ciągi znaków sformatowane przy użyciu kodowania UTF-8.</span><span class="sxs-lookup"><span data-stu-id="ac926-569">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="ac926-570">Wartości Identity i Hint mogą mieć długość do 128 bajtów.</span><span class="sxs-lookup"><span data-stu-id="ac926-570">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="ac926-571">Tożsamość i PSK tworzą unikatową parę, która jest ładowana na każde urządzenie w sieci, które musi komunikować się ze sobą.</span><span class="sxs-lookup"><span data-stu-id="ac926-571">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="ac926-572">"Wskazówka" jest używana głównie do definiowania profilów aplikacji w celu grupowania PSKs przez funkcję lub usługę.</span><span class="sxs-lookup"><span data-stu-id="ac926-572">The "hint" is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="ac926-573">Te wartości muszą być uzgadniane z wyprzedzeniem i są zależne od aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-573">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="ac926-574">Przykładowo aplikacja serwera wiersza polecenia OpenSSL (z włączonym PSK) używa domyślnego ciągu "Client_identity", który musi być dostarczony przez klienta TLS w celu kontynuowania uzgadniania TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-574">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string "Client_identity", which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="ac926-575">Aby uzyskać więcej informacji na temat PSKs, zobacz Dokumentacja bezpiecznego interfejsu API NetX dla następujących usług: nx_secure_tls_client_psk_set, nx_secure_tls_psk_add.</span><span class="sxs-lookup"><span data-stu-id="ac926-575">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_tls_client_psk_set, nx_secure_tls_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="ac926-576">Importowanie certyfikatów X. 509 do NetX Secure</span><span class="sxs-lookup"><span data-stu-id="ac926-576">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="ac926-577">Certyfikaty cyfrowe są wymagane dla większości połączeń TLS w Internecie.</span><span class="sxs-lookup"><span data-stu-id="ac926-577">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="ac926-578">Certyfikaty zapewniają metodę uwierzytelniania wcześniej nieznanych hostów za pośrednictwem Internetu przy użyciu zaufanych wystawców, *zwykle nazywanych urzędami certyfikacji lub* urzędami certyfikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-578">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="ac926-579">Aby połączyć NetX bezpieczne urządzenie z usługą w chmurze komercyjnej (taką jak Amazon Web Services), należy zaimportować certyfikaty do aplikacji, ładując je na urządzenie.</span><span class="sxs-lookup"><span data-stu-id="ac926-579">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="ac926-580">Wraz z certyfikatami czasami potrzebny jest również *klucz prywatny* skojarzony z certyfikatem.</span><span class="sxs-lookup"><span data-stu-id="ac926-580">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="ac926-581">W niektórych aplikacjach (takich jak klient protokołu TLS, gdy uwierzytelnianie certyfikatu klienta nie jest używane) certyfikat będzie wystarczający, ale jeśli certyfikat jest używany do identyfikowania urządzenia, potrzebny będzie klucz prywatny.</span><span class="sxs-lookup"><span data-stu-id="ac926-581">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="ac926-582">Klucze prywatne są zwykle generowane podczas tworzenia certyfikatu i są przechowywane w osobnym pliku, często szyfrowane przy użyciu hasła.</span><span class="sxs-lookup"><span data-stu-id="ac926-582">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

### <a name="certificate-types"></a><span data-ttu-id="ac926-583">Typy certyfikatów</span><span class="sxs-lookup"><span data-stu-id="ac926-583">Certificate Types</span></span>

<span data-ttu-id="ac926-584">Certyfikaty cyfrowe są zwykle używane do identyfikowania jednostek w sieci, ale w zależności od tego, jak ich aplikacja będzie miała nieco inne właściwości.</span><span class="sxs-lookup"><span data-stu-id="ac926-584">Digital certificates are generally used to identify entities on a network, but depending on what their application they will have slightly different properties.</span></span>

### <a name="local-certificates"></a><span data-ttu-id="ac926-585">Certyfikaty lokalne</span><span class="sxs-lookup"><span data-stu-id="ac926-585">Local Certificates</span></span>

<span data-ttu-id="ac926-586">Na potrzeby tej dokumentacji będziemy odwoływać się do "certyfikatów lokalnych" jako tych certyfikatów, które zapewniają tożsamość dla urządzenia lokalnego (może to być "certyfikat urządzenia").</span><span class="sxs-lookup"><span data-stu-id="ac926-586">For the purposes of this documentation, we will refer to "local certificates" as those certificates which provide an identity for our local device (another possible name could be "device certificate").</span></span> <span data-ttu-id="ac926-587">Te certyfikaty będą udostępniane hostowi zdalnemu, gdy host zdalny żąda uwierzytelnienia urządzenia lokalnego.</span><span class="sxs-lookup"><span data-stu-id="ac926-587">These certificates will be provided to a remote host when the remote host desires to authenticate the local device.</span></span>

### <a name="remote-certificates"></a><span data-ttu-id="ac926-588">Certyfikaty zdalne</span><span class="sxs-lookup"><span data-stu-id="ac926-588">Remote Certificates</span></span>

<span data-ttu-id="ac926-589">W tej dokumentacji "certyfikaty zdalne" odwołują się do tych certyfikatów dostarczonych przez hosta zdalnego w trakcie uzgadniania TLS, gdy ma to zastosowanie.</span><span class="sxs-lookup"><span data-stu-id="ac926-589">In this documentation, "remote certificates" refers to those certificates provided by a remote host during the TLS handshake when applicable.</span></span> <span data-ttu-id="ac926-590">Miejsce dla tych certyfikatów musi być przydzielone lub NetX Secure nie będzie mogła przeanalizować ich ani ukończyć uzgadniania protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-590">Space for these certificates must be allocated or NetX Secure will not be able to parse them and complete the TLS handshake.</span></span>

### <a name="signing-certificates"></a><span data-ttu-id="ac926-591">Certyfikaty podpisywania</span><span class="sxs-lookup"><span data-stu-id="ac926-591">Signing Certificates</span></span>

<span data-ttu-id="ac926-592">"Certyfikat podpisywania" służy do cyfrowego podpisywania innych certyfikatów lub danych na potrzeby uwierzytelniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-592">A "signing certificate" is used to digitally sign other certificates or data for the purpose of authentication.</span></span> <span data-ttu-id="ac926-593">Te certyfikaty mogą być certyfikatami pośrednimi lub głównymi w infrastrukturze kluczy publicznych (PKI) i zwykle nie są używane do identyfikowania poszczególnych urządzeń lub hostów.</span><span class="sxs-lookup"><span data-stu-id="ac926-593">These certificates may be either intermediate or root certificates within a Public Key Infrastructure (PKI) and are generally not used to identify individual devices or hosts.</span></span>

### <a name="root-ca-certificates"></a><span data-ttu-id="ac926-594">Certyfikaty głównego urzędu certyfikacji</span><span class="sxs-lookup"><span data-stu-id="ac926-594">Root CA Certificates</span></span>

<span data-ttu-id="ac926-595">"Certyfikaty głównego urzędu certyfikacji" to certyfikaty podpisywania, które stanowią podstawę infrastruktury PKI i są z podpisem własnym, a nie podpisywane przez inny certyfikat podpisywania.</span><span class="sxs-lookup"><span data-stu-id="ac926-595">"Root CA certificates" are signing certificates that provide the basis of a PKI and are self-signed, rather than being signed by another signing certificate.</span></span> <span data-ttu-id="ac926-596">Co najmniej jeden certyfikat głównego urzędu certyfikacji jest zwykle wymagany dla klienta protokołu TLS do weryfikowania serwerów zdalnych.</span><span class="sxs-lookup"><span data-stu-id="ac926-596">At least one Root CA certificate is typically required for a TLS Client to verify remote servers.</span></span>

### <a name="certificate-formats"></a><span data-ttu-id="ac926-597">Formaty certyfikatów</span><span class="sxs-lookup"><span data-stu-id="ac926-597">Certificate formats</span></span>

<span data-ttu-id="ac926-598">Certyfikaty cyfrowe są po prostu plikami zawierającymi dane strukturalne kodowane przy użyciu składni ASN. 1.</span><span class="sxs-lookup"><span data-stu-id="ac926-598">Digital certificates are simply files containing structured data encoded using the ASN.1 syntax.</span></span> <span data-ttu-id="ac926-599">Istnieją jednak różne formaty, w których mogą być przechowywane certyfikaty i ważne jest, aby przed załadowaniem certyfikatu do NetX bezpiecznej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-599">However, there are various formats in which certificates may be stored and it is important to have the right format before loading a certificate into a NetX Secure application.</span></span>

<span data-ttu-id="ac926-600">Najpopularniejsze formaty dla certyfikatów to DER i PEM.</span><span class="sxs-lookup"><span data-stu-id="ac926-600">The most common formats for certificates are DER and PEM.</span></span> <span data-ttu-id="ac926-601">Algorytm DER (na *Distinguished Encoding Rules* format ASN. 1) jest formatem binarnym używanym przez protokół TLS podczas wykonywania wstępnego uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-601">DER (for *Distinguished Encoding Rules*, an ASN.1 format) is the binary format used by TLS when performing the initial handshake.</span></span> <span data-ttu-id="ac926-602">PEM (from *privacy Enhanced mail*) to podstawowa 64 wersja formatu der, która jest odpowiednia do obsługi poczty e-mail lub wysyłania za pośrednictwem protokołu HTTP w sieci Web.</span><span class="sxs-lookup"><span data-stu-id="ac926-602">PEM (from *Privacy Enhanced Mail*) is a base-64 encoded version of the DER format which is suitable for emailing or sending over HTTP on the web.</span></span> <span data-ttu-id="ac926-603">Różni dostawcy używają różnych rozszerzeń nazw plików dla certyfikatów, takich jak "PEM" lub ". CRT" dla certyfikatów PEM i "der" dla certyfikatów DER.</span><span class="sxs-lookup"><span data-stu-id="ac926-603">Different vendors use different filename extensions for certificates, such as ".pem" or ".crt" for PEM certificates, and ".der" for DER certificates.</span></span> <span data-ttu-id="ac926-604">Jeśli masz certyfikat i nie wyczyścisz używanego formatu, otwarcie pliku w edytorze tekstów umożliwi określenie typu, ponieważ pliki DER są zakodowane jako binarne, a pliki PEM są zwykłym tekstem ASCII, który zaczyna się od nagłówka "-----BEGIN CERTIFICATE-----".</span><span class="sxs-lookup"><span data-stu-id="ac926-604">If you have a certificate and it is not clear what format is used, opening the file in a text editor will allow you to determine the type since DER files are encoded  binary, and PEM files are regular ASCII text that start with the header "-----BEGIN CERTIFICATE-----".</span></span>

<span data-ttu-id="ac926-605">NetX Secure wymaga, aby certyfikat był w formacie binarnym DER, dlatego przed zaimportowaniem należy przekonwertować certyfikat na format DER.</span><span class="sxs-lookup"><span data-stu-id="ac926-605">NetX Secure requires that your certificate be in binary DER format, so you will need to convert your certificate into DER format before importing.</span></span> <span data-ttu-id="ac926-606">Można to zrobić za pomocą łatwo dostępnych narzędzi, takich jak OpenSSL.</span><span class="sxs-lookup"><span data-stu-id="ac926-606">This can be done with readily available tools such as OpenSSL.</span></span>

<span data-ttu-id="ac926-607">Jeśli potrzebujesz klucza prywatnego dla aplikacji, plik klucza zostanie zakodowany przy użyciu PEM lub DER w określonym formacie (PKCS # 1 dla RSA, RFC 5915 dla ECC).</span><span class="sxs-lookup"><span data-stu-id="ac926-607">If you need a private key for your application, the key file will be encoded using PEM or DER in a specific format (PKCS#1 for RSA, RFC 5915 for ECC).</span></span> <span data-ttu-id="ac926-608">Plik klucza prywatnego należy przekonwertować na algorytm DER przed zaimportowaniem.</span><span class="sxs-lookup"><span data-stu-id="ac926-608">The private key file will need to be converted into DER before being imported.</span></span>

<span data-ttu-id="ac926-609">Następujące polecenia OpenSSL są podawane jako przykład do konwertowania certyfikatów i plików kluczy RSA do formatu DER wymagane przez NetX Secure (ECC jest podobne — zapoznaj się z dokumentacją OpenSSL).</span><span class="sxs-lookup"><span data-stu-id="ac926-609">The following OpenSSL commands are given as an example for converting certificates and RSA key files into the DER format required by NetX Secure (ECC is similar – refer to the OpenSSL documentation).</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
### <a name="private-keys-and-certificates"></a><span data-ttu-id="ac926-610">Klucze prywatne i certyfikaty</span><span class="sxs-lookup"><span data-stu-id="ac926-610">Private Keys and Certificates</span></span>

<span data-ttu-id="ac926-611">W przypadku certyfikatów, które identyfikują urządzenie, skojarzony klucz prywatny musi być załadowany wraz z certyfikatem.</span><span class="sxs-lookup"><span data-stu-id="ac926-611">For certificates that identify a device, the associated private key must be loaded along with the certificate.</span></span> <span data-ttu-id="ac926-612">Klucz prywatny (może dotyczyć jednego z algorytmów klucza publicznego, takiego jak RSA, Diffie-Hellmana lub kryptografii Elliptic-Curve) jest używany przez serwer TLS do odszyfrowywania przychodzącego materiału klucza ("wstępnego klucza tajnego") z klienta TLS, a tym samym uwierzytelniania samego klienta.</span><span class="sxs-lookup"><span data-stu-id="ac926-612">The private key (which may be for one of the public-key algorithms such as RSA, Diffie-Hellman, or Elliptic-Curve Cryptography) is used by a TLS server to decrypt the incoming key material (the "pre-master secret") from a TLS client, thereby authenticating itself to the client.</span></span> <span data-ttu-id="ac926-613">W przypadku klienta TLS jest dostarczany certyfikat tożsamości (certyfikat ze skojarzonym kluczem prywatnym), a serwer żąda certyfikatu klienta. klucz prywatny jest używany do uwierzytelniania klienta programu — w przypadku korzystania z klucza prywatnego klient szyfruje token przy użyciu klucz prywatny, który następnie jest odszyfrowywany przez serwer przy użyciu klucz publiczny klienta, który jest dostępny w certyfikacie klienta (w podobny sposób, ale szczegóły są inne).</span><span class="sxs-lookup"><span data-stu-id="ac926-613">For a TLS Client, if an identity certificate (a certificate with its associated private key) is provided and a server requests a client certificate, the private key is used to authenticate the client – in the case of RSA the client  encrypts a token using the private key which the server then decrypts using the client's public key, provided in the client certificate (Diffie-Hellman and ECC authentication happens in a similar fashion but the details are a bit different).</span></span>

<span data-ttu-id="ac926-614">W NetX Secure usługa *nx_secure_x509_certificate_initialize* jest używana do inicjowania certyfikatu X. 509 (zobacz sekcję "Ładowanie certyfikatów na urządzenie", aby uzyskać więcej informacji), i opcjonalnie Skojarz klucz prywatny z tym certyfikatem.</span><span class="sxs-lookup"><span data-stu-id="ac926-614">In NetX secure, the service *nx_secure_x509_certificate_initialize* is used to initialize an X.509 certificate (see section "Loading certificates onto your device" for more information) and optionally associate a private key with that certificate.</span></span>

<span data-ttu-id="ac926-615">W przypadku podania klucza prywatnego certyfikat jest oznaczany jako certyfikat "tożsamość" używany do identyfikowania urządzenia.</span><span class="sxs-lookup"><span data-stu-id="ac926-615">If a private key is supplied, the certificate is marked as being the "identity" certificate used to identify the device.</span></span> <span data-ttu-id="ac926-616">Klucz jest przesyłany jako ciągły binarny obiekt BLOB i Długość z typem skojarzonego klucza.</span><span class="sxs-lookup"><span data-stu-id="ac926-616">The key is passed as a contiguous binary blob and a length, with an associated key type.</span></span> <span data-ttu-id="ac926-617">Typ klucza zależy od typu klucza (np. RSA, ECC itp.) i formatu (np. PKCS # 1 DER).</span><span class="sxs-lookup"><span data-stu-id="ac926-617">The key type depends on the type of key (e.g. RSA, ECC, etc.) and the format (e.g. PKCS#1 DER).</span></span> <span data-ttu-id="ac926-618">Jeśli nie podano klucza, wartość NX_SECURE_X509_KEY_TYPE_NONE (wartość 0x0) może być przekazywana w celu wskazania, że żaden klucz nie jest dostarczany (długość 0 i wskaźnik NX_NULL dla parametru danych osiągnie ten sam efekt).</span><span class="sxs-lookup"><span data-stu-id="ac926-618">If no key is supplied, the value NX_SECURE_X509_KEY_TYPE_NONE (value 0x0) can be passed to indicate no key is being supplied (a length of 0 and a NX_NULL pointer for the data parameter will achieve the same effect).</span></span>

<span data-ttu-id="ac926-619">W poniższej tabeli przedstawiono typy kluczy znane NetX Secure i skojarzony identyfikator typu, który ma zostać przekazana do *nx_secure_x509_certificate_initialize*.</span><span class="sxs-lookup"><span data-stu-id="ac926-619">The following table shows the key types known to NetX Secure and the associated type identifier to be passed into *nx_secure_x509_certificate_initialize*.</span></span> <span data-ttu-id="ac926-620">Dodatkowe typy kluczy zostaną dodane, ponieważ dodatkowe algorytmy szyfrowania zostaną dodane do NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="ac926-620">Additional key types will be added as more encryption algorithms are added to NetX Secure.</span></span>

| <span data-ttu-id="ac926-621">Identyfikator</span><span class="sxs-lookup"><span data-stu-id="ac926-621">Identifier</span></span>                              | <span data-ttu-id="ac926-622">Algorytm</span><span class="sxs-lookup"><span data-stu-id="ac926-622">Algorithm</span></span> | <span data-ttu-id="ac926-623">Format</span><span class="sxs-lookup"><span data-stu-id="ac926-623">Format</span></span>   | <span data-ttu-id="ac926-624">Encoding</span><span class="sxs-lookup"><span data-stu-id="ac926-624">Encoding</span></span> | <span data-ttu-id="ac926-625">Wartość</span><span class="sxs-lookup"><span data-stu-id="ac926-625">Value</span></span> |
| --------------------------------------- | --------- | -------- | -------- | ----- |
| <span data-ttu-id="ac926-626">NX_SECURE_X509_KEY_TYPE_NONE</span><span class="sxs-lookup"><span data-stu-id="ac926-626">NX_SECURE_X509_KEY_TYPE_NONE</span></span>            | <span data-ttu-id="ac926-627">Brak</span><span class="sxs-lookup"><span data-stu-id="ac926-627">None</span></span>      | <span data-ttu-id="ac926-628">NIE DOTYCZY</span><span class="sxs-lookup"><span data-stu-id="ac926-628">N/A</span></span>      | <span data-ttu-id="ac926-629">NIE DOTYCZY</span><span class="sxs-lookup"><span data-stu-id="ac926-629">N/A</span></span>      | <span data-ttu-id="ac926-630">0x0</span><span class="sxs-lookup"><span data-stu-id="ac926-630">0x0</span></span>   |
| <span data-ttu-id="ac926-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span><span class="sxs-lookup"><span data-stu-id="ac926-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span></span>   | <span data-ttu-id="ac926-632">RSA</span><span class="sxs-lookup"><span data-stu-id="ac926-632">RSA</span></span>       | <span data-ttu-id="ac926-633">PKCS # 1</span><span class="sxs-lookup"><span data-stu-id="ac926-633">PKCS#1</span></span>   | <span data-ttu-id="ac926-634">ALGORYTM</span><span class="sxs-lookup"><span data-stu-id="ac926-634">DER</span></span>      | <span data-ttu-id="ac926-635">0x1</span><span class="sxs-lookup"><span data-stu-id="ac926-635">0x1</span></span>   |
| <span data-ttu-id="ac926-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span><span class="sxs-lookup"><span data-stu-id="ac926-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span></span>          | <span data-ttu-id="ac926-637">ECDSA</span><span class="sxs-lookup"><span data-stu-id="ac926-637">ECDSA</span></span>     | <span data-ttu-id="ac926-638">RFC 5915</span><span class="sxs-lookup"><span data-stu-id="ac926-638">RFC 5915</span></span> | <span data-ttu-id="ac926-639">ALGORYTM</span><span class="sxs-lookup"><span data-stu-id="ac926-639">DER</span></span>      | <span data-ttu-id="ac926-640">0x2</span><span class="sxs-lookup"><span data-stu-id="ac926-640">0x2</span></span>   |

### <a name="user-defined-private-key-types"></a><span data-ttu-id="ac926-641">Typy kluczy prywatnych zdefiniowane przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="ac926-641">User-defined private key types</span></span>

<span data-ttu-id="ac926-642">Wartości identyfikatorów typu klucza dla usługi *nx_secure_x509_certificate_initialize* określają działania podejmowane w momencie dostarczania klucza prywatnego.</span><span class="sxs-lookup"><span data-stu-id="ac926-642">The values of the key type identifiers for the *nx_secure_x509_certificate_initialize* service govern the actions taken when the private key is supplied.</span></span> <span data-ttu-id="ac926-643">W przypadku znanych typów wartości znajdują się w zakresie 0x0000 0000 – 0x0000 FFFF (ostatnie 16 bitów z 32-bitową liczbą całkowitą bez znaku).</span><span class="sxs-lookup"><span data-stu-id="ac926-643">For known types, the values are in the range 0x0000 0000 – 0x0000 FFFF (bottom 16 bits of a 32-bit unsigned integer).</span></span> <span data-ttu-id="ac926-644">W przypadku platform z niestandardowymi typami kluczy<sup>17</sup> (jak w przypadku niektórych sprzętowych aparatów szyfrowania), typ klucza zdefiniowanego przez użytkownika w zakresie 0x0000 1000 — FFFF (z 16 bitami niezerowymi) może być przekazanie jako typ klucza.</span><span class="sxs-lookup"><span data-stu-id="ac926-644">For platforms with custom key types<sup>17</sup> (as is the case for some hardware-based encryption engines), a user-defined key type in the range 0x0000 1000-0xFFFF FFFF (top 16 bits non-zero) may be passed as the key type.</span></span> <span data-ttu-id="ac926-645">W przypadku ustawienia dowolnego z 16 najważniejszych bitów typu klucza dane klucza prywatnego są przekazywane bezpośrednio do odpowiedniej procedury kryptograficznej (np. RSA) podanej w tabeli ciphersuite TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-645">If any of the top 16 bits of the key type are set, then the private key data is passed directly to the appropriate cryptographic routine (e.g. RSA) supplied in the TLS ciphersuite table.</span></span> <span data-ttu-id="ac926-646">Typy kluczy zdefiniowane przez użytkownika nie są analizowane lub w inny sposób przetwarzane przed przekazaniem do procedury kryptograficznej.</span><span class="sxs-lookup"><span data-stu-id="ac926-646">User-defined key types are not parsed or otherwise processed before being passed to the cryptographic routine.</span></span> <span data-ttu-id="ac926-647">Ponadto typ klucza zdefiniowanego przez użytkownika również zostanie przesłany do procedury kryptograficznej, aby można było obsługiwać każde odpowiednie przetwarzanie na tym poziomie.</span><span class="sxs-lookup"><span data-stu-id="ac926-647">In addition, the user-defined key type will also be passed to the cryptographic routine so that any appropriate processing can be handled at that level.</span></span>

<span data-ttu-id="ac926-648">Należy pamiętać, że typy kluczy zdefiniowane przez użytkownika są zwykle używane dla konkretnych platform sprzętowych, które wykorzystują niestandardowe (prawdopodobnie zaszyfrowane) dane klucza.</span><span class="sxs-lookup"><span data-stu-id="ac926-648">Note that user-defined key types are generally used for specific hardware platforms that utilize custom (possibly encrypted) key data.</span></span> <span data-ttu-id="ac926-649">Zazwyczaj oznacza to, że dane klucza są generowane lub kodowane przy użyciu mechanizmu specyficznego dla tego dostawcy sprzętu (lub w przypadku standardu PKCS # 11, określonego standardu).</span><span class="sxs-lookup"><span data-stu-id="ac926-649">Generally this implies that the key data is generated or encoded using a mechanism specific to that hardware vendor (or in the case of a standard like PKCS#11, a specific standard).</span></span> <span data-ttu-id="ac926-650">Aby uzyskać więcej informacji, zapoznaj się z dokumentacją platformy sprzętowej.</span><span class="sxs-lookup"><span data-stu-id="ac926-650">Consult your hardware platform documentation for more information.</span></span>

17. <span data-ttu-id="ac926-651">Typy kluczy zdefiniowane przez użytkownika wymagają odpowiedniej niestandardowej procedury kryptograficznej do obsługi niestandardowego formatu klucza.</span><span class="sxs-lookup"><span data-stu-id="ac926-651">User-defined key types require a corresponding custom cryptographic routine to handle the custom key format.</span></span> <span data-ttu-id="ac926-652">Procedura kryptograficzna musi mieć zgodny algorytm (np. RSA) i być przekazywane do protokołu TLS w tabeli ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="ac926-652">The cryptographic routine must have a matching algorithm (e.g. RSA) and be passed into TLS in the ciphersuite table.</span></span> 

### <a name="loading-certificates-onto-your-device"></a><span data-ttu-id="ac926-653">Ładowanie certyfikatów na urządzenie</span><span class="sxs-lookup"><span data-stu-id="ac926-653">Loading certificates onto your device</span></span>

<span data-ttu-id="ac926-654">Każda metoda ładowania pliku na urządzenie będzie wystarczająca do zaimportowania certyfikatów.</span><span class="sxs-lookup"><span data-stu-id="ac926-654">Any method for loading a file onto your device will be sufficient to import your certificates.</span></span>

<span data-ttu-id="ac926-655">Najprostszą metodą ładowania certyfikatu jest konwertowanie binarnych danych szyfrowanych algorytmem DER na tablicę C i kompilowanie ich do aplikacji jako stałej.</span><span class="sxs-lookup"><span data-stu-id="ac926-655">The simplest method for loading a certificate is to convert the binary DER-encoded data into a C array and compile it into your application as a constant.</span></span> <span data-ttu-id="ac926-656">Można to łatwo zrobić z narzędziami takimi jak "XXD" w systemie Linux (z opcją "-i").</span><span class="sxs-lookup"><span data-stu-id="ac926-656">This can be easily done with tools such as "xxd" in Linux (with the "-i" option).</span></span>

<span data-ttu-id="ac926-657">Alternatywnie można załadować certyfikat do systemu plików Flash lub innych opcji magazynu, o ile można przekazać wskaźnik do danych certyfikatu do bezpiecznego interfejsu API NetX.</span><span class="sxs-lookup"><span data-stu-id="ac926-657">Alternatively, you can load your certificate into a flash filesystem or other storage options as long as you can pass a pointer to the certificate data into the NetX Secure API.</span></span>

### <a name="certificate-files-needed-for-netx-secure"></a><span data-ttu-id="ac926-658">Pliki certyfikatów, które są zbędne do NetX Secure</span><span class="sxs-lookup"><span data-stu-id="ac926-658">Certificate files needed for NetX Secure</span></span>

<span data-ttu-id="ac926-659">Pliki certyfikatów, które będą potrzebne do zaimportowania, zależą od aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-659">The certificate files you will need to import depends on your application.</span></span> <span data-ttu-id="ac926-660">Ogólnie rzecz biorąc, serwery TLS wymagają certyfikatu w celu zidentyfikowania urządzenia, a klienci TLS wymagają co najmniej jednego *zaufania zaufanego* do uwierzytelniania serwerów zdalnych.</span><span class="sxs-lookup"><span data-stu-id="ac926-660">In general, TLS Servers require a certificate to identify the device, and TLS Clients require one or more *Trusted Certificates* to authenticate remote servers.</span></span> <span data-ttu-id="ac926-661">W poniższej tabeli przedstawiono certyfikaty, które są zbędne dla niektórych różnych aplikacji TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-661">The following table illustrates certificates needed for some different TLS applications.</span></span>

| <span data-ttu-id="ac926-662">**Funkcje/opcje protokołu TLS**</span><span class="sxs-lookup"><span data-stu-id="ac926-662">**TLS functionality/options**</span></span>                     | <span data-ttu-id="ac926-663">**Wymagany certyfikat/klucze (minimum)**</span><span class="sxs-lookup"><span data-stu-id="ac926-663">**Certificates/keys needed (minimum)**</span></span>              |
| ------------------------------------------------- | --------------------------------------------------- |
| <span data-ttu-id="ac926-664">Klient TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-664">TLS Client</span></span>                                        | <span data-ttu-id="ac926-665">Certyfikat głównego urzędu certyfikacji</span><span class="sxs-lookup"><span data-stu-id="ac926-665">Root CA certificate</span></span>                                 |
| <span data-ttu-id="ac926-666">Serwer TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-666">TLS Server</span></span>                                        | <span data-ttu-id="ac926-667">Certyfikat lokalny, klucz prywatny dla tego certyfikatu</span><span class="sxs-lookup"><span data-stu-id="ac926-667">Local certificate, private key for that certificate</span></span> |
| <span data-ttu-id="ac926-668">Serwer TLS z uwierzytelnianiem certyfikatu klienta</span><span class="sxs-lookup"><span data-stu-id="ac926-668">TLS Server with Client Certificate Authentication</span></span> | <span data-ttu-id="ac926-669">Certyfikat lokalny, klucz prywatny, główny urząd certyfikacji</span><span class="sxs-lookup"><span data-stu-id="ac926-669">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="ac926-670">Klient TLS z uwierzytelnianiem za pomocą certyfikatu klienta</span><span class="sxs-lookup"><span data-stu-id="ac926-670">TLS Client with Client Certificate Authentication</span></span> | <span data-ttu-id="ac926-671">Certyfikat lokalny, klucz prywatny, główny urząd certyfikacji</span><span class="sxs-lookup"><span data-stu-id="ac926-671">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="ac926-672">Klient lub serwer TLS tylko z kluczami wstępnymi</span><span class="sxs-lookup"><span data-stu-id="ac926-672">TLS Client or Server with Pre-Shared Keys only</span></span>    | <span data-ttu-id="ac926-673">Brak (użycie PSK zamiast certyfikatów)</span><span class="sxs-lookup"><span data-stu-id="ac926-673">None (PSK used instead of certificates)</span></span>             |

<span data-ttu-id="ac926-674">Odpowiednie usługi do ładowania certyfikatów są następujące:</span><span class="sxs-lookup"><span data-stu-id="ac926-674">The relevant services for loading certificates are as follows:</span></span>

| <span data-ttu-id="ac926-675">**Nazwa interfejsu API**</span><span class="sxs-lookup"><span data-stu-id="ac926-675">**API Name**</span></span>                                   | <span data-ttu-id="ac926-676">**Cel**</span><span class="sxs-lookup"><span data-stu-id="ac926-676">**Purpose**</span></span>                                            |
| ---------------------------------------------- |------------------------------------------------------- |
| <span data-ttu-id="ac926-677">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="ac926-677">nx_secure_x509_certificate_initialize</span></span>      | <span data-ttu-id="ac926-678">Musi być wywołana dla wszystkich certyfikatów, aby wypełnić strukturę NX_SECURE_X509_CERT danymi certyfikatu i kluczem prywatnym.</span><span class="sxs-lookup"><span data-stu-id="ac926-678">Must be called for all certificates to populate the NX_SECURE_X509_CERT structure with your certificate data and private key.</span></span> |
| <span data-ttu-id="ac926-679">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="ac926-679">nx_secure_tls_local_certificate_add</span></span>       | <span data-ttu-id="ac926-680">Dodaj certyfikat lokalny do sesji TLS w celu zidentyfikowania urządzenia.</span><span class="sxs-lookup"><span data-stu-id="ac926-680">Add a local certificate to a TLS session to identify your device.</span></span>                                                                |
| <span data-ttu-id="ac926-681">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="ac926-681">nx_secure_tls_local_certificate_remove</span></span>    | <span data-ttu-id="ac926-682">Usuń certyfikat lokalny z sesji TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-682">Remove a local certificate from a TLS session.</span></span>                                                                                   |
| <span data-ttu-id="ac926-683">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="ac926-683">nx_secure_tls_remote_certificate_allocate</span></span> | <span data-ttu-id="ac926-684">Przydziel miejsce dla certyfikatu zdalnego (wywoływane z niezainicjowanym NX_SECURE_X509_CERT).</span><span class="sxs-lookup"><span data-stu-id="ac926-684">Allocate space for a remote certificate (called with an uninitialized NX_SECURE_X509_CERT).</span></span>                                   |
| <span data-ttu-id="ac926-685">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="ac926-685">nx_secure_tls_trusted_certificate_add</span></span>     | <span data-ttu-id="ac926-686">Dodaj certyfikat do sesji TLS jako zaufany certyfikat do uwierzytelniania hostów zdalnych.</span><span class="sxs-lookup"><span data-stu-id="ac926-686">Add a certificate to a TLS Session as a Trusted Certificate for authenticating remote hosts.</span></span>                                     |
| <span data-ttu-id="ac926-687">nx_secure_tls_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="ac926-687">nx_secure_tls_trusted_certificate_remove</span></span>  | <span data-ttu-id="ac926-688">Usuń zaufany certyfikat z sesji TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-688">Remove a trusted certificate from a TLS Session.</span></span>                                                                                 |

### <a name="working-with-aws-iot-certificates"></a><span data-ttu-id="ac926-689">Praca z certyfikatami IoT AWS</span><span class="sxs-lookup"><span data-stu-id="ac926-689">Working with AWS IoT Certificates</span></span>

<span data-ttu-id="ac926-690">W interfejsie Amazon Web Services IoT wybierz pozycję "zabezpieczenia" z menu paska bocznego i wybierz pozycję "certyfikaty".</span><span class="sxs-lookup"><span data-stu-id="ac926-690">In the Amazon Web Services IoT interface, select "Security" from the sidebar menu and select "Certificates".</span></span> <span data-ttu-id="ac926-691">Utwórz nowy certyfikat i postępuj zgodnie z instrukcjami, aby pobrać nowy certyfikat urządzenia.</span><span class="sxs-lookup"><span data-stu-id="ac926-691">Create a new certificate and follow the instructions to download your new device certificate.</span></span>

<span data-ttu-id="ac926-692">Po pobraniu certyfikatów konieczne będzie ich przekonwertowanie do formatu DER przy użyciu OpenSSL lub podobnego narzędzia.</span><span class="sxs-lookup"><span data-stu-id="ac926-692">Once you have downloaded your certificates, you will need to convert them into DER format using OpenSSL or a similar utility.</span></span>

<span data-ttu-id="ac926-693">Uwaga: AWS również udostępni plik klucza publicznego.</span><span class="sxs-lookup"><span data-stu-id="ac926-693">NOTE: AWS will also provide a public key file.</span></span> <span data-ttu-id="ac926-694">Klucz publiczny jest zawarty w certyfikacie urządzenia lokalnego, dlatego nie musi zostać zaimportowany do aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-694">The public key is contained within the local device certificate so it does not need to be imported into your application.</span></span>

<span data-ttu-id="ac926-695">Poniżej przedstawiono przykładowe polecenia służące do konwertowania certyfikatu urządzenia lokalnego i jego klucza prywatnego na format DER do użycia z NetX Secure:</span><span class="sxs-lookup"><span data-stu-id="ac926-695">As an example, here are the commands to convert the local device certificate and its private key into DER format for use with NetX Secure:</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
<span data-ttu-id="ac926-696">Skonwertowane pliki można zaimportować do aplikacji zgodnie z powyższymi instrukcjami.</span><span class="sxs-lookup"><span data-stu-id="ac926-696">The converted files can be imported into your application following the above instructions.</span></span>

## <a name="x509-certificate-validation-in-netx-secure"></a><span data-ttu-id="ac926-697">Walidacja certyfikatu X. 509 w usłudze NetX Secure</span><span class="sxs-lookup"><span data-stu-id="ac926-697">X.509 Certificate Validation in NetX Secure</span></span> 

<span data-ttu-id="ac926-698">W przypadku korzystania z protokołu TLS z certyfikatami X. 509 do identyfikacji i weryfikacji hosta ważne jest, aby zrozumieć, jak te certyfikaty są rzeczywiście weryfikowane.</span><span class="sxs-lookup"><span data-stu-id="ac926-698">When using TLS with X.509 certificates for host identification and verification, it is important to understand how those certificates are actually validated.</span></span> <span data-ttu-id="ac926-699">Chociaż Specyfikacja TLS nie zawiera szczegółowych instrukcji dotyczących weryfikacji certyfikatu, odnosi się do specyfikacji X. 509 (RFC 5280).</span><span class="sxs-lookup"><span data-stu-id="ac926-699">While the TLS specification does not provide detailed instructions on how to validate a certificate, it does refer to the X.509 specification (RFC 5280).</span></span> <span data-ttu-id="ac926-700">Ogólnie rzecz biorąc, oczekuje się, że protokół TLS będzie przeprowadzać co najmniej podstawowe sprawdzanie poprawności certyfikatów przychodzących (te certyfikaty dostarczone przez hosta zdalnego podczas uzgadniania protokołu TLS), a protokół Secure TLS NetX nie jest inny.</span><span class="sxs-lookup"><span data-stu-id="ac926-700">In general, it is expected that TLS will perform at least basic validation on incoming certificates (those certificates supplied by the remote host during the TLS handshake), and NetX Secure TLS is no different.</span></span>

### <a name="basic-x509-validation"></a><span data-ttu-id="ac926-701">Podstawowa Walidacja X. 509</span><span class="sxs-lookup"><span data-stu-id="ac926-701">Basic X.509 Validation</span></span>

<span data-ttu-id="ac926-702">W przypadku dowolnego certyfikatu przychodzącego protokół NetX Secure TLS będzie wykonywał podstawowe sprawdzanie poprawności ścieżki X. 509.</span><span class="sxs-lookup"><span data-stu-id="ac926-702">For any incoming certificate, NetX Secure TLS will perform basic X.509 path validation.</span></span> <span data-ttu-id="ac926-703">Proces polega na sprawdzeniu podpisu cyfrowego każdego certyfikatu dla certyfikatu wystawcy, który może być dostarczony przez hosta zdalnego lub znajdować się w zaufanym magazynie certyfikatów (zobacz sekcję "Importowanie certyfikatów X. 509 do usługi NetX Secure"), aby uzyskać więcej informacji na temat importowania zaufanych certyfikatów).</span><span class="sxs-lookup"><span data-stu-id="ac926-703">The process involves checking each certificate's digital signature against its issuer certificate, which may be provided by the remote host or be located in the trusted certificate store (see the section "Importing X.509 certificates into NetX Secure" for more information on importing trusted certificates).</span></span> <span data-ttu-id="ac926-704">Proces sprawdzania poprawności jest cyklicznie powtarzany w certyfikatach wystawcy, dopóki nie zostanie osiągnięty zaufany certyfikat lub że łańcuch zostanie zakończony (z certyfikatem z podpisem własnym lub z brakującym certyfikatem wystawcy).</span><span class="sxs-lookup"><span data-stu-id="ac926-704">The validation process is recursively repeated on the issuer certificates until a trusted certificate is reached or the chain ends (with a self-signed certificate or a missing issuer certificate).</span></span> <span data-ttu-id="ac926-705">Jeśli zostanie osiągnięty zaufany certyfikat, certyfikat zostanie zweryfikowany, w przeciwnym razie zostanie odrzucony.</span><span class="sxs-lookup"><span data-stu-id="ac926-705">If a trusted certificate is reached, the certificate is verified, otherwise it is rejected.</span></span> <span data-ttu-id="ac926-706">Ponadto na każdym etapie procesu weryfikacji Data wygaśnięcia każdego certyfikatu jest sprawdzana względem czasu podanego przez funkcję sygnatury czasowej aplikacji (Aby uzyskać więcej informacji, zobacz "nx_secure_tls_session_time_function_set".</span><span class="sxs-lookup"><span data-stu-id="ac926-706">Additionally, at each stage in the verification process the expiration date of each certificate is checked against the time provided by the application timestamp function (see the service "nx_secure_tls_session_time_function_set" for more information).</span></span>

<span data-ttu-id="ac926-707">Specyfikacja X. 509 zawiera również algorytm obsługujący "zasady", czyli identyfikatory, które znajdują się w rozszerzeniu X. 509, które można sprawdzić podczas weryfikacji ścieżki.</span><span class="sxs-lookup"><span data-stu-id="ac926-707">The X.509 specification also provides an algorithm for supporting "policies", which are identifiers that are present in an X.509 extension that can be checked during path validation.</span></span> <span data-ttu-id="ac926-708">NetX zabezpiecza obecnie traktuje certyfikaty X. 509, ponieważ w przypadku zdefiniowania opcji "anyPolicy" — to oznacza, że wszystkie zasady są akceptowane, a opcjonalne sprawdzanie zasad nie jest wykonywane.</span><span class="sxs-lookup"><span data-stu-id="ac926-708">NetX Secure currently treats X.509 certificates as though the "anyPolicy" option is defined – that is, all policies are acceptable and the optional policy checking is not performed.</span></span> <span data-ttu-id="ac926-709">Implementację NetX Secure X. 509 można rozszerzyć za pomocą tej funkcji w przyszłej wersji.</span><span class="sxs-lookup"><span data-stu-id="ac926-709">The NetX Secure X.509 implementation may be augmented with this feature in a future release.</span></span> <span data-ttu-id="ac926-710">Na razie rozszerzenie zasad może zostać uzyskane z certyfikatu przy użyciu interfejsu API *nx_secure_x509_extension_find* .</span><span class="sxs-lookup"><span data-stu-id="ac926-710">For now, the policy extension may be obtained from a certificate using the *nx_secure_x509_extension_find* API.</span></span>

<span data-ttu-id="ac926-711">Po zakończeniu walidacji ścieżki podstawowej protokół TLS wywoła wywołanie zwrotne weryfikacji certyfikatu dostarczone przez aplikację przy użyciu interfejsu API *nx_secure_tls_session_certificate_callback_set* .</span><span class="sxs-lookup"><span data-stu-id="ac926-711">Once the basic path validation is complete, TLS will invoke the certificate verification callback supplied by the application using the *nx_secure_tls_session_certificate_callback_set* API.</span></span> <span data-ttu-id="ac926-712">Jeśli nie podano wywołania zwrotnego, certyfikat jest uznawany za zaufany po pomyślnej weryfikacji ścieżki.</span><span class="sxs-lookup"><span data-stu-id="ac926-712">If no callback is supplied, the certificate is considered to be trusted following successful path validation.</span></span> <span data-ttu-id="ac926-713">Jeśli zostanie podane wywołanie zwrotne, wywołanie zwrotne będzie przeprowadzać wszelkie dodatkowe walidacje certyfikatu wymagane przez aplikację.</span><span class="sxs-lookup"><span data-stu-id="ac926-713">If a callback is supplied, the callback will perform any additional validation of the certificate required by the application.</span></span> <span data-ttu-id="ac926-714">Wartość zwracana z wywołania zwrotnego jest używana do określenia, czy kontynuować uzgadnianie TLS czy też przerwać uzgadnianie z powodu błędu walidacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-714">The return value from the callback is used to determine whether to continue with the TLS handshake or to abort the handshake due to a validation failure.</span></span>

<span data-ttu-id="ac926-715">Wywołanie zwrotne jest wywoływane ze wskaźnikiem do odpowiedniej sesji TLS i NX_SECURE_X509_CERTm wskaźnikiem do certyfikatu do zweryfikowania.</span><span class="sxs-lookup"><span data-stu-id="ac926-715">The callback is invoked with a pointer to the relevant TLS session and an NX_SECURE_X509_CERT pointer to the certificate to be validated.</span></span> <span data-ttu-id="ac926-716">Między sesją TLS i certyfikatem aplikacja ma wszystkie dane wymagane od protokołu TLS w celu przeprowadzenia dodatkowych testów weryfikacyjnych.</span><span class="sxs-lookup"><span data-stu-id="ac926-716">Between the TLS session and the certificate, the application has all of the data it needs from TLS to perform additional verification checks.</span></span>

<span data-ttu-id="ac926-717">Aby pomóc w dodatkowej weryfikacji, NetX Secure udostępnia procedury X. 509 dla niektórych typowych operacji sprawdzania poprawności, w tym sprawdzanie poprawności DNS i sprawdzanie listy odwołania certyfikatów.</span><span class="sxs-lookup"><span data-stu-id="ac926-717">To help with the additional validation, NetX Secure provides X.509 routines for some common validation operations, including DNS validation and Certificate Revocation List checking.</span></span> <span data-ttu-id="ac926-718">Wszystkie te procedury są odpowiednie do użycia w ramach wywołania zwrotnego weryfikacji certyfikatu, ale mogą być również używane do przeprowadzania wyłączania certyfikatów X. 509.</span><span class="sxs-lookup"><span data-stu-id="ac926-718">All of these routines are suitable for use within the certificate verification callback but may also be used to perform off-line checking of X.509 certificates.</span></span>

<span data-ttu-id="ac926-719">Poniższa tabela zawiera podsumowanie dostępnych funkcji pomocnika dla przetwarzania certyfikatów X. 509.</span><span class="sxs-lookup"><span data-stu-id="ac926-719">The following table summarizes the available helper functions for X.509 certificate processing.</span></span> <span data-ttu-id="ac926-720">Bardziej szczegółowe wyjaśnienia dotyczące operacji można znaleźć w poniższych sekcjach i dokumentacji interfejsu API w rozdziale 4</span><span class="sxs-lookup"><span data-stu-id="ac926-720">More detailed explanations for the operations can be found in the following sections and the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="ac926-721">Opis usług NetX Secure Services zawiera dodatkowe szczegóły dotyczące konkretnych procedur.</span><span class="sxs-lookup"><span data-stu-id="ac926-721">Description of NetX Secure Services provides additional details on the specific routines.</span></span>

| <span data-ttu-id="ac926-722">**Nazwa interfejsu API**</span><span class="sxs-lookup"><span data-stu-id="ac926-722">**API Name**</span></span>                             | <span data-ttu-id="ac926-723">**Opis**</span><span class="sxs-lookup"><span data-stu-id="ac926-723">**Description**</span></span>                               |
| ---------------------------------------- | -------------------------------------- |
| <span data-ttu-id="ac926-724">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="ac926-724">nx_secure_x509_common_name_dns_check</span></span>               | <span data-ttu-id="ac926-725">Sprawdź nazwę pospolitą podmiotu X. 509 i SubjectAltName w odniesieniu do oczekiwanej nazwy DNS</span><span class="sxs-lookup"><span data-stu-id="ac926-725">Check the X.509 subject Common Name and SubjectAltName against an expected DNS name</span></span> |
| <span data-ttu-id="ac926-726">nx_secure_x509_crl_revocation_check</span><span class="sxs-lookup"><span data-stu-id="ac926-726">nx_secure_x509_crl_revocation_check</span></span>                 | <span data-ttu-id="ac926-727">Wyszukaj odwołany certyfikat na liście odwołania certyfikatów X. 509 (CRL)</span><span class="sxs-lookup"><span data-stu-id="ac926-727">Check for a revoked certificate in an X.509 Certificate Revocation List (CRL)</span></span>       |
| <span data-ttu-id="ac926-728">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="ac926-728">nx_secure_x509_extended_key_usage_extension_parse</span></span> | <span data-ttu-id="ac926-729">Analizowanie i znajdowanie określonego identyfikatora OID rozszerzonego użycia klucza w certyfikacie</span><span class="sxs-lookup"><span data-stu-id="ac926-729">Parse and find a specific extended key usage OID in a certificate</span></span>                   |
| <span data-ttu-id="ac926-730">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="ac926-730">nx_secure_x509_key_usage_extension_parse</span></span>           | <span data-ttu-id="ac926-731">Analizowanie i zwracanie pole bitowe użycia klucza w certyfikacie</span><span class="sxs-lookup"><span data-stu-id="ac926-731">Parse and return the key usage bitfield in a certificate</span></span>                            |
| <span data-ttu-id="ac926-732">nx_secure_x509_extension_find</span><span class="sxs-lookup"><span data-stu-id="ac926-732">nx_secure_x509_extension_find</span></span>                        | <span data-ttu-id="ac926-733">Znajdź i zwróć nieprzetworzone dane ASN. 1 zakodowane algorytmem DER dla określonego rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="ac926-733">Find and return the raw DER-encoded ASN.1 data for a specific extension.</span></span>            |

<span data-ttu-id="ac926-734">Funkcje pomocnika X. 509 do użycia w wywołaniu zwrotnym weryfikacji certyfikatu</span><span class="sxs-lookup"><span data-stu-id="ac926-734">X.509 helper functions for use in the certificate verification callback</span></span>

### <a name="x509-extensions"></a><span data-ttu-id="ac926-735">Rozszerzenia X. 509</span><span class="sxs-lookup"><span data-stu-id="ac926-735">X.509 Extensions</span></span>

<span data-ttu-id="ac926-736">Specyfikacja X. 509 zawiera wiele "rozszerzeń", które mogą być używane do dostarczania dodatkowych informacji, które mogą być wykorzystane w weryfikacji certyfikatów.</span><span class="sxs-lookup"><span data-stu-id="ac926-736">The X.509 specification describes a number of "extensions" that can be used to supply additional information that can be utilized in the verification of certificates.</span></span> <span data-ttu-id="ac926-737">W większości przypadków te rozszerzenia są opcjonalne i nie są wymagane do bezpiecznej weryfikacji certyfikatu cyfrowego względem zaufanego certyfikatu głównego.</span><span class="sxs-lookup"><span data-stu-id="ac926-737">For the most part, these extensions are optional and are not required for secure validation of a digital certificate against a trusted root certificate.</span></span> <span data-ttu-id="ac926-738">Jednak usługa NetX Secure obsługuje niektóre podstawowe rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="ac926-738">However, NetX Secure does support some basic extensions.</span></span> <span data-ttu-id="ac926-739">Obsługę dodatkowych rozszerzeń można dodać w przyszłych wydaniach.</span><span class="sxs-lookup"><span data-stu-id="ac926-739">Support for additional extensions may be added in future releases.</span></span>

<span data-ttu-id="ac926-740">Obecnie obsługiwane rozszerzenia są wymienione w poniższej tabeli:</span><span class="sxs-lookup"><span data-stu-id="ac926-740">The currently supported extensions are listed in the following table:</span></span>

| <span data-ttu-id="ac926-741">Nazwa rozszerzenia</span><span class="sxs-lookup"><span data-stu-id="ac926-741">Extension Name</span></span>           | <span data-ttu-id="ac926-742">Opis</span><span class="sxs-lookup"><span data-stu-id="ac926-742">Description</span></span>                                                                   | <span data-ttu-id="ac926-743">Odpowiedni interfejs API</span><span class="sxs-lookup"><span data-stu-id="ac926-743">Relevant API</span></span>                                             |
| ------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------------------- |
| <span data-ttu-id="ac926-744">Użycie klucza</span><span class="sxs-lookup"><span data-stu-id="ac926-744">Key Usage</span></span>                | <span data-ttu-id="ac926-745">Zapewnia akceptowalne użycie klucza publicznego certyfikatu w pole bitowe</span><span class="sxs-lookup"><span data-stu-id="ac926-745">Provides acceptable uses for a certificate's public key in a bitfield</span></span>         | <span data-ttu-id="ac926-746">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="ac926-746">nx_secure_x509_key_usage_extension_parse</span></span>           |
| <span data-ttu-id="ac926-747">Rozszerzone użycie klucza</span><span class="sxs-lookup"><span data-stu-id="ac926-747">Extended Key Usage</span></span>       | <span data-ttu-id="ac926-748">Zapewnia dodatkowe akceptowalne zastosowania klucza publicznego certyfikatu przy użyciu identyfikatorów OID</span><span class="sxs-lookup"><span data-stu-id="ac926-748">Provides additional acceptable uses for a certificate's public key using OIDs</span></span> | <span data-ttu-id="ac926-749">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="ac926-749">nx_secure_x509_extended_key_usage_extension_parse</span></span> |
| <span data-ttu-id="ac926-750">Alternatywna nazwa podmiotu</span><span class="sxs-lookup"><span data-stu-id="ac926-750">Subject Alternative Name</span></span> | <span data-ttu-id="ac926-751">Udostępnia alternatywne nazwy DNS, które są również reprezentowane przez certyfikat</span><span class="sxs-lookup"><span data-stu-id="ac926-751">Provides alternative DNS names that are also represented by the certificate</span></span>   | <span data-ttu-id="ac926-752">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="ac926-752">nx_secure_x509_common_name_dns_check</span></span>               |

### <a name="unsupported-x509-extensions"></a><span data-ttu-id="ac926-753">Nieobsługiwane rozszerzenia X. 509</span><span class="sxs-lookup"><span data-stu-id="ac926-753">Unsupported X.509 Extensions</span></span>

<span data-ttu-id="ac926-754">NetX Secure X. 509 implementacji zapewnia usługę do wyodrębnienia nieobsługiwanych rozszerzeń, jak również: *nx_secure_x509_extension_find*.</span><span class="sxs-lookup"><span data-stu-id="ac926-754">NetX Secure's X.509 implemenation does provide a service to extract unsupported extensions as well: *nx_secure_x509_extension_find*.</span></span> <span data-ttu-id="ac926-755">Ten interfejs API jest przeznaczony dla zaawansowanych użytkowników, ponieważ wymaga informacji o ASN. 1 w celu przeanalizowania zwracanych danych.</span><span class="sxs-lookup"><span data-stu-id="ac926-755">This API is intended for advanced users as it requires knowledge of DER-encoded ASN.1 in order to parse the data returned.</span></span> <span data-ttu-id="ac926-756">Jest ona używana wewnętrznie w celu wyodrębnienia obsługiwanych rozszerzeń, ale jest dostarczana dla wygody podczas opracowywania dostosowanej obsługi rozszerzeń X. 509.</span><span class="sxs-lookup"><span data-stu-id="ac926-756">It it used internally to extract supported extensions but is supplied for convenience in developing customized support for X.509 extensions.</span></span>

<span data-ttu-id="ac926-757">Aby można było użyć nx_secure_x509_extension_find, zostanie przemieszczony NX_SECURE_X509_EXTENSION, wraz z certyfikatem i IDENTYFIKATORem rozszerzenia, który jest liczbą całkowitą ciągu identyfikatora OID o zmiennej długości dla znanego typu rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="ac926-757">To use nx_secure_x509_extension_find, a NX_SECURE_X509_EXTENSION is passed in, along with the certificate and an extension ID, which is an integer representation of the variable-length OID string for a known extension type.</span></span> <span data-ttu-id="ac926-758">Pełna lista obsługiwanych identyfikatorów OID dla rozszerzeń X. 509 znajduje się w dokumentacji interfejsu API dla nx_secure_x509_extension_find na stronie 178.</span><span class="sxs-lookup"><span data-stu-id="ac926-758">A complete list of supported OIDs for X.509 extensions is provided in the API reference for nx_secure_x509_extension_find on page 178.</span></span>

<span data-ttu-id="ac926-759">Struktura NX_SECURE_X509_EXTENSION jest definiowana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="ac926-759">The NX_SECURE_X509_EXTENSION structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_X509_EXTENSION_STRUCT
{
    /* Identifier (maps to OID) for this extension. */
    USHORT nx_secure_x509_extension_id;

    /* Critical flag - boolean value. */
    USHORT nx_secure_x509_extension_critical;

    /* Pointer to DER-encoded extension data. */
    const UCHAR *nx_secure_x509_extension_data;
    ULONG        nx_secure_x509_extension_data_length;
} NX_SECURE_X509_EXTENSION;
```
<span data-ttu-id="ac926-760">Gdy usługa zwróci się pomyślnie, struktura zostanie wypełniona odpowiednimi danymi z certyfikatu.</span><span class="sxs-lookup"><span data-stu-id="ac926-760">When the service returns successfully, the structure will be populated with the relevant data from the certificate.</span></span> <span data-ttu-id="ac926-761">Pole nx_secure_x509_extension_id jest zwykle używane do celów wewnętrznych, ale zostanie wypełnione odpowiednią reprezentacją liczby całkowitej dla identyfikatora OID.</span><span class="sxs-lookup"><span data-stu-id="ac926-761">The nx_secure_x509_extension_id field is generally used for internal purposes but will be populated with the relevant OID integer representation.</span></span> <span data-ttu-id="ac926-762">Pole nx_secure_x509_extension_critical uwidacznia wartość flagi rozszerzenia krytycznego X. 509 (Boolean).</span><span class="sxs-lookup"><span data-stu-id="ac926-762">The nx_secure_x509_extension_critical field exposes the X.509 critical extension flag value (Boolean).</span></span> <span data-ttu-id="ac926-763">Pola nx_secure_x509_extension_data i nx_secure_x509_extension_data_length zawierają wskaźnik do danych ASN w formacie DER. 1 dla rozszerzenia i długość tych danych.</span><span class="sxs-lookup"><span data-stu-id="ac926-763">The nx_secure_x509_extension_data and nx_secure_x509_extension_data_length fields contain a pointer to the DER-encoded ASN.1 data for the extension, and the length of that data, respectively.</span></span>

<span data-ttu-id="ac926-764">Rzeczywista analiza numeru ASN. 1 dane wykracza poza zakres tego dokumentu, ale jeśli masz dostęp do źródła bezpiecznego protokołu TLS NetX, możesz sprawdzić, w jaki sposób analizowanie odbywa się wszędzie tam, gdzie nx_secure_x509_extension_find jest wywoływana dla obsługiwanych rozszerzeń.</span><span class="sxs-lookup"><span data-stu-id="ac926-764">Actual parsing of the extension ASN.1 data is beyond the scope of this document, but if you have access to the NetX Secure TLS source you can see how the parsing is done wherever nx_secure_x509_extension_find is called for supported extensions.</span></span>

### <a name="x509-dns-validation"></a><span data-ttu-id="ac926-765">Weryfikacja systemu DNS X. 509</span><span class="sxs-lookup"><span data-stu-id="ac926-765">X.509 DNS Validation</span></span>

<span data-ttu-id="ac926-766">Typowa operacja weryfikacji certyfikatu w protokole TLS polega na sprawdzeniu, czy nazwa domeny jest Top-Level (TLD) hosta zdalnego względem certyfikatu X. 509 dostarczonego przez ten host podczas uzgadniania protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-766">A common certificate validation operation in TLS involves checking the Top-Level Domain (TLD) name of a remote host against the X.509 certificate provided by that host during the TLS handshake.</span></span> <span data-ttu-id="ac926-767">Ta operacja pomaga upewnić się, że certyfikat jest rzeczywiście zgodny z serwerem hosta, który go dostarczył, przy założeniu, że wyszukiwanie DNS może być zaufane.</span><span class="sxs-lookup"><span data-stu-id="ac926-767">This operation helps to ensure that the certificate does indeed match the host server that provided it, assuming the DNS lookup can be trusted.</span></span> <span data-ttu-id="ac926-768">W NetX Secure TLS ta funkcja jest zapewniana przez **nx_secure_x509_common_name_dns_check** usługi, która pobiera certyfikat i ciąg zawierający część TLD adresu URL służącego do uzyskiwania dostępu do hosta.</span><span class="sxs-lookup"><span data-stu-id="ac926-768">In NetX Secure TLS, this functionality is provided by the service **nx_secure_x509_common_name_dns_check**, which takes the certificate and a string containing the TLD portion of the URL used to access the host.</span></span> <span data-ttu-id="ac926-769">Wartość TLD jest porównywana z polem nazwa pospolita certyfikatu i jeśli jest zgodna, NX_SUCCESS jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="ac926-769">The TLD is compared to the certificate's Common Name field and if it matches, NX_SUCCESS is returned.</span></span> <span data-ttu-id="ac926-770">Jeśli nazwa pospolita nie jest zgodna, procedura będzie również sprawdzać istnienie rozszerzenia certyfikatu X. 509 *SubjectAltName*.</span><span class="sxs-lookup"><span data-stu-id="ac926-770">If the Common Name does not match, the routine will also check for the existence of the X.509 certificate extension *subjectAltName*.</span></span> <span data-ttu-id="ac926-771">Jeśli subjectAltName jest obecny, wszystkie wpisy DNSName w rozszerzeniu są również sprawdzane względem podanej TLD.</span><span class="sxs-lookup"><span data-stu-id="ac926-771">If a subjectAltName is present, any DNSName entries in the extension are also checked against the provided TLD.</span></span> <span data-ttu-id="ac926-772">Ponownie, jeśli dowolny z nich jest zgodny, NX_SUCCESS jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="ac926-772">Again, if any match, NX_SUCCESS is returned.</span></span> <span data-ttu-id="ac926-773">Jeśli nie zostanie znalezione dopasowanie, zwracany jest błąd odpowiedni do powrotu z wywołania zwrotnego walidacji certyfikatu.</span><span class="sxs-lookup"><span data-stu-id="ac926-773">If no match is found, an error suitable for returning from the certificate validation callback is returned.</span></span>

### <a name="x509-key-usage-and-extended-key-usage-extensions"></a><span data-ttu-id="ac926-774">Użycie klucza X. 509 i rozszerzenia rozszerzonego użycia klucza</span><span class="sxs-lookup"><span data-stu-id="ac926-774">X.509 Key Usage and Extended Key Usage Extensions</span></span>

<span data-ttu-id="ac926-775">Rozszerzenia użycie klucza X. 509 i rozszerzone użycie klucza zawierają informacje dotyczące sposobu użycia klucza publicznego certyfikatu podczas uwierzytelniania tego certyfikatu.</span><span class="sxs-lookup"><span data-stu-id="ac926-775">The X.509 Key Usage and Extended Key Usage extensions provide information on how a certificate's public key may be used when authenticating that certificate.</span></span> <span data-ttu-id="ac926-776">Użycie klucza jest dostarczane przez wystawcę certyfikatu, gdy certyfikat jest podpisany i wystawiony.</span><span class="sxs-lookup"><span data-stu-id="ac926-776">The key usage is supplied by the certificate's issuer when the certificate is signed and issued.</span></span> <span data-ttu-id="ac926-777">Użycie klucza może być używane przez hosta TLS do sprawdzenia, czy certyfikat jest autoryzowany do uwierzytelniania zdalnego hosta TLS i wykonywania innych operacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-777">The key usage may be used by a TLS host to check that the certificate is authorized to be used to authenticate a remote TLS host and perform other operations.</span></span>

<span data-ttu-id="ac926-778">Rozszerzenie użycie klucza składa się z prostego pole bitowe, gdzie każdy z bitów reprezentuje określone użycie klucza.</span><span class="sxs-lookup"><span data-stu-id="ac926-778">The Key Usage extension consists of a simple bitfield where each of the bits represents a specific key usage.</span></span> <span data-ttu-id="ac926-779">Pełna lista tych wartości znajduje się w dokumentacji interfejsu API dla *nx_secure_x509_key_usage_extension_parse* na stronie 183.</span><span class="sxs-lookup"><span data-stu-id="ac926-779">A complete list of these values is provided in the API reference for *nx_secure_x509_key_usage_extension_parse* on page 183.</span></span> <span data-ttu-id="ac926-780">Aby zapoznać się z bardziej szczegółowym opisem bitów użycia klucza i ich znaczenia, zapoznaj się ze standardem RFC 5280, w sekcji 4.2.1.3.</span><span class="sxs-lookup"><span data-stu-id="ac926-780">For a more complete description of the key usage bits and their meanings, refer to RFC 5280, section 4.2.1.3.</span></span>

<span data-ttu-id="ac926-781">Rozszerzenie rozszerzonego użycia klucza, takie jak rozszerzenie użycie klucza, zapewnia akceptowalne informacje o użyciu klucza.</span><span class="sxs-lookup"><span data-stu-id="ac926-781">The Extended Key Usage extension, like the Key Usage extension, provides acceptable key use information.</span></span> <span data-ttu-id="ac926-782">Jednak w celu zapewnienia obsługi dowolnego użycia rozszerzenie rozszerzonego użycia klucza wykorzystuje identyfikatory OID zamiast pole bitowe.</span><span class="sxs-lookup"><span data-stu-id="ac926-782">However, in order to support arbitrary usages, the Extended Key Usage extension utilizes OIDs instead of a bitfield.</span></span> <span data-ttu-id="ac926-783">Podczas analizowania rozszerzonego użycia klucza w NetX Secure X. 509, liczba całkowita reprezentująca identyfikator OID jest dostarczana przez aplikację — usługa *nx_secure_x509_extended_key_usage_extension_parse* następnie zwróci czy ten identyfikator OID jest obecny.</span><span class="sxs-lookup"><span data-stu-id="ac926-783">When parsing an Extended Key Usage extension in NetX Secure X.509, an integer representing the OID is supplied by the application – the *nx_secure_x509_extended_key_usage_extension_parse* service will then return whether that OID is present.</span></span> <span data-ttu-id="ac926-784">Pełna lista obsługiwanych identyfikatorów OID dla rozszerzonego użycia klucza znajduje się w dokumentacji interfejsu API dla *nx_secure_x509_extended_key_usage_extension_parse* na stronie 175.</span><span class="sxs-lookup"><span data-stu-id="ac926-784">A complete list of supported OIDs for Extended Key usage is provided in the API reference for *nx_secure_x509_extended_key_usage_extension_parse* on page 175.</span></span> <span data-ttu-id="ac926-785">Aby zapoznać się z bardziej szczegółowym opisem identyfikatorów OID i ich znaczenia, zapoznaj się ze standardem RFC 5280, w sekcji 4.2.1.12.</span><span class="sxs-lookup"><span data-stu-id="ac926-785">For a more complete description of the OIDs and their meanings, refer to RFC 5280, section 4.2.1.12.</span></span>

### <a name="x509-crl-revocation-status-checking"></a><span data-ttu-id="ac926-786">Sprawdzanie stanu odwołania do listy CRL X. 509</span><span class="sxs-lookup"><span data-stu-id="ac926-786">X.509 CRL Revocation Status Checking</span></span>

<span data-ttu-id="ac926-787">X. 509 udostępnia mechanizm nazywany *listą odwołania certyfikatów* (CRL), która umożliwia urzędowi podpisywania certyfikatu cyfrowego odwoływanie ważności certyfikatów, które zostały podpisane.</span><span class="sxs-lookup"><span data-stu-id="ac926-787">X.509 provides a mechanism called the *Certificate Revocation List* (CRL) that allows a digital certificate signing authority to revoke the validity of certificates it has signed.</span></span> <span data-ttu-id="ac926-788">Wszystkie aplikacje, które wymagają zweryfikowania certyfikatów z urzędu podpisywania, mogą uzyskać listę CRL i porównać wszystkie certyfikaty podpisane przez urząd certyfikacji z listą CRL, aby sprawdzić, czy ich stan został odwołany z jakiegoś powodu (na przykład złamany klucz prywatny).</span><span class="sxs-lookup"><span data-stu-id="ac926-788">Any application that needs to verify certificates from a signing authority can obtain a CRL and compare any certificates signed by that authority (issuer) against the CRL to see if they have had their status revoked for some reason (such as compromised private key).</span></span> <span data-ttu-id="ac926-789">W ten sposób aplikacja może uniknąć używania potencjalnie niebezpiecznych certyfikatów, które przekazują inne sprawdzenia poprawności certyfikatu.</span><span class="sxs-lookup"><span data-stu-id="ac926-789">In this way, the application can avoid using potentially dangerous certificates that pass other certificate validation checks.</span></span>

<span data-ttu-id="ac926-790">Uzyskiwanie listy CRL odbywa się przez aplikację przez pobranie listy kodowanej algorytmem DER ze wstępnie zdefiniowanego serwera lub w inny sposób.</span><span class="sxs-lookup"><span data-stu-id="ac926-790">Obtaining a CRL is done by an application by downloading the DER-encoded list from a pre-defined server or through some other means.</span></span> <span data-ttu-id="ac926-791">Rzeczywista konfiguracja jest różna od wystawcy do wystawcy, aby usługa NetX Secure nie zapewniała mechanizmu uzyskiwania listy CRL, ale udostępnia procedurę sprawdzania certyfikatu w odniesieniu do listy CRL, **nx_secure_x509_crl_revocation_check**.</span><span class="sxs-lookup"><span data-stu-id="ac926-791">The actual setup varies from issuer to issuer so NetX Secure does not provide a mechanism for obtaining CRLs, but it does provide a routine to check a certificate against a CRL, **nx_secure_x509_crl_revocation_check**.</span></span>

<span data-ttu-id="ac926-792">Interfejs API przyjmuje listę CRL zakodowaną algorytmem DER, magazyn certyfikatów (na przykład ten, który znajduje się w sesji TLS) do sprawdzenia i certyfikat do sprawdzenia.</span><span class="sxs-lookup"><span data-stu-id="ac926-792">The API takes a DER-encoded CRL, a certificate store (such as the one in a TLS session) to check against, and the certificate to be checked.</span></span> <span data-ttu-id="ac926-793">Procedura najpierw sprawdza poprawność samej listy CRL względem zaufanego magazynu (część magazynu certyfikatów dostarczanego przez aplikację).</span><span class="sxs-lookup"><span data-stu-id="ac926-793">The routine first validates the CRL itself against the trusted store (part of the certificate store provided by the application).</span></span> <span data-ttu-id="ac926-794">Jest to ważne, aby chronić przed nieuczciwymi listami CRL używanymi w przypadku ataków typu "odmowa usługi" oraz stwierdzać, że lista CRL jest rzeczywiście od właściwego wystawcy.</span><span class="sxs-lookup"><span data-stu-id="ac926-794">This is important to protect against fraudulent CRLs being used for Denial-of-Service attacks and establishes that the CRL is actually from the proper issuer.</span></span> <span data-ttu-id="ac926-795">Po sprawdzeniu poprawności listy CRL wystawcy zostanie sprawdzony — Jeśli wystawca listy CRL nie pasuje do wystawcy certyfikatu, wówczas lista CRL nie jest prawidłowa dla tego certyfikatu i zwracany jest błąd.</span><span class="sxs-lookup"><span data-stu-id="ac926-795">Following the CRL validation, the issuer is checked – if the issuer of the CRL does not match the issuer of the certificate, then the CRL is not valid for that certificate and an error is returned.</span></span> <span data-ttu-id="ac926-796">Do aplikacji można określić, czy uzgadnianie TLS może być kontynuowane w tym momencie.</span><span class="sxs-lookup"><span data-stu-id="ac926-796">It is up to the application to determine whether the TLS handshake can continue at this point.</span></span> <span data-ttu-id="ac926-797">Jeśli wystawcy są zgodne, lista CRL szuka numeru seryjnego zweryfikowanego certyfikatu.</span><span class="sxs-lookup"><span data-stu-id="ac926-797">If the issuers do match, then the CRL is searched for the serial number of the certificate being validated.</span></span> <span data-ttu-id="ac926-798">Jeśli numer seryjny znajduje się na liście, zwracany jest błąd wskazujący, że certyfikat został odwołany.</span><span class="sxs-lookup"><span data-stu-id="ac926-798">If the serial number is present in the list, an error indicating that the certificate has been revoked is returned.</span></span> <span data-ttu-id="ac926-799">Jeśli nie zostanie znalezione dopasowanie, zostanie zwrócona NX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="ac926-799">If no match is found, NX_SUCCESS is returned.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="ac926-800">Uwierzytelnianie certyfikatu klienta w protokole Secure TLS NetX</span><span class="sxs-lookup"><span data-stu-id="ac926-800">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="ac926-801">W przypadku korzystania z uwierzytelniania certyfikatu X. 509 protokół TLS wymaga, aby wystąpienie serwera TLS zapewniało certyfikat do identyfikacji, ale domyślnie wystąpienie klienta TLS nie musi podawać certyfikatu do uwierzytelnienia przy użyciu innej formy uwierzytelniania (np. kombinacji nazwy użytkownika/hasła).</span><span class="sxs-lookup"><span data-stu-id="ac926-801">When using X.509 certificate authentication, the TLS protocol requires that the TLS Server instance provide a certificate for identification, but by default the TLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="ac926-802">Jest to zgodne z najbardziej typowym wykorzystaniem protokołu TLS w Internecie dla witryn sieci Web.</span><span class="sxs-lookup"><span data-stu-id="ac926-802">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="ac926-803">Na przykład witryna handlu detalicznego w trybie online musi udowodnić potencjalnemu klientowi korzystanie z przeglądarki sieci Web, że serwer jest wiarygodny, ale użytkownik użyje nazwy logowania/hasła w celu uzyskania dostępu do określonego konta.</span><span class="sxs-lookup"><span data-stu-id="ac926-803">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="ac926-804">Jednak domyślna wielkość liter nie zawsze jest pożądana, więc protokół TLS zezwala na to, aby wystąpienie serwera TLS zażądało certyfikatu z klienta zdalnego.</span><span class="sxs-lookup"><span data-stu-id="ac926-804">However, the default case is not always desirable, so TLS optionally allows for the TLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="ac926-805">Po włączeniu tej funkcji serwer TLS wyśle do klienta protokołu TLS komunikat CertificateRequest podczas uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-805">When this feature is enabled, the TLS Server will send a CertificateRequest message to the TLS Client during the handshake.</span></span> <span data-ttu-id="ac926-806">Klient musi odpowiedzieć własnym certyfikatem, a komunikat CertificateVerify zawierający token kryptograficzny wskazujący, że klient jest właścicielem zgodnego klucza prywatnego skojarzonego z tym certyfikatem.</span><span class="sxs-lookup"><span data-stu-id="ac926-806">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="ac926-807">Jeśli weryfikacja nie powiedzie się lub certyfikat nie jest połączony z zaufanym certyfikatem na serwerze, uzgadnianie TLS nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="ac926-807">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="ac926-808">Istnieją dwa oddzielne przypadki uwierzytelniania certyfikatu klienta w protokole TLS — w poniższych sekcjach omówiono oba przypadki.</span><span class="sxs-lookup"><span data-stu-id="ac926-808">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-tls-clients"></a><span data-ttu-id="ac926-809">Uwierzytelnianie certyfikatu klienta dla klientów TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-809">Client Certificate Authentication for TLS Clients</span></span>

<span data-ttu-id="ac926-810">Klient protokołu TLS może próbować nawiązać połączenie z serwerem, który żąda certyfikatu do uwierzytelnienia klienta.</span><span class="sxs-lookup"><span data-stu-id="ac926-810">A TLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="ac926-811">W takim przypadku klient musi dostarczyć certyfikat do serwera i upewnić się, że jest właścicielem zgodnego klucza prywatnego lub serwer zakończy uzgadnianie TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-811">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the TLS handshake.</span></span>

<span data-ttu-id="ac926-812">W NetX Secure TLS nie ma specjalnej konfiguracji do obsługi tej funkcji, ale aplikacja będzie musiała podać lokalny certyfikat identyfikacyjny dla wystąpienia klienta TLS przy użyciu usługi *nx_secure_tls_local_certificate_add* .</span><span class="sxs-lookup"><span data-stu-id="ac926-812">In NetX Secure TLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_local_certificate_add* service.</span></span> <span data-ttu-id="ac926-813">Jeśli aplikacja nie udostępnia żadnego certyfikatu, ale serwer zdalny używa uwierzytelniania certyfikatu klienta i żąda certyfikatu, uzgadnianie protokołu TLS zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="ac926-813">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the TLS handshake will fail.</span></span> <span data-ttu-id="ac926-814">Aby można było wykonać uzgadnianie TLS, certyfikat podany w sesji protokołu TLS z *nx_secure_tls_local_certificate_add* musi być rozpoznawany przez serwer zdalny.</span><span class="sxs-lookup"><span data-stu-id="ac926-814">The certificate provided to the TLS Session with *nx_secure_tls_local_certificate_add* must be recognized by the remote server in order to complete the TLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="ac926-815">Uwierzytelnianie certyfikatu klienta dla serwerów TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-815">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="ac926-816">Przypadek serwera TLS dla uwierzytelniania certyfikatu klienta jest nieco bardziej skomplikowany niż przypadek klienta TLS ze względu na opcjonalną funkcję.</span><span class="sxs-lookup"><span data-stu-id="ac926-816">The TLS Server case for Client Certificate Authentication is slightly more complex than the TLS Client case due to the feature being optional.</span></span> <span data-ttu-id="ac926-817">W takim przypadku serwer TLS musi jawnie zażądać certyfikatu ze zdalnego klienta TLS, a następnie przetworzyć komunikat CertificateVerify, aby sprawdzić, czy Klient zdalny jest właścicielem pasującego klucza prywatnego, a następnie serwer musi sprawdzić, czy certyfikat dostarczony przez klienta może być śledzony do certyfikatu w lokalnym magazynie zaufanych certyfikatów.</span><span class="sxs-lookup"><span data-stu-id="ac926-817">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="ac926-818">W przypadku wystąpień serwera Secure TLS NetX uwierzytelnianie certyfikatu klienta jest kontrolowane przez</span><span class="sxs-lookup"><span data-stu-id="ac926-818">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by</span></span> <br>
<span data-ttu-id="ac926-819">*Klient <span class="underline"> _</span> Secure <span class="underline">_</span>TLS <span class="underline"> _</span> sesji <span class="underline">_</span>NX <span class="underline"> _</span> Weryfikuj <span class="underline">_</span>* i</span><span class="sxs-lookup"><span data-stu-id="ac926-819">the *nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>enable* and</span></span><br>
<span data-ttu-id="ac926-820">*<span class="underline"> _</span> bezpieczny <span class="underline">_</span>klient <span class="underline"> _</span> sesji <span class="underline">_</span>protokołu TLS w usłudze NX <span class="underline"> _</span> Sprawdź, czy <span class="underline">_</span>są wyłączone* usługi.</span><span class="sxs-lookup"><span data-stu-id="ac926-820">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>disable* services.</span></span>

<span data-ttu-id="ac926-821">Aby włączyć uwierzytelnianie certyfikatu klienta, aplikacja musi wywoływać</span><span class="sxs-lookup"><span data-stu-id="ac926-821">To enable Client Certificate Authentication, an application must call</span></span><br>
<span data-ttu-id="ac926-822">*Klient <span class="underline"> _</span> bezpiecznej <span class="underline">_</span><span class="underline"> _</span> sesji <span class="underline">_</span>TLS przed wywołaniem nx_secure_tls_session_start <span class="underline"> _</span> Sprawdź, czy <span class="underline">_</span>włączono* go przy użyciu wystąpienia sesji serwera TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-822">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify <span class="underline">_</span>enable* with the TLS Server session instance before calling *nx_secure_tls_session_start*.</span></span> <span data-ttu-id="ac926-823">Należy zauważyć, że wywołanie tej usługi w sesji protokołu TLS, która jest używana na potrzeby połączeń klientów TLS, nie będzie miało żadnego efektu.</span><span class="sxs-lookup"><span data-stu-id="ac926-823">Note that calling this service on a TLS Session that is used for TLS Client connections will have no effect.</span></span>

<span data-ttu-id="ac926-824">Po włączeniu uwierzytelniania przy użyciu certyfikatu klienta serwer TLS zażąda certyfikatu od klienta zdalnego protokołu TLS podczas uzgadniania protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-824">When Client Certificate Authentication is enabled, the TLS Server will request a certificate from the remote TLS Client during the TLS handshake.</span></span> <span data-ttu-id="ac926-825">W przypadku serwera NetX Secure TLS certyfikat klienta jest sprawdzany pod względem magazynu zaufanych certyfikatów utworzonych przy użyciu *nx <span class="underline"> _</span> <span class="underline">_ secure_tls</span>zaufany <span class="underline"> _</span> <span class="underline">_ certyfikat</span>Dodaj* następujący po łańcuchu wystawcy X. 509.</span><span class="sxs-lookup"><span data-stu-id="ac926-825">In NetX Secure TLS Server, the Client certificate is checked against the store of trusted certificates created with *nx <span class="underline">_</span>secure_tls <span class="underline">_</span>trusted <span class="underline">_</span>certificate<span class="underline">_</span>add* following the X.509 issuer chain.</span></span> <span data-ttu-id="ac926-826">Klient zdalny musi dostarczyć łańcuch, który łączy jego certyfikat tożsamości z certyfikatem w zaufanym magazynie lub uzgadnianie protokołu TLS zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="ac926-826">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the TLS handshake will fail.</span></span> <span data-ttu-id="ac926-827">Ponadto jeśli przetwarzanie komunikatu CertificateVerify nie powiedzie się, uzgadnianie TLS również zakończy się niepowodzeniem.</span><span class="sxs-lookup"><span data-stu-id="ac926-827">Additionally, if the CertificateVerify message processing fails, the TLS handshake will also fail.</span></span>

<span data-ttu-id="ac926-828">Metody podpisu używane dla metody CertificateVerify są ustalone dla protokołów TLS w wersji 1,0 i TLS w wersji 1,1 i są określone przez serwer TLS w wersji TLS 1,2.</span><span class="sxs-lookup"><span data-stu-id="ac926-828">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2.</span></span> <span data-ttu-id="ac926-829">W przypadku protokołu TLS 1,2 metody podpisywania są ogólnie zgodne z odpowiednimi metodami podanymi w tabeli metod kryptograficznych, ale zazwyczaj RSA z algorytmem SHA-256 (zobacz sekcję "Kryptografia w NetX Secure TLS", aby uzyskać więcej informacji na temat inicjowania protokołu TLS z metodami kryptograficznymi).</span><span class="sxs-lookup"><span data-stu-id="ac926-829">For TLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section "Cryptography in NetX Secure TLS" for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="ac926-830">Kryptografia w protokole Secure TLS NetX</span><span class="sxs-lookup"><span data-stu-id="ac926-830">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="ac926-831">TLS definiuje protokół, w którym Kryptografia może być używana do zabezpieczania komunikacji sieciowej.</span><span class="sxs-lookup"><span data-stu-id="ac926-831">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="ac926-832">W związku z tym pozostawi rzeczywiste kryptografie do użycia w postaci otwartej dla użytkowników protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-832">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="ac926-833">Specyfikacja wymaga tylko jednego ciphersuite do zaimplementowania — w przypadku protokołu TLS 1,2, że ciphersuite jest TLS_RSA_WITH_AES_128_CBC_SHA, wskazując użycie RSA dla operacji klucza publicznego, AES w trybie CBC z 128-bitowymi kluczami dla szyfrowania sesji i algorytmem SHA-1 dla skrótów uwierzytelniania komunikatów.</span><span class="sxs-lookup"><span data-stu-id="ac926-833">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="ac926-834">Jest zgodny z protokołem TLS 1,2, NetX Secure domyślnie włącza obowiązkowy TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite, ale biorąc pod uwagę liczbę możliwych implementacji dla każdej z metod kryptograficznych ze względu na możliwości sprzętowe i inne zagadnienia, NetX Secure zapewnia ogólny interfejs API kryptografii, który umożliwia użytkownikowi określenie metod kryptograficznych, które mają być używane z protokołem TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-834">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

<span data-ttu-id="ac926-835">Uwaga: mechanizm ogólnego interfejsu API kryptografii umożliwia również użytkownikom implementację własnych ciphersuites, ale jest to zalecane dla zaawansowanych użytkowników, którzy znają ciphersuites i rozszerzenia TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-835">NOTE: The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="ac926-836">Skontaktuj się z przedstawicielem programu Express Logic, Jeśli interesuje Cię obsługę własnych ciphersuites.</span><span class="sxs-lookup"><span data-stu-id="ac926-836">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

### <a name="cryptographic-methods"></a><span data-ttu-id="ac926-837">Metody kryptograficzne</span><span class="sxs-lookup"><span data-stu-id="ac926-837">Cryptographic Methods</span></span>

<span data-ttu-id="ac926-838">NetX Secure TLS implementuje algorytm DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA i ECC (wybrane krzywe) w oprogramowaniu ze sterownikami sprzętowymi dla określonych platform sprzętowych.</span><span class="sxs-lookup"><span data-stu-id="ac926-838">NetX Secure TLS implements DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA, and ECC (selected curves) in software with hardware drivers for certain hardware platforms.</span></span> <span data-ttu-id="ac926-839">Aplikacja może korzystać z procedur kryptograficznych dostarczanych z usługą NetX Secure lub używać procedur niestandardowych dostarczonych przez użytkownika końcowego lub inne osoby trzecie.</span><span class="sxs-lookup"><span data-stu-id="ac926-839">An application may use the cryptographic routines provided with NetX Secure, or use custom routines provided by the end user or third parties.</span></span>

<span data-ttu-id="ac926-840">*NX_CRYPTO_METHOD* to blok sterowania zaprojektowany dla aplikacji do opisywania konkretnej implementacji algorytmu kryptograficznego, który ma być używany z NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-840">The *NX_CRYPTO_METHOD* is a control block designed for an application to describe a particular implementation of a cryptographic algorithm to be used with NetX Secure TLS.</span></span> <span data-ttu-id="ac926-841">Dzięki *NX_CRYPTO_METHOD* aplikacja może łatwo zintegrować swoją implementację kryptograficzną z bezpiecznym NetX.</span><span class="sxs-lookup"><span data-stu-id="ac926-841">With the *NX_CRYPTO_METHOD,* an application can easily integrate their own crypto implementation into NetX Secure.</span></span> <span data-ttu-id="ac926-842">Struktura *NX_CRYPTO_METHOD* jest zadeklarowana jako:</span><span class="sxs-lookup"><span data-stu-id="ac926-842">The *NX_CRYPTO_METHOD* structure is declared as:</span></span>

```C
typedef struct NX_CRYPTO_METHOD_STRUCT
{
    /* Symbolic name of the algorithm. */
    USHORT nx_crypto_algorithm;

    /* Size of the key, in bits. */
    USHORT nx_crypto_key_size_in_bits;

    /* Size of the IV block, in bits, used for encryption. */
    USHORT nx_crypto_IV_size_in_bits;

    /* Size of the ICV block, in bits, used for authentication. */
    USHORT nx_crypto_ICV_size_in_bits;

    /* Size of the crypto block, in bytes. */
    ULONG nx_crypto_block_size_in_bytes;

    /* Size of the metadata area. */
    ULONG nx_crypto_metadata_size;

    /* nx_crypto_init function initializes the crypto method with the
        "secret key" or other state  information. The initialization 
        routine should return a handle to the caller.  This handle is 
        used in subsequent crypto operations to identify the session.  
        */

    UINT (*nx_crypto_init) (NX_CRYPTO_METHOD     *method,
                            UCHAR               *key, 
                            NX_CRYPTO_KEY_SIZE   key_size_in_bits,
                            VOID               **handler,
                            VOID                *crypto_metadata,
                            VOID                 crypto_metadata_size);

    /* NetX Secure calls the nx_crypto_cleanup routine when a TLS
       session is to be deleted (or updated).  Resources allocated 
       during the crypto operation should be released in this routine.  
       */
    UINT (*nx_crypto_cleanup) (VOID *handler);

    /* nx_crypto_operation is the actual crypto or hash operation. Note 
       that both input and output buffers are prepared by the caller. 
       For encryption or decryption operations, the crypto operation 
       routine uses the output buffer for encrypted or decrypted data. 
       For authentication operations, the authentication routine shall 
       use the output buffer for the digest. */
    UINT (*nx_crypto_operation)(UINT  op, 
                  VOID              *handler, 
                  NX_CRYPTO_METHOD  *method,
                  UCHAR             *key,
                  NX_CRYPTO_KEY_SIZE key_size_in_bits,
                  UCHAR             *input,
                  ULONG              input_length_in_byte,
                  UCHAR             *iv_ptr,
                  UCHAR             *output,
                  ULONG              output_length_in_byte,
                  VOID              *crypto_metadata,
                  VOID               crypto_metadata_size,
                  NX_PACKET*         packet_ptr,
                  VOID (*nx_crypto_hw_process_callback(NX_PACKET 
                                                       *packet_ptr, 
                                                        UINT status);
} NX_CRYPTO_METHOD;
```

<span data-ttu-id="ac926-843">Poniżej znajduje się opis każdego elementu w strukturze *NX_CRYPTO_METHOD* :</span><span class="sxs-lookup"><span data-stu-id="ac926-843">Below is the description of each element in the *NX_CRYPTO_METHOD* structure:</span></span>

- <span data-ttu-id="ac926-844">nx_crypto_algorithm: to pole identyfikuje algorytm opisany w zmiennej *metody* pewne prawidłowe wartości dla NetX Secure TLS są następujące (zobacz nx_crypto_const. h dla określonych wartości):</span><span class="sxs-lookup"><span data-stu-id="ac926-844">nx_crypto_algorithm: This field identifies the algorithm described in the variable *method* Some valid values for NetX Secure TLS are as follows (refer to nx_crypto_const.h for specific values):</span></span>
    
  - <span data-ttu-id="ac926-845">NX_CRYPTO_NONE</span><span class="sxs-lookup"><span data-stu-id="ac926-845">NX_CRYPTO_NONE</span></span>    
  - <span data-ttu-id="ac926-846">NX_CRYPTO_ENCRYPTION_NULL</span><span class="sxs-lookup"><span data-stu-id="ac926-846">NX_CRYPTO_ENCRYPTION_NULL</span></span>    
  - <span data-ttu-id="ac926-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span><span class="sxs-lookup"><span data-stu-id="ac926-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span></span>    
  - <span data-ttu-id="ac926-848">NX_CRYPTO_AUTHENTICATION_NONE</span><span class="sxs-lookup"><span data-stu-id="ac926-848">NX_CRYPTO_AUTHENTICATION_NONE</span></span>    
  - <span data-ttu-id="ac926-849">TLS_HASH_SHA_1</span><span class="sxs-lookup"><span data-stu-id="ac926-849">TLS_HASH_SHA_1</span></span>    
  - <span data-ttu-id="ac926-850">TLS_HASH_SHA_256</span><span class="sxs-lookup"><span data-stu-id="ac926-850">TLS_HASH_SHA_256</span></span>    
  - <span data-ttu-id="ac926-851">TLS_HASH_MD5</span><span class="sxs-lookup"><span data-stu-id="ac926-851">TLS_HASH_MD5</span></span>    
  - <span data-ttu-id="ac926-852">TLS_CIPHER_RSA</span><span class="sxs-lookup"><span data-stu-id="ac926-852">TLS_CIPHER_RSA</span></span>    
  - <span data-ttu-id="ac926-853">TLS_CIPHER_NULL</span><span class="sxs-lookup"><span data-stu-id="ac926-853">TLS_CIPHER_NULL</span></span>

- <span data-ttu-id="ac926-854">nx_crypto_key_size_in_bits: to pole określa rozmiar klucza tajnego używanego przez metodę.</span><span class="sxs-lookup"><span data-stu-id="ac926-854">nx_crypto_key_size_in_bits: this field specifies the size of the secret key used by the method.</span></span>

- <span data-ttu-id="ac926-855">nx_crypto_IV_size_in_bits: to pole określa rozmiar wektora inicjalizacji (IV).</span><span class="sxs-lookup"><span data-stu-id="ac926-855">nx_crypto_IV_size_in_bits: this field specifies the size of the Initialization Vector (IV).</span></span> <span data-ttu-id="ac926-856">Należy zauważyć, że w większości przypadków blok IV jest używany tylko na potrzeby algorytmów szyfrowania i odszyfrowywania.</span><span class="sxs-lookup"><span data-stu-id="ac926-856">Note that in most cases the IV block is only used for encryption/decryption algorithms.</span></span> <span data-ttu-id="ac926-857">Algorytmy uwierzytelniania i weryfikacji rzadko używają tego pola.</span><span class="sxs-lookup"><span data-stu-id="ac926-857">Authentication and verification algorithms rarely use this field.</span></span>

- <span data-ttu-id="ac926-858">nx_crypto_ICV_size_in_bits: to pole określa rozmiar bloku wartości sprawdzania integralności (ICV).</span><span class="sxs-lookup"><span data-stu-id="ac926-858">nx_crypto_ICV_size_in_bits: this field specifies the size of the Integrity Check Value (ICV) block.</span></span> <span data-ttu-id="ac926-859">Uwaga: ten blok służy do użycia protokołu IPsec i nie jest używany w protokole TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-859">NOTE: This block is for IPsec usage and is unused in TLS.</span></span> <span data-ttu-id="ac926-860">Aby uzyskać więcej informacji, zobacz NetX Duo IPsec.</span><span class="sxs-lookup"><span data-stu-id="ac926-860">See NetX Duo IPsec for more information.</span></span>

- <span data-ttu-id="ac926-861">nx_crypto_block_size_in_bytes: to pole określa rozmiar bloku algorytmu kryptograficznego dla szyfrów opartych na blokach, w bajtach.</span><span class="sxs-lookup"><span data-stu-id="ac926-861">nx_crypto_block_size_in_bytes: this field specifies the size of the cryptographic algorithm block for block-based ciphers, in bytes.</span></span> <span data-ttu-id="ac926-862">W większości przypadków jest to używane przez procedury szyfrowania i rzadko przez procedury uwierzytelniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-862">In most cases this is used by encryption routines and rarely by authentication routines.</span></span>

- <span data-ttu-id="ac926-863">nx_crypto_metadata_area_size: to pole określa rozmiar obszaru metadanych wymaganego przez tę metodę.</span><span class="sxs-lookup"><span data-stu-id="ac926-863">nx_crypto_metadata_area_size: this field specifies the size of the metadata area this method requires.</span></span> <span data-ttu-id="ac926-864">Każda implementacja może wymagać pewnej ilości pamięci do przechowywania informacji o stanie lub przechowywania danych pośrednich (na przykład materiału transformacji Key) lub do użycia jako szkicownik.</span><span class="sxs-lookup"><span data-stu-id="ac926-864">Each implementation may require certain memory to store its state information, or to store intermediate data (such as key transformation material), or to use as a scratch area.</span></span> <span data-ttu-id="ac926-865">Ilość miejsca wymaganego przez implementację jest określona w tym polu.</span><span class="sxs-lookup"><span data-stu-id="ac926-865">The amount of space required by an implementation is specified in this field.</span></span> <span data-ttu-id="ac926-866">Aplikacja zapewnia miejsce w pamięci podczas tworzenia sesji TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-866">The application provides the memory space when creating a TLS session.</span></span> <span data-ttu-id="ac926-867">Funkcja kryptograficzna jest odpowiedzialna za zarządzanie tym obszarem metadanych.</span><span class="sxs-lookup"><span data-stu-id="ac926-867">The cryptographic function is responsible for managing this metadata area.</span></span>

- <span data-ttu-id="ac926-868">nx_crypto_init: jest to funkcja inicjująca dla algorytmu kryptograficznego.</span><span class="sxs-lookup"><span data-stu-id="ac926-868">nx_crypto_init: This is the initialization function for the cryptographic algorithm.</span></span> <span data-ttu-id="ac926-869">Dla implementacji, która nie wymaga procedury inicjowania, to pole może mieć wartość NX_NULL.</span><span class="sxs-lookup"><span data-stu-id="ac926-869">For an implementation that does not need an initialization routine, this field may be set to NX_NULL.</span></span> <span data-ttu-id="ac926-870">Typowym zastosowaniem funkcji inicjowania jest zainicjowanie wewnętrznej struktury danych dla algorytmu.</span><span class="sxs-lookup"><span data-stu-id="ac926-870">A typical use of an initialization function is to initialize the internal data structure for the algorithm.</span></span> <span data-ttu-id="ac926-871">NetX Secure TLS będzie obsługiwać inicjalizację procedury kryptograficznej przez wywołanie tej funkcji wewnętrznie.</span><span class="sxs-lookup"><span data-stu-id="ac926-871">NetX Secure TLS will handle initialization of the cryptographic routine by calling this function internally.</span></span>

<span data-ttu-id="ac926-872">Prototyp dla funkcji inicjującej to:</span><span class="sxs-lookup"><span data-stu-id="ac926-872">The prototype for the initialization function is:</span></span>

```C
UINT crypto_init_function(NX_CRYPTO_METHOD *method, 
                          UCHAR *key, 
                          UINT  key_size_in_bits, 
                          VOID  **handle, 
                          VOID  *crypto_metadata_area, 
                          ULONG crypto_metadata_area_size);
```

  - <span data-ttu-id="ac926-873">Metoda jest wskaźnikiem do bloku kontroli metody kryptograficznej.</span><span class="sxs-lookup"><span data-stu-id="ac926-873">method is a pointer to the crypto method control block.</span></span>

  - <span data-ttu-id="ac926-874">klucz jest ciągiem klucza tajnego do przetwarzania pakietów danych.</span><span class="sxs-lookup"><span data-stu-id="ac926-874">key is the secret key string for processing the data packets.</span></span>

  - <span data-ttu-id="ac926-875">key_size_in_bits definiuje rozmiar klucza tajnego w bitach.</span><span class="sxs-lookup"><span data-stu-id="ac926-875">key_size_in_bits defines the size of the secret key, in bits.</span></span>

  - <span data-ttu-id="ac926-876">dojście to element zdefiniowany przez implementację, który identyfikuje konkretną sesję kryptograficzną.</span><span class="sxs-lookup"><span data-stu-id="ac926-876">handle is an implementation-defined item that identifies a particular crypto session.</span></span> <span data-ttu-id="ac926-877">Wartość jest generowana przez procedurę inicjowania i zostaje przeniesiona z powrotem do obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="ac926-877">The value is generated by the initialization routine, and is passed back to the caller.</span></span> <span data-ttu-id="ac926-878">Kolejna operacja kryptograficzna lub procedura czyszczenia używają tego uchwytu do identyfikowania sesji.</span><span class="sxs-lookup"><span data-stu-id="ac926-878">The subsequent crypto operation or clean up routine use this handle to identify the session.</span></span>

  - <span data-ttu-id="ac926-879">crypto_metadata jest wskaźnikiem do obszaru metadanych wymaganego przez implementację tego algorytmu.</span><span class="sxs-lookup"><span data-stu-id="ac926-879">crypto_metadata is a pointer to the metadata area required by the implementation of this algorithm.</span></span> <span data-ttu-id="ac926-880">Dla algorytmów, które nie potrzebują obszaru metadanych, to pole jest ustawione na NX_NULL a procedura inicjacji nie może uzyskać dostępu do obszaru metadanych.</span><span class="sxs-lookup"><span data-stu-id="ac926-880">For algorithms that do not need a metadata area this field is set to NX_NULL and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="ac926-881">crypto_metadata_size określa rozmiar obszaru metadanych.</span><span class="sxs-lookup"><span data-stu-id="ac926-881">crypto_metadata_size specifies the size of the metadata area.</span></span> <span data-ttu-id="ac926-882">Dla sygnatury dostępu współdzielonego utworzonego bez obszaru metadanych to pole ma ustawioną wartość zero, a procedura inicjacji nie może uzyskać dostępu do obszaru metadanych.</span><span class="sxs-lookup"><span data-stu-id="ac926-882">For SAs created without metadata area, this field is set to zero, and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="ac926-883">Ta procedura zwraca *NX_SUCCESS* , jeśli proces inicjowania zakończył się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="ac926-883">This routine shall return *NX_SUCCESS* if the initialization process is successful.</span></span> <span data-ttu-id="ac926-884">Obiekt wywołujący traktuje dowolną inną wartość zwracaną jako błąd.</span><span class="sxs-lookup"><span data-stu-id="ac926-884">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="ac926-885">nx_crypto_cleanup: to jest procedura oczyszczania zdefiniowana dla implementacji algorytmu kryptograficznego.</span><span class="sxs-lookup"><span data-stu-id="ac926-885">nx_crypto_cleanup: This is the cleanup routine defined for the implementation of a crypto algorithm.</span></span> <span data-ttu-id="ac926-886">Jest wywoływana po usunięciu lub ponownym uruchomieniu sesji TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-886">It is invoked when a TLS session is deleted or restarted.</span></span>

<span data-ttu-id="ac926-887">Prototyp funkcji czyszczącej to:</span><span class="sxs-lookup"><span data-stu-id="ac926-887">The prototype for the cleanup function is:</span></span>

```C
UINT crypto_cleanup_function(VOID *handle);
```
- <span data-ttu-id="ac926-888">Dojście jest przesyłane do funkcji oczyszczania przez wywołującego.</span><span class="sxs-lookup"><span data-stu-id="ac926-888">handle is passed to the cleanup function by the caller.</span></span> <span data-ttu-id="ac926-889">Dojście jest inicjowane przez procedurę inicjalizacji kryptograficznej i używane do identyfikowania stanu algorytmu kryptograficznego.</span><span class="sxs-lookup"><span data-stu-id="ac926-889">The handle is initialized by the crypto initialization routine and used to identify cryptographic algorithm state.</span></span>

- <span data-ttu-id="ac926-890">Ta procedura zwraca *NX_SUCCESS* , jeśli proces oczyszczania zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="ac926-890">This routine shall return *NX_SUCCESS* if the cleanup process is successful.</span></span> <span data-ttu-id="ac926-891">Obiekt wywołujący traktuje dowolną inną wartość zwracaną jako błąd.</span><span class="sxs-lookup"><span data-stu-id="ac926-891">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="ac926-892">nx_crypto_operation: to jest procedura, która wykonuje rzeczywiste szyfrowanie, odszyfrowywanie i usługi uwierzytelniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-892">nx_crypto_operation: This is the routine that performs the actual encryption, decryption, and authentication services.</span></span> <span data-ttu-id="ac926-893">Prototyp funkcji procedury operacji to:</span><span class="sxs-lookup"><span data-stu-id="ac926-893">The function prototype of the operation routine is:</span></span>

```C
UINT crypto_operation_function(UINT   op,
          VOID  *handle,  
          NX_CRYPTO_METHOD* method,
          UCHAR *key,
          UCHAR  key_size_in_bits,
          UCHAR* input,
          ULONG  input_length_in_byte,
          UCHAR* iv_ptr,
          UCHAR* output,
          ULONG  output_length_in_byte,
          VOID *crypto_metadata,
          ULONG crypto_metadata_size,
          NX_PACKET *packet_ptr,
          VOID (*nx_crypto_hw_process_callback)(NX_PACKET 
                          *packet_ptr, UINT status));
```

- <span data-ttu-id="ac926-894">op wskazuje typ operacji, która powinna zostać przeprowadzona. Prawidłowe wartości to:</span><span class="sxs-lookup"><span data-stu-id="ac926-894">op indicates the type of operation this routine is expected to carry out. Valid values are:</span></span>
    
    - <span data-ttu-id="ac926-895">NX_CRYPTO_ENCRYPT</span><span class="sxs-lookup"><span data-stu-id="ac926-895">NX_CRYPTO_ENCRYPT</span></span>
    - <span data-ttu-id="ac926-896">NX_CRYPTO_DECRYPT</span><span class="sxs-lookup"><span data-stu-id="ac926-896">NX_CRYPTO_DECRYPT</span></span>
    - <span data-ttu-id="ac926-897">NX_CRYPTO_AUTHENTICATE</span><span class="sxs-lookup"><span data-stu-id="ac926-897">NX_CRYPTO_AUTHENTICATE</span></span>
    - <span data-ttu-id="ac926-898">NX_CRYPTO_VERIFY</span><span class="sxs-lookup"><span data-stu-id="ac926-898">NX_CRYPTO_VERIFY</span></span>

- <span data-ttu-id="ac926-899">dojście zostało przesłane do funkcji operacji przez obiekt wywołujący.</span><span class="sxs-lookup"><span data-stu-id="ac926-899">handle is passed to the operation function by the caller.</span></span> <span data-ttu-id="ac926-900">Jest on generowany przez procedurę inicjalizacji kryptograficznej.</span><span class="sxs-lookup"><span data-stu-id="ac926-900">It is generated by the crypto initialization routine.</span></span>
- <span data-ttu-id="ac926-901">Metoda wskazuje blok kontroli metody kryptograficznej</span><span class="sxs-lookup"><span data-stu-id="ac926-901">method points to the crypto method control block</span></span>
- <span data-ttu-id="ac926-902">klucz do klucza tajnego używanego dla tej operacji</span><span class="sxs-lookup"><span data-stu-id="ac926-902">key points to the secret key used for this operation</span></span>
- <span data-ttu-id="ac926-903">key_size_in_bits to rozmiar klucza tajnego w bitach</span><span class="sxs-lookup"><span data-stu-id="ac926-903">key_size_in_bits is the size of the secret key in bits</span></span>
- <span data-ttu-id="ac926-904">wejście to wskaźnik do początku komunikatu, na którym ma być prowadzone zarządzanie.</span><span class="sxs-lookup"><span data-stu-id="ac926-904">input is a pointer to the beginning of the message to be operated on.</span></span>
- <span data-ttu-id="ac926-905">input_length_in_byte jest przenoszona przez obiekt wywołujący, aby wskazać rozmiar wiadomości, na której ma być prowadzony proces.</span><span class="sxs-lookup"><span data-stu-id="ac926-905">input_length_in_byte is passed by the caller to indicate the size of the message to be operated on.</span></span>
- <span data-ttu-id="ac926-906">iv_ptr jest konfiguracją przez obiekt wywołujący do wskazywania początku bloku IV.</span><span class="sxs-lookup"><span data-stu-id="ac926-906">iv_ptr is setup by the caller to point to the beginning of an IV block.</span></span> <span data-ttu-id="ac926-907">Należy pamiętać, że pamięć dla bloku IV jest udostępniana przez obiekt wywołujący.</span><span class="sxs-lookup"><span data-stu-id="ac926-907">Note that the memory for the IV block is provided by the caller.</span></span> <span data-ttu-id="ac926-908">W przypadku szyfrowania, funkcja operacji powinna zapisać informacje o IV w tym bloku pamięci; w przypadku odszyfrowywania funkcja operacji powinna pobrać informacje o IV z tego bloku pamięci.</span><span class="sxs-lookup"><span data-stu-id="ac926-908">For encryption, the operation function should write the IV information into this memory block; for decryption, the operation function should retrieve the IV information from this memory block.</span></span> <span data-ttu-id="ac926-909">Algorytmy dla operacji uwierzytelniania i weryfikacji zwykle nie używają wektora inicjalizacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-909">Algorithms for authentication and verification operation typically do not use the initialization vector.</span></span>
- <span data-ttu-id="ac926-910">dane wyjściowe są skonfigurowane przez obiekt wywołujący, aby wskazywały bufor wyjściowy.</span><span class="sxs-lookup"><span data-stu-id="ac926-910">output is setup by the caller to point to an output buffer.</span></span> <span data-ttu-id="ac926-911">Należy pamiętać, że pamięć dla buforu wyjściowego jest udostępniana przez obiekt wywołujący.</span><span class="sxs-lookup"><span data-stu-id="ac926-911">Note that the memory for the output buffer is provided by the caller.</span></span> <span data-ttu-id="ac926-912">W przypadku szyfrowania funkcja operacji powinna zapisać tekst szyfru do bufora wyjściowego; w przypadku odszyfrowywania operacja powinna napisać odszyfrowany tekst (zwykły tekst) do buforu wyjściowego; w celu uwierzytelnienia wartość skrótu jest zapisywana w buforze wyjściowym.</span><span class="sxs-lookup"><span data-stu-id="ac926-912">For encryption, the operation function should write the cipher text to the output buffer; for decryption, the operation should write the deciphered text (clear text) to the output buffer; for authentication, the hash value shall be written to the output buffer.</span></span> <span data-ttu-id="ac926-913">W celu weryfikacji bufor wyjściowy służy do przechowywania informacji o skrócie.</span><span class="sxs-lookup"><span data-stu-id="ac926-913">For verification, the output buffer is used to store hash information.</span></span>
- <span data-ttu-id="ac926-914">output_length_in_byte wskazuje rozmiar buforu wyjściowego</span><span class="sxs-lookup"><span data-stu-id="ac926-914">output_length_in_byte indicates the size of the output buffer</span></span>
- <span data-ttu-id="ac926-915">crypto_metadata wskazuje obszar metadanych, który ma być używany przez tę operację kryptograficzną.</span><span class="sxs-lookup"><span data-stu-id="ac926-915">crypto_metadata points to the metadata area to be used by this crypto operation.</span></span> <span data-ttu-id="ac926-916">Obszar metadanych kryptograficznych jest zazwyczaj inicjowany przez crypto_init_function.</span><span class="sxs-lookup"><span data-stu-id="ac926-916">The crypto metadata area is typically initialized by crypto_init_function.</span></span>
- <span data-ttu-id="ac926-917">crypto_metadata_size wskazuje rozmiar obszaru metadanych.</span><span class="sxs-lookup"><span data-stu-id="ac926-917">crypto_metadata_size indicates the size of the metadata area.</span></span>
- <span data-ttu-id="ac926-918">Ta procedura zwraca *NX_SUCCESS* , jeśli proces operacji zakończy się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="ac926-918">This routine shall return *NX_SUCCESS* if the operation process is successful.</span></span> <span data-ttu-id="ac926-919">Obiekt wywołujący traktuje dowolną inną wartość zwracaną jako błąd.</span><span class="sxs-lookup"><span data-stu-id="ac926-919">The caller treats any other return value as failure.</span></span>
- <span data-ttu-id="ac926-920">packet_ptr: pakiet zawierający dane, które są przetwarzane.</span><span class="sxs-lookup"><span data-stu-id="ac926-920">packet_ptr: The packet that contains the data being processed.</span></span> <span data-ttu-id="ac926-921">Uwaga: ten parametr jest nieużywany przez protokół TLS i powinien mieć ustawioną wartość NX_NULL.</span><span class="sxs-lookup"><span data-stu-id="ac926-921">NOTE: This parameter is unused by TLS and should be set to NX_NULL.</span></span>
- <span data-ttu-id="ac926-922">nx_crypto_hw_process_callback: funkcja wywołania zwrotnego podana przez metodę szyfrowania.</span><span class="sxs-lookup"><span data-stu-id="ac926-922">nx_crypto_hw_process_callback: A callback function provided by the encryption method.</span></span> <span data-ttu-id="ac926-923">Jest używana, jeśli funkcja kryptograficzna jest dostarczana przez sprzęt i wymaga procedury wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="ac926-923">This is used if the crypto function is provided by hardware and requires a callback routine.</span></span>

<span data-ttu-id="ac926-924">NetX Secure TLS zapewnia następujące metody szyfrowania:</span><span class="sxs-lookup"><span data-stu-id="ac926-924">NetX Secure TLS provides the following encryption methods:</span></span>

- <span data-ttu-id="ac926-925">*AES*</span><span class="sxs-lookup"><span data-stu-id="ac926-925">*AES*</span></span>  
- <span data-ttu-id="ac926-926">*RSA*</span><span class="sxs-lookup"><span data-stu-id="ac926-926">*RSA*</span></span>  
- <span data-ttu-id="ac926-927">*NULL*</span><span class="sxs-lookup"><span data-stu-id="ac926-927">*NULL*</span></span>

<span data-ttu-id="ac926-928">NetX Secure TLS zapewnia następujące metody uwierzytelniania:</span><span class="sxs-lookup"><span data-stu-id="ac926-928">NetX Secure TLS provides the following authentication methods:</span></span>

- <span data-ttu-id="ac926-929">*HMAC-MD5*</span><span class="sxs-lookup"><span data-stu-id="ac926-929">*HMAC-MD5*</span></span>  
- <span data-ttu-id="ac926-930">*HMAC-SHA1*</span><span class="sxs-lookup"><span data-stu-id="ac926-930">*HMAC-SHA1*</span></span>  
- <span data-ttu-id="ac926-931">*HMAC-SHA256*</span><span class="sxs-lookup"><span data-stu-id="ac926-931">*HMAC-SHA256*</span></span>

<span data-ttu-id="ac926-932">W poniższych przykładach pokazano, jak skonfigurować strukturę *NX_CRYPTO_METHOD* tak, aby korzystała z metod szyfrowania i uwierzytelniania dostarczonych przez NetX Duo IPSec.</span><span class="sxs-lookup"><span data-stu-id="ac926-932">The following examples illustrate how to configure the *NX_CRYPTO_METHOD* structure to use the encryption and authentication methods provided by NetX Duo IPsec.</span></span>

<span data-ttu-id="ac926-933">***AES***</span><span class="sxs-lookup"><span data-stu-id="ac926-933">***AES:***</span></span>

```C
/* AES-CBC 128. */
NX_CRYPTO_METHOD crypto_method_aes_cbc_128 = 
{
    /* AES crypto algorithm                             */
    NX_CRYPTO_ENCRYPTION_AES_CBC,                       

    /* Key size in bits. For AES-128 this value is 128  */
    NX_CRYPTO_AES_128_KEY_LEN_IN_BITS,              
   
    /* IV size in bits.  For AES-128 this value is 128  */
    NX_CRYPTO_AES_IV_LEN_IN_BITS,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  For AES this value is 16   */
    (NX_CRYPTO_AES_BLOCK_SIZE_IN_BITS >> 3),        

    /* Metadata size in bytes, for AES this value is 262*/
    sizeof(NX_CRYPTO_AES),              

    /* AES-CBC initialization routine.                  */
    _nx_secure_crypto_method_aes_init,               

    /* AES-CBC cleanup routine, not used.               */
    NX_NULL,                                        

    /* AES-CBC operation                                */
    _nx_secure_crypto_method_aes_operation           
};

/* RSA. */
NX_CRYPTO_METHOD crypto_method_rsa = 
{
    /* RSA crypto algorithm                             */
    TLS_CIPHER_RSA,                       

    /* Key size. RSA key sizes vary, so set to 0.         */
    0,              
   
    /* IV size in bits.  RSA does not use an IV.         */
    0,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  RSA does not have a block size. */
    0,        

    /* Metadata size in bytes, for RSA use the control block. */
    sizeof(NX_CRYPTO_RSA),              

    /* RSA initialization routine.                  */
    _nx_secure_crypto_method_rsa_init,               

    /* Cleanup routine, not used.                    */
    NX_NULL,                                        

    /* RSA operation                                */
    _nx_secure_crypto_method_rsa_operation           

};
```
<span data-ttu-id="ac926-934">***NULL***</span><span class="sxs-lookup"><span data-stu-id="ac926-934">***NULL***</span></span>

```C
/* NULL encryption method. */
NX_CRYPTO_METHOD crypto_method_null = 
{
    NX_CRYPTO_ENCRYPTION_NULL,/* Name of the crypto algorithm  */
    0,                        /* Key size in bits, not used    */
    0,                        /* IV size in bits, not used     */
    0,                        /* ICV size in bits, not used    */
    4,                        /* Block size in bytes           */
    0,                        /* Metadata size in bytes        */
    NX_NULL,                  /* Initialization routine,unused */
    NX_NULL,                  /* Cleanup routine, not used     */
    _nx_secure_crypto_method_null_operation  /* NULL operation  
*/
}; 
```
<span data-ttu-id="ac926-935">***HMAC-SHA1***</span><span class="sxs-lookup"><span data-stu-id="ac926-935">***HMAC-SHA1***</span></span>
```C
NX_CRYPTO_METHOD crypto_method_hmac_sha1 = 
{
    /* HMAC SHA1 algorithm                               */
    TLS_HASH_SHA1,            


    /* Key size in bits. For HMAC-SHA1 this value is 160 */ 
    NX_CRYPTO_HMAC_SHA1_KEY_LEN_IN_BITS,              

    /* IV size in bits, not used                         */
    0,                                            

    /* Transmitted ICV size in bits. Unused.             */
    0, 

    /* Block size in bytes, not used                     */
    0,                                            

    /* Metadata size in bytes                            */
    sizeof(NX_SHA1_HMAC),                                            

    /* Initialization routine, not used                  */
    NX_NULL,                                      

    /* Cleanup routine, not used                         */
    NX_NULL,                                          

    /* HMAC SHA1 operation                               */
    _nx_secure_crypto_method_hmac_sha1_operation   
};
```
<span data-ttu-id="ac926-936">***DAWAJ***</span><span class="sxs-lookup"><span data-stu-id="ac926-936">***NONE***</span></span>

<span data-ttu-id="ac926-937">Specjalna metoda **NX_CRYPTO_NONE** jest używana do sygnalizowania modułu IPSec, że szyfrowanie lub usługa uwierzytelniania nie jest wymagana.</span><span class="sxs-lookup"><span data-stu-id="ac926-937">A special method **NX_CRYPTO_NONE** is used to signal the IPsec module that the encryption or the authentication service is not required.</span></span> <span data-ttu-id="ac926-938">Jest on konfigurowany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="ac926-938">It is configured as follows:</span></span>

```C
/* NX_CRYPTO_NONE means encryption or authentication
   method is not needed.  */
NX_CRYPTO_METHOD crypto_method_none = 
{
    NX_CRYPTO_NONE,       /* Name of the crypto algorithm */
    0,                    /* Key size in bits, not used   */
    0,                    /* IV size in bits, not used    */
    0,                    /* ICV size in bits, not used   */
    0,                    /* Block size in bytes          */
    0,                    /* Metadata size in bytes       */
    NX_NULL,              /* Initialization routine, not used */
    NX_NULL,              /* Cleanup routine, not used    */
    NX_NULL               /* NULL operation               */
};                                               
```
### <a name="initializing-tls-with-cryptographic-methods"></a><span data-ttu-id="ac926-939">Inicjowanie protokołu TLS z metodami kryptograficznymi</span><span class="sxs-lookup"><span data-stu-id="ac926-939">Initializing TLS with Cryptographic Methods</span></span>

<span data-ttu-id="ac926-940">Po utworzeniu procedur kryptograficznych zgodnych z sygnaturami metod kryptograficznych opisanymi w poprzedniej sekcji należy przekazać je do protokołu TLS po zainicjowaniu bloku sterowania NX_SECURE_TLS_SESSION.</span><span class="sxs-lookup"><span data-stu-id="ac926-940">Once you have created your cryptographic routines conforming to the cryptographic method signatures described in the previous section, you will need to pass them into TLS when you initialize an NX_SECURE_TLS_SESSION control block.</span></span> <span data-ttu-id="ac926-941">Odbywa się to w nx_secure_tls_session_create usługi TLS:</span><span class="sxs-lookup"><span data-stu-id="ac926-941">This is done in the TLS service nx_secure_tls_session_create:</span></span>

```C
UINT  nx_secure_tls_session_create(
              NX_SECURE_TLS_SESSION*     session_ptr,
              const NX_SECURE_TLS_CRYPTO*    tls_cipher_table,
              VOID*                encryption_metadata_area,
              ULONG                 encryption_metadata_size
);
```
- <span data-ttu-id="ac926-942">session_pointer jest wskaźnikiem do bloku sterowania NX_SECURE_TLS_SESSION.</span><span class="sxs-lookup"><span data-stu-id="ac926-942">session_pointer is a pointer to your NX_SECURE_TLS_SESSION control block.</span></span>
- <span data-ttu-id="ac926-943">tls_cipher_table jest wskaźnikiem do bloku sterowania NX_SECURE_TLS_CRYPTO, opisanego poniżej.</span><span class="sxs-lookup"><span data-stu-id="ac926-943">tls_cipher_table is a pointer to an NX_SECURE_TLS_CRYPTO control block, described below.</span></span>
- <span data-ttu-id="ac926-944">encryption_metadata_area punkty do przestrzeni używanej przez procedury kryptograficzne w protokole TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-944">encryption_metadata_area points to space used by cryptographic routines in TLS.</span></span>
- <span data-ttu-id="ac926-945">encryption_metadata_size to rozmiar obszaru metadanych w bajtach.</span><span class="sxs-lookup"><span data-stu-id="ac926-945">encryption_metadata_size is the size of the metadata area in bytes.</span></span>

### <a name="elliptic-curve-cryptography-ecc-in-netx-secure-tls"></a><span data-ttu-id="ac926-946">Kryptografia krzywej eliptycznej (ECC) w NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-946">Elliptic Curve Cryptography (ECC) in NetX Secure TLS</span></span>

<span data-ttu-id="ac926-947">Kryptografia krzywej eliptycznej (ECC) zapewnia schemat kryptografii klucza publicznego, który może być używany zamiast RSA.</span><span class="sxs-lookup"><span data-stu-id="ac926-947">Elliptic Curve Cryptography (ECC) provides a public-key cryptography scheme that can be used instead of RSA.</span></span> <span data-ttu-id="ac926-948">Funkcja ECC jest zwykle szybsza i używa mniejszych kluczy niż RSA, więc może być cenną opcją dla osadzonego protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-948">ECC is typically faster and uses smaller keys than RSA so it can be a valuable option for embedded TLS.</span></span> <span data-ttu-id="ac926-949">W wersjach standardu X dla urządzeń z systemem Azure RTO 6,0, ECC został wysłany jako dodatek wymagający instalacji kodu źródłowego ECC do projektu.</span><span class="sxs-lookup"><span data-stu-id="ac926-949">In X-Ware versions prior to Azure RTOS 6.0, ECC was shipped as an add-on, requiring installation of the ECC source code into your project.</span></span> <span data-ttu-id="ac926-950">Usługa Azure RTO 6,0 Zintegrowana ECC z bazą kodu linii głównej w celu zainstalowania plików ECC nie jest już potrzebna.</span><span class="sxs-lookup"><span data-stu-id="ac926-950">Azure RTOS 6.0 integrated ECC into the mainline codebase so installation of the ECC files is no longer necessary.</span></span> <span data-ttu-id="ac926-951">Jednak ECC nadal wymaga takiego samego inicjalizacji jak w poprzednich wersjach.</span><span class="sxs-lookup"><span data-stu-id="ac926-951">However, ECC still requires the same initialization as those previous versions.</span></span>

### <a name="supported-ecc-curves"></a><span data-ttu-id="ac926-952">Obsługiwane krzywe ECC</span><span class="sxs-lookup"><span data-stu-id="ac926-952">Supported ECC curves</span></span>

<span data-ttu-id="ac926-953">NetX bezpiecznie implementuje części krzywych zgodnie z <http://www.secg.org/sec2-v2.pdf> .</span><span class="sxs-lookup"><span data-stu-id="ac926-953">NetX Secure implements parts of the curves as per <http://www.secg.org/sec2-v2.pdf>.</span></span> <span data-ttu-id="ac926-954">Thefollowing krzywe są obsługiwane<sup>18</sup>:</span><span class="sxs-lookup"><span data-stu-id="ac926-954">Thefollowing curves are supported<sup>18</sup>:</span></span>

  - <span data-ttu-id="ac926-955">secp256r1</span><span class="sxs-lookup"><span data-stu-id="ac926-955">secp256r1</span></span> 
  - <span data-ttu-id="ac926-956">secp384r1</span><span class="sxs-lookup"><span data-stu-id="ac926-956">secp384r1</span></span> 
  - <span data-ttu-id="ac926-957">secp521r1</span><span class="sxs-lookup"><span data-stu-id="ac926-957">secp521r1</span></span> 

<span data-ttu-id="ac926-958">Jeśli używane są inne krzywe ECC, procedura *nx_secure_tls_session_start ()* zwróci błąd NX_SECURE_TLS_NO_SUPPORTED_CIPHERS wskazujący, że użyto nieobsługiwanych krzywych.</span><span class="sxs-lookup"><span data-stu-id="ac926-958">If other ECC curves are used, the *nx_secure_tls_session_start()* routine will return the error NX_SECURE_TLS_NO_SUPPORTED_CIPHERS indicating that unsupported curves were used.</span></span>

<span data-ttu-id="ac926-959">Należy pamiętać, że łańcuch certyfikatów TLS może być zaszyfrowany również algorytmem ECC.</span><span class="sxs-lookup"><span data-stu-id="ac926-959">Note that TLS certificate chain may be encrypted by ECC-algorithms as well.</span></span> <span data-ttu-id="ac926-960">Chociaż krzywe dostarczone przez klienta TLS są obsługiwane, istnieje możliwość, że krzywa ECC używana w łańcuchu certyfikatów nie jest obsługiwana.</span><span class="sxs-lookup"><span data-stu-id="ac926-960">Even though the curves provided by the TLS Client are supported, it is possible that the ECC curve used in the certificate chain is not supported.</span></span> <span data-ttu-id="ac926-961">W takim przypadku procedura *nx_secure_tls_session_start* zwraca NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span><span class="sxs-lookup"><span data-stu-id="ac926-961">In this case, *nx_secure_tls_session_start* routine returns NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span></span>

<span data-ttu-id="ac926-962">Domyślny przykład tabeli ciphersuite dla ECC jest dostępny w nx_crypto_generic_ciphersuites. c.</span><span class="sxs-lookup"><span data-stu-id="ac926-962">A default ciphersuite table example for ECC is provided in nx_crypto_generic_ciphersuites.c.</span></span> <span data-ttu-id="ac926-963">Więcej informacji o tabelach ciphersuite można znaleźć w sekcji "tabela szyfrowania kryptograficznego protokołu TLS".</span><span class="sxs-lookup"><span data-stu-id="ac926-963">See section "TLS Cryptographic Cipher Table" for more information on ciphersuite tables.</span></span>

18. <span data-ttu-id="ac926-964">Należy zauważyć, że implementacje dla krzywych secp192r1 i secp224r1are są również udostępniane dla starszych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-964">Note that implementations for the curves secp192r1 and secp224r1are also provided for legacy applications.</span></span> <span data-ttu-id="ac926-965">Jednak te krzywe są teraz uważane za słabe i nie powinny być używane do tworzenia nowych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-965">However these curves are now considered weak and SHOULD NOT be used for new application development.</span></span>

### <a name="crypto-methods-for-ecc"></a><span data-ttu-id="ac926-966">Metody kryptograficzne dla ECC</span><span class="sxs-lookup"><span data-stu-id="ac926-966">Crypto Methods for ECC</span></span>

<span data-ttu-id="ac926-967">Metody kryptograficzne dla grup krzywej eliptyczna:</span><span class="sxs-lookup"><span data-stu-id="ac926-967">Crypto methods for Elliptic Curve groups:</span></span>

- <span data-ttu-id="ac926-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span><span class="sxs-lookup"><span data-stu-id="ac926-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span></span>  
- <span data-ttu-id="ac926-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span><span class="sxs-lookup"><span data-stu-id="ac926-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span></span>  
- <span data-ttu-id="ac926-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span><span class="sxs-lookup"><span data-stu-id="ac926-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span></span>  
- <span data-ttu-id="ac926-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span><span class="sxs-lookup"><span data-stu-id="ac926-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span></span>  
- <span data-ttu-id="ac926-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span><span class="sxs-lookup"><span data-stu-id="ac926-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span></span>

<span data-ttu-id="ac926-973">Metody kryptograficzne dla krzywych ECC są zdefiniowane w nx_crypto_generic_ciphersuites. c.</span><span class="sxs-lookup"><span data-stu-id="ac926-973">The crypto methods for ECC curves are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="ac926-974">Metoda kryptograficzna dla ECDHE:</span><span class="sxs-lookup"><span data-stu-id="ac926-974">Crypto method for ECDHE:</span></span>

- <span data-ttu-id="ac926-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span><span class="sxs-lookup"><span data-stu-id="ac926-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span></span>

<span data-ttu-id="ac926-976">Metoda kryptograficzna dla ECDSA:</span><span class="sxs-lookup"><span data-stu-id="ac926-976">Crypto method for ECDSA:</span></span>

- <span data-ttu-id="ac926-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span><span class="sxs-lookup"><span data-stu-id="ac926-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span></span>

<span data-ttu-id="ac926-978">Metody kryptograficzne ECDSA i ECDHE są zdefiniowane w nx_crypto_generic_ciphersuites. c.</span><span class="sxs-lookup"><span data-stu-id="ac926-978">ECDSA and ECDHE crypto methods are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="ac926-979">W połączeniu z innymi metodami kryptograficznymi, takimi jak RSA, SHA i AES, można używać ich jako bloków konstrukcyjnych dla tabeli odnośników ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="ac926-979">Combined with other crypto methods such as RSA, SHA, AES, they can be used as building blocks for the ciphersuite lookup table.</span></span>

### <a name="enabling-ecc-support-for-tls"></a><span data-ttu-id="ac926-980">Włączanie obsługi protokołu TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-980">Enabling ECC Support for TLS</span></span>

<span data-ttu-id="ac926-981">Funkcja ECC jest domyślnie włączona w przypadku protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-981">ECC is enabled by default for TLS.</span></span> <span data-ttu-id="ac926-982">Aby wyłączyć obsługę ECC, należy zdefiniować symbol NX_SECURE_DISABLE_ECC_CIPHERSUITE.</span><span class="sxs-lookup"><span data-stu-id="ac926-982">To disable ECC support, the symbol NX_SECURE_DISABLE_ECC_CIPHERSUITE must be defined.</span></span>

<span data-ttu-id="ac926-983">Aby zmiana zaczęła obowiązywać, należy ponownie skompilować bezpieczną bibliotekę NetX i wszystkie aplikacje używające tej biblioteki.</span><span class="sxs-lookup"><span data-stu-id="ac926-983">For the change to take effect, you will need to rebuild the NetX Secure Library and all applications that use that library.</span></span>

<span data-ttu-id="ac926-984">W kodzie aplikacji interfejs API n *x_secure_tls_ecc_initialize ()* musi zostać wywołany po utworzeniu sesji TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-984">In the application code, the API n *x_secure_tls_ecc_initialize()* must be called after the TLS session is created.</span></span> <span data-ttu-id="ac926-985">Ten interfejs API powiadamia sesję protokołu TLS o typie krzywych, które mają być używane na potrzeby operacji wymiany kluczy TLS i weryfikacji certyfikatu.</span><span class="sxs-lookup"><span data-stu-id="ac926-985">This API notifies the TLS session of the type of curves to be used for TLS key exchange operations and certificate verification.</span></span> <span data-ttu-id="ac926-986">W fazie uzgadniania protokołu TLS, jeśli wybrano algorytm ECC dla klienta i serwera, parametry powiązane z krzywą ECC, aby określić, która krzywa ma być używana.</span><span class="sxs-lookup"><span data-stu-id="ac926-986">During the TLS handshake phase, if an ECC algorithm is selected the client and server exchange ECC curve-related parameters to decide which curve to use.</span></span>

<span data-ttu-id="ac926-987">Poniższy segment kodu ilustruje sposób korzystania z interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="ac926-987">The following code segment illustrates how to use the API.</span></span> <span data-ttu-id="ac926-988">Należy zauważyć, że argumenty (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size i nx_crypto_ecc_curves)* są zdefiniowane w *nx_crypto_generic_ciphersuites. c*.</span><span class="sxs-lookup"><span data-stu-id="ac926-988">Note that the arguments (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size, and nx_crypto_ecc_curves)* are all defined in *nx_crypto_generic_ciphersuites.c*.</span></span> <span data-ttu-id="ac926-989">W związku z tym te symbole mogą być używane bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="ac926-989">Therefore these symbols can be used directly.</span></span>

```C
status = nx_secure_tls_ecc_initialize(&tls_session,     
                    nx_crypto_ecc_supported_groups,      
                    nx_crypto_ecc_supported_groups_size,     
                    nx_crypto_ecc_curves);
```
<span data-ttu-id="ac926-990">Przykładowa konfiguracja w nx_crypto_generic_ciphersuites. c zawiera tabelę odnośników ciphersuite ECC, która jest używana, gdy włączono funkcję ECC.</span><span class="sxs-lookup"><span data-stu-id="ac926-990">The example configuration in nx_crypto_generic_ciphersuites.c contains an ECC ciphersuite lookup table that is used when ECC is enabled.</span></span> <span data-ttu-id="ac926-991">Aby używać ECC, po prostu Przekaż nx_crypto_tls_ciphers_ecc jako parametr tabeli ciphersuite podczas tworzenia sesji protokołu TLS z nx_secure_tls_session_create.</span><span class="sxs-lookup"><span data-stu-id="ac926-991">To use ECC, simply pass nx_crypto_tls_ciphers_ecc as the ciphersuite table parameter when creating TLS sessions with nx_secure_tls_session_create.</span></span> <span data-ttu-id="ac926-992">Przykładowa tabela zawiera dane ECC i ciphersuites bez ECC.</span><span class="sxs-lookup"><span data-stu-id="ac926-992">The example table contains both ECC and non-ECC ciphersuites.</span></span>

### <a name="tls-cryptographic-cipher-table"></a><span data-ttu-id="ac926-993">Tabela szyfrowania kryptograficznego TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-993">TLS Cryptographic Cipher Table</span></span>

<span data-ttu-id="ac926-994">Struktura NX_SECURE_TLS_CRYPTO jest definiowana jako:</span><span class="sxs-lookup"><span data-stu-id="ac926-994">The NX_SECURE_TLS_CRYPTO structure is defined as:</span></span>

```C
typedef struct NX_SECURE_METHODS_STRUCT
{
    /* Table that maps ciphersuites to crypto methods. */
    NX_SECURE_TLS_CIPHERSUITE_INFO* nx_secure_tls_ciphersuite_lookup_table;
    USHORT nx_secure_tls_ciphersuite_lookup_table_size;

    /* Table that maps X.509 cipher identifiers to crypto methods. */
    NX_SECURE_X509_CRYPTO *nx_secure_tls_x509_cipher_table;
    USHORT nx_secure_tls_x509_cipher_table_size;

    /* Specific routines needed for specific TLS versions. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_md5_method;
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha1_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_1_method;
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha256_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_sha256_method;
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    const NX_CRYPTO_METHOD *nx_secure_tls_hkdf_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_hmac_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_ecdhe_method;
#endif

} NX_SECURE_TLS_CRYPTO;
```
<span data-ttu-id="ac926-995">Tabela jest tworzona przez wypełnienie wpisów dla tej struktury w stałej statycznej znajdującej się w projekcie NetX Secure TLS, zazwyczaj znajdującym się w procedurach i modułach kryptograficznych.</span><span class="sxs-lookup"><span data-stu-id="ac926-995">The table is created by filling in the entries for this structure in a static constant located within the NetX Secure TLS project, usually located with the cryptographic routines and modules.</span></span>

<span data-ttu-id="ac926-996">Przykładowo Biblioteka kryptograficzna ("generyczna") oparta na oprogramowaniu NetX Secure zawiera następującą definicję tabeli (w przypadku usługi non-ECC ciphersuite support<sup>19</sup>):</span><span class="sxs-lookup"><span data-stu-id="ac926-996">As an example, the software-only ("generic") cryptographic library provided with NetX Secure contains the following table definition (for non-ECC ciphersuite support<sup>19</sup>):</span></span>

```C
/* Define the cipher table object we can pass into TLS. */
const NX_SECURE_TLS_CRYPTO nx_crypto_tls_ciphers =
{
    /* TLS Ciphersuite lookup table and size. */
    _nx_crypto_ciphersuite_lookup_table,
    sizeof(_nx_crypto_ciphersuite_lookup_table) / 
    sizeof(NX_SECURE_TLS_CIPHERSUITE_INFO),

    /* X.509 certificate cipher table and size. */
    _nx_crypto_x509_cipher_lookup_table,
    sizeof(_nx_crypto_x509_cipher_lookup_table) / sizeof(NX_SECURE_X509_CRYPTO),

    /* TLS version-specific methods. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    &crypto_method_md5,
    &crypto_method_sha1,
    &crypto_method_tls_prf_1,
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    &crypto_method_sha256,
    &crypto_method_tls_prf_sha_256
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    &crypto_method_hkdf,
    &crypto_method_hmac,
    &crypto_method_ecdhe,
#endif
};
```
<span data-ttu-id="ac926-997">W strukturze pierwszy wpis jest tabelą ciphersuite TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-997">In the structure, the first entry is the TLS ciphersuite table.</span></span> <span data-ttu-id="ac926-998">Struktura NX_SECURE_TLS_CIPHERSUITE_INFO mapuje procedury kryptograficzne (w formie wskaźników NX_CRYPTO_METHOD) do określonych ciphersuites zgodnie z definicją w specyfikacji TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-998">The NX_SECURE_TLS_CIPHERSUITE_INFO structure maps cryptographic routines (in the form of NX_CRYPTO_METHOD pointers) to specific ciphersuites as defined in the TLS specifications.</span></span> <span data-ttu-id="ac926-999">Druga wartość to liczba wpisów w tabeli wskazywanych przez pierwsze pole.</span><span class="sxs-lookup"><span data-stu-id="ac926-999">The second value is the number of entries in the table pointed to by the first field.</span></span>

<span data-ttu-id="ac926-1000">Następne pole wskazuje tabelę procedur używanych przez X. 509 podczas przetwarzania certyfikatów cyfrowych i struktura NX_SECURE_X509_CRYPTO jest podobna w formularzu, aby NX_SECURE_TLS_CIPHERSUITE_INFO.</span><span class="sxs-lookup"><span data-stu-id="ac926-1000">The next field points to a table of routines used by X.509 when processing digital certificates and the structure NX_SECURE_X509_CRYPTO is similar in form to NX_SECURE_TLS_CIPHERSUITE_INFO.</span></span> <span data-ttu-id="ac926-1001">Następujące pole jest liczbą wpisów w tabeli.</span><span class="sxs-lookup"><span data-stu-id="ac926-1001">The following field is the number of entries in the table.</span></span>

<span data-ttu-id="ac926-1002">W poniższej tabeli odnośników przedstawiono różne procedury dla określonych wersji protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-1002">Following the lookup table are a number of routines needed for specific versions of TLS.</span></span> <span data-ttu-id="ac926-1003">Na przykład przed protokołem TLS w wersji 1,2 procedury generowania kluczy i wyznaczania wartości skrótu zostały naprawione w celu użycia kombinacji algorytmu SHA-1 i MD5 — metody dla tych procedur są wywoływane w odniesieniu do struktury szyfru, ponieważ nie są one powiązane z konkretną ciphersuites.</span><span class="sxs-lookup"><span data-stu-id="ac926-1003">For example, prior to TLS version 1.2, the key generation and handshake hashing routines were fixed to use a combination of SHA-1 and MD5 – the methods for these routines are called out specifically in the cipher structure since they are not tied to specific ciphersuites.</span></span> <span data-ttu-id="ac926-1004">W przypadku protokołu TLS w wersji 1,2 są wybierane procedury generowania kluczy i wyznaczania wartości skrótu przez ciphersuite, ale dla ciphersuites, które nie określają procedur do użycia, używana jest metoda mieszania SHA-256, a struktura szyfru wywołuje tę procedurę w specjalny sposób.</span><span class="sxs-lookup"><span data-stu-id="ac926-1004">In TLS version 1.2, the key generation and hashing routines are chosen by the ciphersuite, but for ciphersuites which do not specify the routines to use, the SHA-256 hash method is used, and the cipher structure calls out that routine specifically.</span></span>

<span data-ttu-id="ac926-1005">Protokół TLS 1,3 wymaga kilku dodatkowych szyfrów dla różnych operacji.</span><span class="sxs-lookup"><span data-stu-id="ac926-1005">TLS 1.3 requires a few extra specific ciphers for various operations.</span></span>

19. <span data-ttu-id="ac926-1006">Należy pamiętać, że obsługa protokołu TLS 1,3 wymaga ECC — Użyj nx_crypto_tls_ciphers_ecc, jeśli włączona jest funkcja TLS 1,3.</span><span class="sxs-lookup"><span data-stu-id="ac926-1006">Note that TLS 1.3 support requires ECC – use nx_crypto_tls_ciphers_ecc if TLS 1.3 is enabled.</span></span>

### <a name="tls-ciphersuite-lookup-table"></a><span data-ttu-id="ac926-1007">Tabela wyszukiwania Ciphersuite TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-1007">TLS Ciphersuite Lookup Table</span></span>

<span data-ttu-id="ac926-1008">Aby wypełnić tabelę szyfrowania dla protokołu TLS, należy również utworzyć tabelę odnośników ciphersuite, która mapuje procedury kryptograficzne na określone identyfikatory ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="ac926-1008">To fill in the cipher table for TLS, you will also need to create a ciphersuite lookup table that maps cryptographic routines to specific ciphersuite identifiers.</span></span> <span data-ttu-id="ac926-1009">Identyfikatory są wartościami zarejestrowanymi przez organizację IANA, które są uniwersalne.</span><span class="sxs-lookup"><span data-stu-id="ac926-1009">The identifiers are IANA-registered values that are universal.</span></span> <span data-ttu-id="ac926-1010">Aby uzyskać więcej informacji, zobacz specyfikacje RFC protokołu TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-1010">See the TLS RFCs for more information.</span></span> <span data-ttu-id="ac926-1011">Procedury przedstawiają 5 oddzielnych metod używanych w każdym ciphersuite (niektóre ciphersuites mogą nie używać wszystkich 5): szyfrowanie publiczne, uwierzytelnianie klucza publicznego, szyfrowanie sesji, procedura skrótu sesji i funkcja TLS Pseudo-Random funkcji (PRF).</span><span class="sxs-lookup"><span data-stu-id="ac926-1011">The routines represent the 5 separate methods used in each ciphersuite (some ciphersuites may not use all 5): public cipher, public-key authentication, session cipher, session hash routine, and TLS Pseudo-Random Function (PRF).</span></span> <span data-ttu-id="ac926-1012">W poniższej tabeli opisano każdą z 5 metod:</span><span class="sxs-lookup"><span data-stu-id="ac926-1012">The following table explains each of the 5 methods:</span></span>

| <span data-ttu-id="ac926-1013">**Kategoria rutynowa**</span><span class="sxs-lookup"><span data-stu-id="ac926-1013">**Routine category**</span></span>      | <span data-ttu-id="ac926-1014">**Opis**</span><span class="sxs-lookup"><span data-stu-id="ac926-1014">**Description**</span></span>                                                                                       | <span data-ttu-id="ac926-1015">**Przykładowe algorytmy**</span><span class="sxs-lookup"><span data-stu-id="ac926-1015">**Example algorithms**</span></span>                                            |
| ------------------------- | ----------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| <span data-ttu-id="ac926-1016">Szyfrowanie publiczne</span><span class="sxs-lookup"><span data-stu-id="ac926-1016">Public cipher</span></span>             | <span data-ttu-id="ac926-1017">Używane do wymiany kluczy podczas uzgadniania protokołu TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-1017">Used to exchange keys during the TLS handshake</span></span>                                                        | <span data-ttu-id="ac926-1018">RSA, Diffie-Hellmana, ECC</span><span class="sxs-lookup"><span data-stu-id="ac926-1018">RSA, Diffie-Hellman, ECC</span></span>                                          |
| <span data-ttu-id="ac926-1019">Uwierzytelnianie klucza publicznego</span><span class="sxs-lookup"><span data-stu-id="ac926-1019">Public-key authentication</span></span> | <span data-ttu-id="ac926-1020">Służy do uwierzytelniania lub podpisywania danych podczas uzgadniania protokołu TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-1020">Used to authenticate or sign data during the TLS handshake</span></span>                                            | <span data-ttu-id="ac926-1021">RSA, DSS</span><span class="sxs-lookup"><span data-stu-id="ac926-1021">RSA, DSS</span></span>                                                          |
| <span data-ttu-id="ac926-1022">Szyfr sesji</span><span class="sxs-lookup"><span data-stu-id="ac926-1022">Session cipher</span></span>            | <span data-ttu-id="ac926-1023">Algorytm klucza symetrycznego służący do szyfrowania danych aplikacji podczas sesji TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-1023">Symmetric-key algorithm used to encrypt application data during the TLS session</span></span>                       | <span data-ttu-id="ac926-1024">AES, RC4</span><span class="sxs-lookup"><span data-stu-id="ac926-1024">AES, RC4</span></span>                                                          |
| <span data-ttu-id="ac926-1025">Skrót sesji</span><span class="sxs-lookup"><span data-stu-id="ac926-1025">Session hash</span></span>              | <span data-ttu-id="ac926-1026">Służy do zachowania integralności komunikatów w trakcie sesji TLS (gwarantuje, że dane nie uległy zmianie)</span><span class="sxs-lookup"><span data-stu-id="ac926-1026">Used to preserve the integrity of messages during the TLS session (assures that data has not changed)</span></span> | <span data-ttu-id="ac926-1027">SHA-1, SHA-256</span><span class="sxs-lookup"><span data-stu-id="ac926-1027">SHA-1, SHA-256</span></span>                                                    |
| <span data-ttu-id="ac926-1028">PRF TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-1028">TLS PRF</span></span>                   | <span data-ttu-id="ac926-1029">Używane do generowania materiału klucza i w skrócie uzgadniania w uzgadnianiu protokołu TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-1029">Used to generate key material and in the handshake hash in the TLS handshake</span></span>                          | <span data-ttu-id="ac926-1030">PRF jest oparty na procedurach skrótu — SHA-1 + MD5, SHA-256, SHA-512</span><span class="sxs-lookup"><span data-stu-id="ac926-1030">The PRF is based on hash routines – SHA-1 + MD5, SHA-256, SHA-512</span></span> |

<span data-ttu-id="ac926-1031">Struktura NX_SECURE_TLS_CIPHERSUITE_INFO jest definiowana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="ac926-1031">The NX_SECURE_TLS_CIPHERSUITE_INFO structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_TLS_CIPHERSUITE_INFO_struct
{
    /* The IANA value of the ciphersuite as defined by the TLS spec.*/
    USHORT nx_secure_tls_ciphersuite;

    /* The Public Key operation in this suite - RSA or DH. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_cipher;

    /* The Public Authentication method used for signing data. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_auth;

    /* The session cipher being used - AES, RC4, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_session_cipher;

    /* The size of the initialization vectors for the session cipher (bytes).*/
    USHORT nx_secure_tls_iv_size;

    /* The key size for the session cipher (bytes). */
    UCHAR nx_secure_tls_session_key_size;

    /* The hash being used - MD5, SHA-1, SHA-256, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_hash;

    /* The size of the hash being used. SHA-1 is 20 bytes, MD5 is 16 bytes.*/
    USHORT nx_secure_tls_hash_size;

    /* The TLS PRF being used – this is only for TLSv1.2. */
    NX_CRYPTO_METHOD *nx_secure_tls_prf;

} NX_SECURE_TLS_CIPHERSUITE_INFO;
```
<span data-ttu-id="ac926-1032">Pole nx_secure_tls_ciphersuite zawiera wartość ciphersuite organizacji IANA, a wskaźniki NX_CRYPTO_METHOD przedstawiają 5 metod używanych przez ten ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="ac926-1032">The nx_secure_tls_ciphersuite field contains the IANA ciphersuite value, and the NX_CRYPTO_METHOD pointers represent the 5 methods used by that ciphersuite.</span></span> <span data-ttu-id="ac926-1033">Wartości skalarne (nx_secure_tls_iv_size, nx_secure_tls_key_size i nx_secure_tls_hash_size) są informacyjne, dostarczając informacje, które mogą nie być dostępne w wpisach NX_CRYPTO_METHOD.</span><span class="sxs-lookup"><span data-stu-id="ac926-1033">The scalar values (nx_secure_tls_iv_size, nx_secure_tls_key_size, and nx_secure_tls_hash_size) are informational, providing information that might not be available in the NX_CRYPTO_METHOD entries.</span></span>

<span data-ttu-id="ac926-1034">Na przykład będziemy szukać domyślnego ciphersuite dla protokołu TLS TLS_RSA_WITH_AES_128_CBC_SHA, który określa użycie RSA, AES-CBC z kluczami 128-bitowymi i algorytm SHA-1 na potrzeby tworzenia skrótów sesji.</span><span class="sxs-lookup"><span data-stu-id="ac926-1034">As an example, we will look at the default ciphersuite for TLS, TLS_RSA_WITH_AES_128_CBC_SHA, which specifies the use of RSA, AES-CBC with 128-bit keys, and SHA-1 for session hashing.</span></span> <span data-ttu-id="ac926-1035">Nie określono PRF TLS dla tego ciphersuite, więc w trybie TLSv 1.2 zostanie użyty domyślny PRF SHA-256.</span><span class="sxs-lookup"><span data-stu-id="ac926-1035">No TLS PRF is specified for this ciphersuite, so in TLSv1.2 mode, it will use the default SHA-256 PRF.</span></span> <span data-ttu-id="ac926-1036">Należy pamiętać, że wszystkie ciphersuites używają algorytmu SHA-1 + MD5 PRF w protokole TLS 1,0 i 1,1, niezależnie od PRF określonych w tabeli.</span><span class="sxs-lookup"><span data-stu-id="ac926-1036">Note that all ciphersuites use the SHA-1+MD5 PRF in TLS 1.0 and 1.1, regardless of the PRF specified in the table.</span></span>

<span data-ttu-id="ac926-1037">Wpis w tabeli NX_SECURE_TLS_CIPHERSUITE_INFO w ogólnej bibliotece kryptograficznej jest definiowany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="ac926-1037">The entry in the NX_SECURE_TLS_CIPHERSUITE_INFO table in the generic cryptographic library is defined as follows:</span></span>

```C
{ 
  TLS_RSA_WITH_AES_128_CBC_SHA,     /* Ciphersuite identifier */
  &crypto_method_rsa,               /* Public-key cipher (NX_CRYPTO_METHOD)*/
  &crypto_method_rsa,               /* Authentication method(NX_CRYPTO_METHOD)*/
  &crypto_method_aes_cbc_128,       /* Session cipher method(NX_CRYPTO_METHOD)*/
  16,                               /* Session cipher IV size in bytes */
  16,                               /* Session cipher key size in bytes */
  &crypto_method_hmac_sha1,         /* Session hash routine(NX_CRYPTO_METHOD) */
  20,                               /* Session hash output size in bytes */
  &crypto_method_tls_prf_sha_256    /* TLSv1.2 PRF */
},
```

<span data-ttu-id="ac926-1038">Należy pamiętać, że w przypadku szyfrowania sesji rozmiar klucza jest określany przez ciphersuite, ale w przypadku metod klucza publicznego rozmiar klucza nie jest znany, dopóki uzgadnianie protokołu TLS nie będzie możliwe, ponieważ klucze publiczne są zawarte w certyfikatach cyfrowych wymienianych podczas uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-1038">Note that for the session cipher the key size is determined by the ciphersuite, but for the public-key methods the key size is not known until the TLS handshake is underway since the public keys are contained in the digital certificates exchanged during the handshake.</span></span>

### <a name="x509-cipher-lookup-table"></a><span data-ttu-id="ac926-1039">Tabela odnośników szyfrowania X. 509</span><span class="sxs-lookup"><span data-stu-id="ac926-1039">X.509 Cipher Lookup Table</span></span>

<span data-ttu-id="ac926-1040">Podobnie jak w przypadku tabeli NX_SECURE_TLS_CIPHERSUITE_INFO, struktura NX_SECURE_X509_CRYPTO mapuje procedury kryptograficzne na znane wartości.</span><span class="sxs-lookup"><span data-stu-id="ac926-1040">Like the NX_SECURE_TLS_CIPHERSUITE_INFO table, the NX_SECURE_X509_CRYPTO structure maps cryptographic routines to known values.</span></span> <span data-ttu-id="ac926-1041">W przypadku X. 509 identyfikatory są faktycznie identyfikatorami OID zdefiniowanymi przez X. 509 i zarejestrowane w instytucjach normalizacyjnych ISO i ITU.</span><span class="sxs-lookup"><span data-stu-id="ac926-1041">In the case of X.509, the identifiers are actually OIDs defined by X.509 and registered with the ISO and ITU standards bodies.</span></span> <span data-ttu-id="ac926-1042">Identyfikatory OID są wartościami wielobajtowymi o zmiennej długości zaprojektowanych do unikatowego identyfikowania różnych informacji w różnych standardach telekomunikacyjnych, w tym procedur kryptograficznych używanych w certyfikatach cyfrowych.</span><span class="sxs-lookup"><span data-stu-id="ac926-1042">OIDs are variable-length multi-byte values designed to uniquely identify various information in various telecommunication standards, including cryptographic routines used in digital certificates.</span></span> <span data-ttu-id="ac926-1043">Ze względu na fakt, że identyfikatory OID mają zmienną długość, NetX Secure TLS mapuje oficjalne wartości identyfikatorów OID na stałe o stałej długości, które są używane wewnętrznie (patrz nx_secure_x509. h).</span><span class="sxs-lookup"><span data-stu-id="ac926-1043">Due to the fact that OIDs are variable length, NetX Secure TLS maps the official OID values to fixed-length constants that are used internally (see nx_secure_x509.h).</span></span> <span data-ttu-id="ac926-1044">Te stałe są używane w strukturze NX_SECURE_X509_CRYPTO, która jest zdefiniowana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="ac926-1044">These constants are used in the NX_SECURE_X509_CRYPTO structure, which is defined as follows:</span></span>

```C
/* Structure to hold X.509 cryptographic routine information. */
typedef struct NX_SECURE_X509_CRYPTO_struct
{
    /* Internal NetX Secure identifier for certificate "ciphersuite" which consists
       of a hash and a public key operation. These can be mapped to OIDs in X.509.
        */
    USHORT nx_secure_x509_crypto_identifier;

    /* Public-Key Cryptographic method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_public_cipher_method;

    /* Hash method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_hash_method;
} NX_SECURE_X509_CRYPTO;
```

<span data-ttu-id="ac926-1045">Pierwsze pole, *nx_secure_x509_crypto_identifier*, to Wewnętrzna reprezentacja identyfikatorów OID używana przez NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="ac926-1045">The first field, *nx_secure_x509_crypto_identifier*, is the internal OID representation used by NetX Secure.</span></span>

<span data-ttu-id="ac926-1046">Drugie i trzecie pola wskazują na NX_CRYPTO_METHOD obiektów, które reprezentują metody kryptograficzne identyfikowane przez OID, operacja klucza publicznego sparowana z procedurą skrótu.</span><span class="sxs-lookup"><span data-stu-id="ac926-1046">The second and third fields point to NX_CRYPTO_METHOD objects that represent the cryptographic methods identified by the OID, a public-key operation paired with a hash routine.</span></span> <span data-ttu-id="ac926-1047">Należy pamiętać, że każdy certyfikat cyfrowy może mieć więcej niż jeden identyfikator OID dla procedur kryptograficznych.</span><span class="sxs-lookup"><span data-stu-id="ac926-1047">Note that each digital certificate may have more than one OID for cryptographic routines.</span></span>

<span data-ttu-id="ac926-1048">Tabela metod dla X. 509 jest zbudowana w taki sam sposób jak w przypadku tabeli odnośników ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="ac926-1048">The method table for X.509 is constructed in the same manner as the ciphersuite lookup table.</span></span> <span data-ttu-id="ac926-1049">Na przykład poszukamy identyfikatora OID dla RSA_SHA1.</span><span class="sxs-lookup"><span data-stu-id="ac926-1049">As an example, we will look at the OID for RSA_SHA1.</span></span> <span data-ttu-id="ac926-1050">Rzeczywisty identyfikator OID dla RSA_SHA1 jest następujący:</span><span class="sxs-lookup"><span data-stu-id="ac926-1050">The actual OID for RSA_SHA1 is as follows:</span></span>

```C
{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha1-with-rsa-
signature(5)}
```
<span data-ttu-id="ac926-1051">Identyfikator OID jest reprezentowany w składni ASN. 1 i ma wartość liczbową 1.2.840.113549.1.1.5.</span><span class="sxs-lookup"><span data-stu-id="ac926-1051">The OID is represented in ASN.1 syntax and has a numeric value of 1.2.840.113549.1.1.5.</span></span> <span data-ttu-id="ac926-1052">Ta wartość jest następnie zakodowana w formacie binarnym, tworząc następujące bajty:</span><span class="sxs-lookup"><span data-stu-id="ac926-1052">This value is then encoded in binary format, creating the following bytes:</span></span>

```C
UCHAR RSA_SHA1_OID = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05 };
```
<span data-ttu-id="ac926-1053">Rzeczywista konwersja z ASN. 1 do formatu binarnego wykracza poza zakres tego dokumentu.</span><span class="sxs-lookup"><span data-stu-id="ac926-1053">The actual conversion from ASN.1 to the binary format is beyond the scope of this document.</span></span> <span data-ttu-id="ac926-1054">Aby uzyskać więcej informacji, Wyszukaj numer ASN. 1 dla identyfikatorów OID.</span><span class="sxs-lookup"><span data-stu-id="ac926-1054">Search for ASN.1 encodings for OIDs for more information.</span></span> <span data-ttu-id="ac926-1055">Reprezentację binarną identyfikatorów OID obsługiwanych przez NetX można znaleźć w pliku *nx_secure_x509. c*.</span><span class="sxs-lookup"><span data-stu-id="ac926-1055">The binary representation of the OIDs supported by NetX Secure can be found in the file *nx_secure_x509.c*.</span></span>

<span data-ttu-id="ac926-1056">Gdy mamy mapowanie rzeczywistego identyfikatora OID na stałą rozpoznawaną wewnętrznie, możemy utworzyć wpis dla RSA_SHA1 w tabeli NX_SECURE_X509_CRYPTO:</span><span class="sxs-lookup"><span data-stu-id="ac926-1056">Once we have a mapping of the actual OID to an internally-recognized constant, we can create an entry for RSA_SHA1 in the NX_SECURE_X509_CRYPTO table:</span></span>

```C
{ 
    NX_SECURE_TLS_X509_TYPE_RSA_SHA_1,    /* Internal OID constant. */
    &crypto_method_rsa,                   /* RSA method (NX_CRYPTO_METHOD). */ 
    &crypto_method_sha1                   /* SHA-1 method (NX_CRYPTO_METHOD). */
}, 
```
### <a name="default-tls-routines"></a><span data-ttu-id="ac926-1057">Domyślne procedury protokołu TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-1057">Default TLS Routines</span></span>

<span data-ttu-id="ac926-1058">Jak wspomniano powyżej, protokół TLS wymaga pewnych domyślnych procedur do generowania kluczy i weryfikacji komunikatów podczas uzgadniania.</span><span class="sxs-lookup"><span data-stu-id="ac926-1058">As mentioned above, TLS requires some default routines for key generation and message verification during the handshake.</span></span> <span data-ttu-id="ac926-1059">Podstawową procedurą jest funkcja Pseudo-Random TLS lub PRF.</span><span class="sxs-lookup"><span data-stu-id="ac926-1059">The primary routine is the TLS Pseudo-Random Function, or PRF.</span></span> <span data-ttu-id="ac926-1060">PRF opiera się na procedurach skrótu i może służyć do generowania dowolnej ilości danych pseudo-losowych<sup>20</sup> dla generacji kluczy lub innych celów.</span><span class="sxs-lookup"><span data-stu-id="ac926-1060">The PRF is based on hash routines and can be used to generate an arbitrary amount of pseudo-random data<sup>20</sup> for key generation or other purposes.</span></span>

<span data-ttu-id="ac926-1061">Oprócz PRF każda wersja protokołu TLS wykorzystuje domyślne procedury skrótu, które również muszą być dostarczone.</span><span class="sxs-lookup"><span data-stu-id="ac926-1061">In addition to the PRF, each version of TLS utilizes default hash routines that also need to be provided.</span></span> <span data-ttu-id="ac926-1062">W przypadku protokołu TLS w wersji 1,0 i 1,1 te procedury mieszania są MD5 i SHA-1.</span><span class="sxs-lookup"><span data-stu-id="ac926-1062">For TLS versions 1.0 and 1.1, those hash routines are MD5 and SHA-1.</span></span> <span data-ttu-id="ac926-1063">Protokół TLS w wersji 1,2 wymaga tylko algorytmu SHA-256.</span><span class="sxs-lookup"><span data-stu-id="ac926-1063">TLS version 1.2 requires only SHA-256.</span></span>

<span data-ttu-id="ac926-1064">W strukturze NX_SECURE_TLS_CRYPTO istnieją NX_CRYPTO_METHOD wskaźniki dla algorytmu MD5, SHA-1, SHA-256, protokołu TLS w wersji 1.0/1.1 PRF oraz domyślnego protokołu TLS 1,2 PRF.</span><span class="sxs-lookup"><span data-stu-id="ac926-1064">In the NX_SECURE_TLS_CRYPTO structure, there are NX_CRYPTO_METHOD pointers for MD5, SHA-1, SHA-256, the TLS version 1.0/1.1 PRF, and the default TLS 1.2 PRF.</span></span>

<span data-ttu-id="ac926-1065">Obsługa protokołu TLS 1,3 dodaje pola do HKDF (generowanie klucza), HMAC (dla określonych operacji tworzenia skrótów używanych podczas uzgadniania) i ECDHE (wymagane dla funkcji TLS 1,3).</span><span class="sxs-lookup"><span data-stu-id="ac926-1065">TLS 1.3 support adds fields for HKDF (key generation), HMAC (for specific hashing operations used during the handshake) and ECDHE (required for TLS 1.3 functionality).</span></span>

<span data-ttu-id="ac926-1066">Udostępnione w ogólnej bibliotece kryptografii oprogramowania są wersjami oprogramowania PRF TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-1066">Provided in the generic software cryptography library are software versions of the TLS PRF.</span></span> <span data-ttu-id="ac926-1067">W przypadku protokołu TLS 1.0/1.1 Ta funkcja jest wywoływana *nx_crypto_tls_prf_1*.</span><span class="sxs-lookup"><span data-stu-id="ac926-1067">For TLS 1.0/1.1, this function is called *nx_crypto_tls_prf_1*.</span></span> <span data-ttu-id="ac926-1068">W przypadku protokołu TLS 1,2 funkcja jest wywoływana *nx_secure_tls_prf_sha256*.</span><span class="sxs-lookup"><span data-stu-id="ac926-1068">For TLS 1.2, the function is called *nx_secure_tls_prf_sha256*.</span></span> <span data-ttu-id="ac926-1069">Sufiks "1" reprezentuje starszą wersję protokołu TLS 1,0 PRF, a sufiks "SHA256" odnosi się do faktu, że wartość domyślna PRF protokołu TLS 1,2 jest oparta na algorytmie SHA-256.</span><span class="sxs-lookup"><span data-stu-id="ac926-1069">The suffix "1" represents the legacy TLS 1.0 PRF, and the "sha256" suffix refers to the fact that the TLS 1.2 default PRF is based on SHA-256.</span></span> <span data-ttu-id="ac926-1070">Gdy wymagana jest obsługa innych procedur PRF, sufiks tych procedur będzie odzwierciedlał użytą metodę mieszania.</span><span class="sxs-lookup"><span data-stu-id="ac926-1070">When support for other PRF routines is needed, the suffix for those routines will reflect the hash method used.</span></span> <span data-ttu-id="ac926-1071">Ponieważ procedury PRF opierają się na metodach mieszania, bazowe procedury skrótu mogą być przyspieszane sprzętowo niezależnie od różnych platform docelowych.</span><span class="sxs-lookup"><span data-stu-id="ac926-1071">Since the PRF routines are based on hash methods, the underlying hash routines may be hardware-accelerated independently on different target platforms.</span></span>

<span data-ttu-id="ac926-1072">Oprócz tabel odnośników TLS ciphersuite i X. 509 z domyślnymi procedurami PRF i skrótami wypełnionymi w strukturze NX_SECURE_TLS_CRYPTO można wypełnić i użyć do zainicjowania sesji TLS.</span><span class="sxs-lookup"><span data-stu-id="ac926-1072">In addition to the TLS ciphersuite and X.509 lookup tables, with the default PRF and hash routines filled in the NX_SECURE_TLS_CRYPTO structure can be populated and used to initialize a TLS session.</span></span>

20. <span data-ttu-id="ac926-1073">"Pseudo-Random" oznacza fakt, że PRF jest deterministyczna, co oznacza, że zawsze produkuje te same dane wyjściowe, które mają te same dane wejściowe, ale losowo w przypadku, gdy dane wyjściowe nie są przewidywalne.</span><span class="sxs-lookup"><span data-stu-id="ac926-1073">“Pseudo-random” refers to the fact that the PRF is deterministic, meaning it will always produce the same output given the same input, but random in the fact that the output is not predictable.</span></span> <span data-ttu-id="ac926-1074">Protokół TLS wykorzystuje tę właściwość PRF, aby generować klucze sesji z różnych danych publicznych połączonych z głównym kluczem tajnym, które są wymieniane podczas uzgadniania przy użyciu szyfrowania klucza publicznego, takiego jak RSA.</span><span class="sxs-lookup"><span data-stu-id="ac926-1074">TLS uses this property of the PRF to generate the session keys from various public data combined with the master secret exchanged during the handshake using a public-key cipher like RSA.</span></span>

### <a name="cryptographic-metadata"></a><span data-ttu-id="ac926-1075">Metadane kryptograficzne</span><span class="sxs-lookup"><span data-stu-id="ac926-1075">Cryptographic Metadata</span></span>

<span data-ttu-id="ac926-1076">Aby można było zainicjować sesję protokołu TLS z tabelą NX_SECURE_TLS_CRYPTO, musimy przydzielić miejsce w buforze dla metadanych procedury kryptograficznej.</span><span class="sxs-lookup"><span data-stu-id="ac926-1076">Before we can initialize the TLS session with the NX_SECURE_TLS_CRYPTO table, we need to allocate buffer space for the cryptographic routine metadata.</span></span> <span data-ttu-id="ac926-1077">Metadane są używane do przechowywania wszystkich stanów skojarzonych z określoną procedurą, reprezentowane przez blok sterowania.</span><span class="sxs-lookup"><span data-stu-id="ac926-1077">The metadata is used to store all the state associated with a particular routine, represented by its control block.</span></span> <span data-ttu-id="ac926-1078">W polu *nx_crypto_metadata_area_size* każdego NX_CRYPTO_METHOD musi być ustawiony rozmiar struktury kontroli skojarzonej z tą procedurą lub zainicjowanie protokołu TLS nie powiedzie się prawidłowo w przypadku potrzebnego miejsca, co może powodować problemy z przepełnieniem buforu.</span><span class="sxs-lookup"><span data-stu-id="ac926-1078">The *nx_crypto_metadata_area_size* field of each NX_CRYPTO_METHOD must be set to the size of the control structure associated with that routine or the TLS initialization will fail to properly account for the space needed, possibly causing buffer overrun issues.</span></span>

<span data-ttu-id="ac926-1079">Przed utworzeniem sesji TLS bufor metadanych musi być przydzielony.</span><span class="sxs-lookup"><span data-stu-id="ac926-1079">Before the TLS session is created, the metadata buffer must be allocated.</span></span> <span data-ttu-id="ac926-1080">Bufor jest automatycznie dzielony przez nx_secure_tls_session_create i miejsce jest zarezerwowane dla każdej procedury, która jest dostępna w tabeli metod kryptograficznych.</span><span class="sxs-lookup"><span data-stu-id="ac926-1080">The buffer is automatically divided up by nx_secure_tls_session_create and space is reserved for each of the routines that are provided in the cryptographic method table.</span></span> <span data-ttu-id="ac926-1081">Należy pamiętać, że ponieważ tylko jeden ciphersuite jest aktywny w sesji TLS, liczba obsługiwanych ciphersuites nie ma wpływu na wymaganą przestrzeń metadanych — przestrzeń jest zarezerwowana dla każdej z 5 procedur ciphersuite przy użyciu maksymalnego rozmiaru bloku kontroli dla tej kategorii w tabeli odnośników ciphersuite.</span><span class="sxs-lookup"><span data-stu-id="ac926-1081">Note that since only one ciphersuite is active at a time in a TLS session, the number of supported ciphersuites does not affect the needed metadata space – space is reserved for each of the 5 ciphersuite routines using the maximum control block size for that category in the ciphersuite lookup table.</span></span>

<span data-ttu-id="ac926-1082">Aby ułatwić Obliczanie rozmiaru buforu metadanych, usługa *nx_secure_metadata_size_calculate* wykonuje te same obliczenia co nx_secure_tls_session_create, ale po prostu zwraca łączny wymagany rozmiar buforu metadanych w bajtach.</span><span class="sxs-lookup"><span data-stu-id="ac926-1082">In order to make calculating the metadata buffer size easy, the service *nx_secure_metadata_size_calculate* performs the same calculations as nx_secure_tls_session_create but simply returns the total required metadata buffer size in bytes.</span></span>

### <a name="initializing-the-tls-session"></a><span data-ttu-id="ac926-1083">Inicjowanie sesji TLS</span><span class="sxs-lookup"><span data-stu-id="ac926-1083">Initializing the TLS session</span></span>

<span data-ttu-id="ac926-1084">Po utworzeniu obiektów NX_CRYPTO_METHOD i NX_SECURE_TLS_CRYPTO i zastrzeżonym obszarze metadanych można zainicjować sesję protokołu TLS w następujący sposób (wartości pobrane z powyższych przykładów):</span><span class="sxs-lookup"><span data-stu-id="ac926-1084">Once the NX_CRYPTO_METHOD and NX_SECURE_TLS_CRYPTO objects are created and the metadata area reserved, we can initialize a TLS session as follows (values taken from the above examples):</span></span>

```C
/* Pointer to the platform-specific cipher table. */
extern nx_crypto_tls_ciphers;

/* Cryptographic routine metadata buffer. Size is determined by calling 
nx_secure_tls_metadata_size_calculate with the nx_crypto_tls_ciphers table referenced 
above. */
UCHAR crypto_metadata[4500];

/* Initialize our TLS session using our cipher table and metadata area. Note that we can 
use sizeof for the metadata array because the size parameter expects the size in bytes.*/

nx_secure_tls_session_create(
    &tls_session,            /* Pointer to TLS session.      */
    &nx_crypto_tls_ciphers,  /* Pointer to cipher table.     */
    crypto_metadata,         /* Cryptography metadata buffer.*/
    sizeof(crypto_metadata), /* Size of metadata buffer.     */
);
```
