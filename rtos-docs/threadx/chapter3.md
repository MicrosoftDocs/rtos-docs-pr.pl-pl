---
title: Rozdział 3 — funkcjonalne składniki platformy Azure RTO ThreadX
description: Ten rozdział zawiera opis RTO jądra ThreadX o wysokiej wydajności z perspektywy funkcjonalnej.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: aa66ad392171958e5d2cc765992fd1a9e41250a6
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 03/22/2021
ms.locfileid: "104823275"
---
# <a name="chapter-3---functional-components-of-azure-rtos-threadx"></a><span data-ttu-id="00e57-103">Rozdział 3 — funkcjonalne składniki platformy Azure RTO ThreadX</span><span class="sxs-lookup"><span data-stu-id="00e57-103">Chapter 3 - Functional Components of Azure RTOS ThreadX</span></span>

<span data-ttu-id="00e57-104">Ten rozdział zawiera opis RTO jądra ThreadX o wysokiej wydajności z perspektywy funkcjonalnej.</span><span class="sxs-lookup"><span data-stu-id="00e57-104">This chapter contains a description of the high-performance Azure RTOS ThreadX kernel from a functional perspective.</span></span> <span data-ttu-id="00e57-105">Każdy składnik funkcjonalny jest prezentowany w zrozumiały sposób.</span><span class="sxs-lookup"><span data-stu-id="00e57-105">Each functional component is presented in an easy-to-understand manner.</span></span>

## <a name="execution-overview"></a><span data-ttu-id="00e57-106">Przegląd wykonywania</span><span class="sxs-lookup"><span data-stu-id="00e57-106">Execution Overview</span></span>

<span data-ttu-id="00e57-107">Istnieją cztery typy wykonywania programu w ramach aplikacji ThreadX: Inicjowanie, wykonywanie wątków, procedury usługi przerwania (procedury ISR) i czasomierze aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-107">There are four types of program execution within a ThreadX application: Initialization, Thread Execution, Interrupt Service Routines (ISRs), and Application Timers.</span></span>

<span data-ttu-id="00e57-108">Rysunek 2 przedstawia każdy inny typ wykonywania programu.</span><span class="sxs-lookup"><span data-stu-id="00e57-108">Figure 2 shows each different type of program execution.</span></span> <span data-ttu-id="00e57-109">Bardziej szczegółowe informacje na temat każdego z tych typów znajdują się w kolejnych sekcjach tego rozdziału.</span><span class="sxs-lookup"><span data-stu-id="00e57-109">More detailed information about each of these types is found in subsequent sections of this chapter.</span></span>

### <a name="initialization"></a><span data-ttu-id="00e57-110">Inicjalizacja</span><span class="sxs-lookup"><span data-stu-id="00e57-110">Initialization</span></span>

<span data-ttu-id="00e57-111">Jak nazywa się, jest to pierwszy typ wykonywania programu w aplikacji ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-111">As the name implies, this is the first type of program execution in a ThreadX application.</span></span> <span data-ttu-id="00e57-112">Inicjalizacja obejmuje wykonywanie wszystkich programów między resetowaniem procesora i punktem wejścia *pętli planowania wątku.*</span><span class="sxs-lookup"><span data-stu-id="00e57-112">Initialization includes all program execution between processor reset and the entry point of the *thread scheduling loop.*</span></span>

### <a name="thread-execution"></a><span data-ttu-id="00e57-113">Wykonywanie wątku</span><span class="sxs-lookup"><span data-stu-id="00e57-113">Thread Execution</span></span>

<span data-ttu-id="00e57-114">Po zakończeniu inicjalizacji ThreadX wprowadza swoją pętlę planowania wątków.</span><span class="sxs-lookup"><span data-stu-id="00e57-114">After initialization is complete, ThreadX enters its thread scheduling loop.</span></span> <span data-ttu-id="00e57-115">Pętla planowania wyszukuje wątek aplikacji gotowy do wykonania.</span><span class="sxs-lookup"><span data-stu-id="00e57-115">The scheduling loop looks for an application thread ready for execution.</span></span> <span data-ttu-id="00e57-116">Po znalezieniu gotowego wątku ThreadX przenosi do niego kontrolkę.</span><span class="sxs-lookup"><span data-stu-id="00e57-116">When a ready thread is found, ThreadX transfers control to it.</span></span> <span data-ttu-id="00e57-117">Po zakończeniu wątku (lub przeniesieniu innego wątku wyższego priorytetu) wykonywanie jest wykonywane z powrotem do pętli planowania wątku, aby znaleźć wątek gotowy do następnego priorytetu.</span><span class="sxs-lookup"><span data-stu-id="00e57-117">After the thread is finished (or another higher-priority thread becomes ready), execution transfers back to the thread scheduling loop to find the next highest priority ready thread.</span></span>

<span data-ttu-id="00e57-118">Proces ciągłego wykonywania i planowania wątków jest najpopularniejszym typem wykonywania programów w aplikacjach ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-118">This process of continually executing and scheduling threads is the most common type of program execution in ThreadX applications.</span></span>

### <a name="interrupt-service-routines-isr"></a><span data-ttu-id="00e57-119">Procedury usługi przerwania (ISR)</span><span class="sxs-lookup"><span data-stu-id="00e57-119">Interrupt Service Routines (ISR)</span></span>

<span data-ttu-id="00e57-120">Przerwania są podstawą systemów w czasie rzeczywistym.</span><span class="sxs-lookup"><span data-stu-id="00e57-120">Interrupts are the cornerstone of real-time systems.</span></span> <span data-ttu-id="00e57-121">Bez przeszkód bardzo trudne jest reagowanie na zmiany w świecie zewnętrznym w odpowiednim czasie.</span><span class="sxs-lookup"><span data-stu-id="00e57-121">Without interrupts it would be extremely difficult to respond to changes in the external world in a timely manner.</span></span> <span data-ttu-id="00e57-122">W przypadku wykrywania przerwania procesor zapisuje kluczowe informacje o bieżącym wykonaniu programu (zwykle na stosie), a następnie przenosi formant do obszaru wstępnie zdefiniowanego programu.</span><span class="sxs-lookup"><span data-stu-id="00e57-122">On detection of an interrupt, the processor saves key information about the current program execution (usually on the stack), then transfers control to a predefined program area.</span></span> <span data-ttu-id="00e57-123">Ten wstępnie zdefiniowany obszar programu jest często nazywany procedurą usługi przerwania.</span><span class="sxs-lookup"><span data-stu-id="00e57-123">This predefined program area is commonly called an Interrupt Service Routine.</span></span> <span data-ttu-id="00e57-124">W większości przypadków przerwania występują podczas wykonywania wątku (lub w pętli planowania wątku).</span><span class="sxs-lookup"><span data-stu-id="00e57-124">In most cases, interrupts occur during thread execution (or in the thread scheduling loop).</span></span> <span data-ttu-id="00e57-125">Przerwania mogą jednak wystąpić w trakcie wykonywania procedury ISR lub czasomierza aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-125">However, interrupts may also occur inside of an executing ISR or an Application Timer.</span></span>

![Typy wykonywania programu](./media/user-guide/types-program-execution.png)

<span data-ttu-id="00e57-127">**RYSUNEK 2. Typy wykonywania programu**</span><span class="sxs-lookup"><span data-stu-id="00e57-127">**FIGURE 2. Types of Program Execution**</span></span>

### <a name="application-timers"></a><span data-ttu-id="00e57-128">Czasomierze aplikacji</span><span class="sxs-lookup"><span data-stu-id="00e57-128">Application Timers</span></span>

<span data-ttu-id="00e57-129">Czasomierze aplikacji są podobne do procedury ISR, z wyjątkiem tego, że implementacja sprzętowa (zazwyczaj jest używany pojedynczy okresowe przerwanie sprzętowe) jest ukryta w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-129">Application Timers are similar to ISRs, except the hardware implementation (usually a single periodic hardware interrupt is used) is hidden from the application.</span></span> <span data-ttu-id="00e57-130">Takie czasomierze są używane przez aplikacje do wykonywania limitów czasu, okresowych i/lub usług alarmowych.</span><span class="sxs-lookup"><span data-stu-id="00e57-130">Such timers are used by applications to perform time-outs, periodics, and/or watchdog services.</span></span> <span data-ttu-id="00e57-131">Podobnie jak procedury ISR, czasomierze aplikacji najczęściej przerywają wykonywanie wątków.</span><span class="sxs-lookup"><span data-stu-id="00e57-131">Just like ISRs, Application Timers most often interrupt thread execution.</span></span> <span data-ttu-id="00e57-132">W przeciwieństwie do procedury ISR, jednak czasomierze aplikacji nie mogą przerwać siebie nawzajem.</span><span class="sxs-lookup"><span data-stu-id="00e57-132">Unlike ISRs, however, Application Timers cannot interrupt each other.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="00e57-133">Użycie pamięci</span><span class="sxs-lookup"><span data-stu-id="00e57-133">Memory Usage</span></span>

<span data-ttu-id="00e57-134">ThreadX się wraz z programem aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-134">ThreadX resides along with the application program.</span></span> <span data-ttu-id="00e57-135">W związku z tym użycie pamięci statycznej (lub stałej pamięci) ThreadX jest określane przez narzędzia programistyczne. na przykład kompilator, konsolidator i lokalizator.</span><span class="sxs-lookup"><span data-stu-id="00e57-135">As a result, the static memory (or fixed memory) usage of ThreadX is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="00e57-136">Użycie pamięci dynamicznej (lub pamięci w czasie wykonywania) jest kontrolowane bezpośrednio przez aplikację.</span><span class="sxs-lookup"><span data-stu-id="00e57-136">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="00e57-137">Użycie pamięci statycznej</span><span class="sxs-lookup"><span data-stu-id="00e57-137">Static Memory Usage</span></span>

<span data-ttu-id="00e57-138">Większość narzędzi programistycznych dzieli obraz programu aplikacji na pięć podstawowych obszarów: *instrukcje*, *stałe*, *zainicjowane dane*, *niezainicjowane dane* i *stos systemu*.</span><span class="sxs-lookup"><span data-stu-id="00e57-138">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and *system stack*.</span></span> <span data-ttu-id="00e57-139">Rysunek 3 przedstawia przykład tych obszarów pamięci.</span><span class="sxs-lookup"><span data-stu-id="00e57-139">Figure 3 shows an example of these memory areas.</span></span>

<span data-ttu-id="00e57-140">Ważne jest, aby zrozumieć, że jest to tylko przykład.</span><span class="sxs-lookup"><span data-stu-id="00e57-140">It is important to understand that this is only an example.</span></span> <span data-ttu-id="00e57-141">Rzeczywisty układ pamięci statycznej jest specyficzny dla procesora, narzędzi programistycznych i bazowego sprzętu.</span><span class="sxs-lookup"><span data-stu-id="00e57-141">The actual static memory layout is specific to the processor, development tools, and the underlying hardware.</span></span>

<span data-ttu-id="00e57-142">Obszar instrukcji zawiera wszystkie instrukcje procesora programu.</span><span class="sxs-lookup"><span data-stu-id="00e57-142">The instruction area contains all of the program's processor instructions.</span></span> <span data-ttu-id="00e57-143">Ten obszar jest zwykle największą i często znajduje się w pamięci ROM.</span><span class="sxs-lookup"><span data-stu-id="00e57-143">This area is typically the largest and is often located in ROM.</span></span>

<span data-ttu-id="00e57-144">Obszar stałych zawiera różne skompilowane stałe, w tym ciągi zdefiniowane lub przywoływane w programie.</span><span class="sxs-lookup"><span data-stu-id="00e57-144">The constant area contains various compiled constants, including strings defined or referenced within the program.</span></span> <span data-ttu-id="00e57-145">Ponadto ten obszar zawiera "początkową kopię" zainicjowanego obszaru danych.</span><span class="sxs-lookup"><span data-stu-id="00e57-145">In addition, this area contains the "initial copy" of the initialized data area.</span></span> <span data-ttu-id="00e57-146">W trakcie procesu inicjowania kompilatora *użycia pamięci* ta część obszaru stałego służy do konfigurowania zainicjowanego obszaru danych w pamięci RAM.</span><span class="sxs-lookup"><span data-stu-id="00e57-146">During the *Memory Usage* compiler's initialization process, this portion of the constant area is used to set up the initialized data area in RAM.</span></span> <span data-ttu-id="00e57-147">Obszar stałych zwykle jest zgodny z obszarem instrukcji i często znajduje się w pamięci ROM.</span><span class="sxs-lookup"><span data-stu-id="00e57-147">The constant area usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="00e57-148">Zainicjowane dane i niezainicjowane obszary danych zawierają wszystkie zmienne globalne i statyczne.</span><span class="sxs-lookup"><span data-stu-id="00e57-148">The initialized data and uninitialized data areas contain all of the global and static variables.</span></span> <span data-ttu-id="00e57-149">Obszary te są zawsze zlokalizowane w pamięci RAM.</span><span class="sxs-lookup"><span data-stu-id="00e57-149">These areas are always located in RAM.</span></span>

<span data-ttu-id="00e57-150">Stos systemowy jest zwykle ustawiany bezpośrednio po zainicjowaniu i niezainicjowanym obszarze danych.</span><span class="sxs-lookup"><span data-stu-id="00e57-150">The system stack is generally set up immediately following the initialized and uninitialized data areas.</span></span>

<span data-ttu-id="00e57-151">Stos systemu jest używany przez kompilator podczas inicjacji, a następnie przez ThreadX podczas inicjowania, a następnie w przypadku przetwarzania w procesie ISR.</span><span class="sxs-lookup"><span data-stu-id="00e57-151">The system stack is used by the compiler during initialization, then by ThreadX during initialization and, subsequently, in ISR processing.</span></span>

![Przykład obszaru pamięci](./media/user-guide/memory-area-example.png)

<span data-ttu-id="00e57-153">**RYSUNEK 3. Przykład obszaru pamięci**</span><span class="sxs-lookup"><span data-stu-id="00e57-153">**FIGURE 3. Memory Area Example**</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="00e57-154">Użycie pamięć dynamiczna</span><span class="sxs-lookup"><span data-stu-id="00e57-154">Dynamic Memory Usage</span></span>

<span data-ttu-id="00e57-155">Jak wspomniano wcześniej, użycie pamięci dynamicznej jest kontrolowane bezpośrednio przez aplikację.</span><span class="sxs-lookup"><span data-stu-id="00e57-155">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="00e57-156">Bloki kontroli i obszary pamięci skojarzone z stosami, kolejkami i pulami pamięci można umieścić w dowolnym miejscu w obszarze pamięci docelowej.</span><span class="sxs-lookup"><span data-stu-id="00e57-156">Control blocks and memory areas associated with stacks, queues, and memory pools can be placed anywhere in the target's memory space.</span></span> <span data-ttu-id="00e57-157">Jest to ważna funkcja, ponieważ ułatwia ona łatwe wykorzystanie różnych typów pamięci fizycznej.</span><span class="sxs-lookup"><span data-stu-id="00e57-157">This is an important feature because it facilitates easy utilization of different types of physical memory.</span></span>

<span data-ttu-id="00e57-158">Załóżmy na przykład, że w docelowym środowisku sprzętowym występuje szybka pamięć i wolna pamięć.</span><span class="sxs-lookup"><span data-stu-id="00e57-158">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="00e57-159">Jeśli aplikacja wymaga dodatkowej wydajności dla wątku o wysokim priorytecie, jego blok sterowania (TX_THREAD) i stos można umieścić w obszarze szybkiej pamięci, co może znacząco wzmocnić jego wydajność.</span><span class="sxs-lookup"><span data-stu-id="00e57-159">If the application needs extra performance for a high-priority thread, its control block (TX_THREAD) and stack can be placed in the fast memory area, which may greatly enhance its performance.</span></span>

## <a name="initialization"></a><span data-ttu-id="00e57-160">Inicjalizacja</span><span class="sxs-lookup"><span data-stu-id="00e57-160">Initialization</span></span>

<span data-ttu-id="00e57-161">Zrozumienie procesu inicjowania jest ważne.</span><span class="sxs-lookup"><span data-stu-id="00e57-161">Understanding the initialization process is important.</span></span> <span data-ttu-id="00e57-162">Początkowe środowisko sprzętowe jest skonfigurowane w tym miejscu.</span><span class="sxs-lookup"><span data-stu-id="00e57-162">The initial hardware environment is set up here.</span></span> <span data-ttu-id="00e57-163">Ponadto jest to miejsce, w którym aplikacja ma swoją wstępną osobowość.</span><span class="sxs-lookup"><span data-stu-id="00e57-163">In addition, this is where the application is given its initial personality.</span></span>

> [!NOTE]
> <span data-ttu-id="00e57-164">*ThreadX próbuje użyć (o ile to możliwe) kompletnego procesu inicjowania narzędzia deweloperskiego. Dzięki temu można łatwiej uaktualniać do nowych wersji narzędzi programistycznych w przyszłości.*</span><span class="sxs-lookup"><span data-stu-id="00e57-164">*ThreadX attempts to utilize (whenever possible) the complete development tool's initialization process. This makes it easier to upgrade to new versions of the development tools in the future.*</span></span>

### <a name="system-reset-vector"></a><span data-ttu-id="00e57-165">Wektor resetowania systemu</span><span class="sxs-lookup"><span data-stu-id="00e57-165">System Reset Vector</span></span>

<span data-ttu-id="00e57-166">Wszystkie mikroprocesory mają logikę resetowania.</span><span class="sxs-lookup"><span data-stu-id="00e57-166">All microprocessors have reset logic.</span></span> <span data-ttu-id="00e57-167">W przypadku wyzerowania (sprzętowego lub programowego) adres punktu wejścia aplikacji jest pobierany z określonej lokalizacji pamięci.</span><span class="sxs-lookup"><span data-stu-id="00e57-167">When a reset occurs (either hardware or software), the address of the application's entry point is retrieved from a specific memory location.</span></span> <span data-ttu-id="00e57-168">Po pobraniu punktu wejścia procesor przetransferuje kontrolkę do tej lokalizacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-168">After the entry point is retrieved, the processor transfers control to that location.</span></span> <span data-ttu-id="00e57-169">Punkt wejścia aplikacji jest bardzo często pisany w natywnym języku asemblera i jest zwykle dostarczany przez narzędzia programistyczne (co najmniej w formularzu szablonu).</span><span class="sxs-lookup"><span data-stu-id="00e57-169">The application entry point is quite often written in the native assembly language and is usually supplied by the development tools (at least in template form).</span></span> <span data-ttu-id="00e57-170">W niektórych przypadkach specjalna wersja programu wprowadzania jest dostarczana z ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-170">In some cases, a special version of the entry program is supplied with ThreadX.</span></span>

### <a name="development-tool-initialization"></a><span data-ttu-id="00e57-171">Inicjowanie narzędzia programistycznego</span><span class="sxs-lookup"><span data-stu-id="00e57-171">Development Tool Initialization</span></span>

<span data-ttu-id="00e57-172">Po zakończeniu inicjalizacji niskiego poziomu należy kontrolować transfery do inicjalizacji wysokiego poziomu narzędzia deweloperskiego.</span><span class="sxs-lookup"><span data-stu-id="00e57-172">After the low-level initialization is complete, control transfers to the development tool's high-level initialization.</span></span> <span data-ttu-id="00e57-173">Zwykle jest to miejsce, w którym są skonfigurowane zmienne globalne i statyczne języka C.</span><span class="sxs-lookup"><span data-stu-id="00e57-173">This is usually the place where initialized global and static C variables are set up.</span></span> <span data-ttu-id="00e57-174">Należy pamiętać, że ich początkowe wartości są pobierane z obszaru stałego.</span><span class="sxs-lookup"><span data-stu-id="00e57-174">Remember their initial values are retrieved from the constant area.</span></span> <span data-ttu-id="00e57-175">Dokładne przetwarzanie inicjowania jest specyficzne dla narzędzia deweloperskiego.</span><span class="sxs-lookup"><span data-stu-id="00e57-175">Exact initialization processing is development tool specific.</span></span>

### <a name="main-function"></a><span data-ttu-id="00e57-176">Funkcja Main</span><span class="sxs-lookup"><span data-stu-id="00e57-176">main Function</span></span>

<span data-ttu-id="00e57-177">Po zakończeniu inicjowania narzędzia deweloperskiego należy kontrolować transfery do funkcji *głównej* dostarczonej przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="00e57-177">When the development tool initialization is complete, control transfers to the user-supplied *main* function.</span></span> <span data-ttu-id="00e57-178">W tym momencie aplikacja kontroluje, co się stanie dalej.</span><span class="sxs-lookup"><span data-stu-id="00e57-178">At this point, the application controls what happens next.</span></span> <span data-ttu-id="00e57-179">W przypadku większości aplikacji funkcja Main po prostu wywołuje *tx_kernel_enter*, który jest wpisem do ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-179">For most applications, the main function simply calls *tx_kernel_enter*, which is the entry into ThreadX.</span></span> <span data-ttu-id="00e57-180">Jednak aplikacje mogą wykonać wstępne przetwarzanie (zwykle w przypadku inicjowania sprzętowego) przed wprowadzeniem ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-180">However, applications can perform preliminary processing (usually for hardware initialization) prior to entering ThreadX.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="00e57-181">*Wywołanie tx_kernel_enter nie zwraca, dlatego nie należy umieszczać żadnego przetwarzania po nim.*</span><span class="sxs-lookup"><span data-stu-id="00e57-181">*The call to tx_kernel_enter does not return, so do not place any processing after it.*</span></span>

### <a name="tx_kernel_enter"></a><span data-ttu-id="00e57-182">tx_kernel_enter</span><span class="sxs-lookup"><span data-stu-id="00e57-182">tx_kernel_enter</span></span>

<span data-ttu-id="00e57-183">Funkcja wejścia koordynuje inicjalizację różnych wewnętrznych struktur danych ThreadX, a następnie wywołuje funkcję definicji aplikacji ***tx_application_define***.</span><span class="sxs-lookup"><span data-stu-id="00e57-183">The entry function coordinates initialization of various internal ThreadX data structures and then calls the application's definition function ***tx_application_define***.</span></span>

<span data-ttu-id="00e57-184">Gdy ***tx_application_define*** zwraca, kontrola jest przekazywana do pętli planowania wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-184">When ***tx_application_define*** returns, control is transferred to the thread scheduling loop.</span></span> <span data-ttu-id="00e57-185">Oznacza to koniec inicjalizacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-185">This marks the end of initialization.</span></span>

### <a name="application-definition-function"></a><span data-ttu-id="00e57-186">Funkcja definicji aplikacji</span><span class="sxs-lookup"><span data-stu-id="00e57-186">Application Definition Function</span></span>

<span data-ttu-id="00e57-187">Funkcja ***tx_application_define*** definiuje wszystkie początkowe wątki aplikacji, kolejki, semafory, muteksy, flagi zdarzeń, Pule pamięci i czasomierze.</span><span class="sxs-lookup"><span data-stu-id="00e57-187">The ***tx_application_define*** function defines all of the initial application threads, queues, semaphores, mutexes, event flags, memory pools, and timers.</span></span> <span data-ttu-id="00e57-188">Istnieje również możliwość tworzenia i usuwania zasobów systemowych z wątków podczas normalnego działania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-188">It is also possible to create and delete system resources from threads during the normal operation of the application.</span></span> <span data-ttu-id="00e57-189">Wszystkie początkowe zasoby aplikacji są jednak zdefiniowane w tym miejscu.</span><span class="sxs-lookup"><span data-stu-id="00e57-189">However, all initial application resources are defined here.</span></span>

<span data-ttu-id="00e57-190">Funkcja \***tx_application_define** _ ma jeden parametr wejściowy, a jego wartość różni się od siebie.</span><span class="sxs-lookup"><span data-stu-id="00e57-190">The \***tx_application_define** _ function has a single input parameter and it is certainly worth mentioning.</span></span> <span data-ttu-id="00e57-191">Adres pamięci RAM _first dostępny \* jest jedynym parametrem wejściowym tej funkcji.</span><span class="sxs-lookup"><span data-stu-id="00e57-191">The _first-available\* RAM address is the sole input parameter to this function.</span></span> <span data-ttu-id="00e57-192">Jest zazwyczaj używany jako punkt wyjścia dla początkowych alokacji pamięci w czasie wykonywania dla stosów wątków, kolejek i pul pamięci.</span><span class="sxs-lookup"><span data-stu-id="00e57-192">It is typically used as a starting point for initial run-time memory allocations of thread stacks, queues, and memory pools.</span></span>

> [!NOTE]
> <span data-ttu-id="00e57-193">*Po zakończeniu inicjalizacji tylko wątek wykonawczy może tworzyć i usuwać zasoby systemowe, w tym inne wątki. W związku z tym należy utworzyć co najmniej jeden wątek podczas inicjalizacji.*</span><span class="sxs-lookup"><span data-stu-id="00e57-193">*After initialization is complete, only an executing thread can create and delete system resources— including other threads. Therefore, at least one thread must be created during initialization.*</span></span>

### <a name="interrupts"></a><span data-ttu-id="00e57-194">Przerwań</span><span class="sxs-lookup"><span data-stu-id="00e57-194">Interrupts</span></span>

<span data-ttu-id="00e57-195">Przerwania są pozostawiane wyłączone podczas całego procesu inicjowania.</span><span class="sxs-lookup"><span data-stu-id="00e57-195">Interrupts are left disabled during the entire initialization process.</span></span> <span data-ttu-id="00e57-196">Jeśli aplikacja w dowolny sposób włącza przerwania, może wystąpić nieprzewidywalne zachowanie.</span><span class="sxs-lookup"><span data-stu-id="00e57-196">If the application somehow enables interrupts, unpredictable behavior may occur.</span></span> <span data-ttu-id="00e57-197">Na rysunku 4 przedstawiono cały proces inicjalizacji od resetowania systemu przy użyciu inicjalizacji specyficznej dla aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-197">Figure 4 shows the entire initialization process, from system reset through application-specific initialization.</span></span>

## <a name="thread-execution"></a><span data-ttu-id="00e57-198">Wykonywanie wątku</span><span class="sxs-lookup"><span data-stu-id="00e57-198">Thread Execution</span></span>

<span data-ttu-id="00e57-199">Planowanie i wykonywanie wątków aplikacji jest najważniejszym działaniem ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-199">Scheduling and executing application threads is the most important activity of ThreadX.</span></span> <span data-ttu-id="00e57-200">Wątek jest zwykle definiowany jako segment częściowo niezależnego programu z dedykowanym przeznaczeniem.</span><span class="sxs-lookup"><span data-stu-id="00e57-200">A thread is typically defined as a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="00e57-201">Połączone przetwarzanie wszystkich wątków tworzy aplikację.</span><span class="sxs-lookup"><span data-stu-id="00e57-201">The combined processing of all threads makes an application.</span></span>

<span data-ttu-id="00e57-202">Wątki są tworzone dynamicznie przez wywołanie \***tx_thread_create** _ podczas inicjowania lub podczas wykonywania wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-202">Threads are created dynamically by calling \***tx_thread_create** _ during initialization or during thread execution.</span></span> <span data-ttu-id="00e57-203">Wątki są tworzone w stanie _ready \* lub *wstrzymania* .</span><span class="sxs-lookup"><span data-stu-id="00e57-203">Threads are created in either a _ready\* or *suspended* state.</span></span>

![Proces inicjalizacji](./media/user-guide/initialization-process.png)

<span data-ttu-id="00e57-205">**RYSUNEK 4. Proces inicjalizacji**</span><span class="sxs-lookup"><span data-stu-id="00e57-205">**FIGURE 4. Initialization Process**</span></span>

### <a name="thread-execution-states"></a><span data-ttu-id="00e57-206">Stany wykonywania wątków</span><span class="sxs-lookup"><span data-stu-id="00e57-206">Thread Execution States</span></span>

<span data-ttu-id="00e57-207">Zrozumienie różnych stanów przetwarzania wątków jest kluczowym elementem opisującym całe środowisko wielowątkowości.</span><span class="sxs-lookup"><span data-stu-id="00e57-207">Understanding the different processing states of threads is a key ingredient to understanding the entire multithreaded environment.</span></span> <span data-ttu-id="00e57-208">W programie ThreadX istnieje pięć odrębnych Stanów wątków: *gotowy*, *zawieszony*, *wykonywany*, *zakończony* i *zakończony.*</span><span class="sxs-lookup"><span data-stu-id="00e57-208">In ThreadX there are five distinct thread states: *ready*, *suspended*, *executing*, *terminated*, and *completed*.</span></span> <span data-ttu-id="00e57-209">Rysunek 5 przedstawia diagram przejścia stanu wątku dla ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-209">Figure 5 shows the thread state transition diagram for ThreadX.</span></span>

![Przejście stanu wątku](./media/user-guide/thread-state-transition.png)

<span data-ttu-id="00e57-211">**RYSUNEK 5. Przejście stanu wątku**</span><span class="sxs-lookup"><span data-stu-id="00e57-211">**FIGURE 5. Thread State Transition**</span></span>

<span data-ttu-id="00e57-212">Wątek jest w stanie *gotowości* , gdy jest gotowy do wykonania.</span><span class="sxs-lookup"><span data-stu-id="00e57-212">A thread is in a *ready* state when it is ready for execution.</span></span> <span data-ttu-id="00e57-213">Wątek gotowy nie jest wykonywany, dopóki nie jest to wątek o najwyższym priorytecie w stanie gotowe.</span><span class="sxs-lookup"><span data-stu-id="00e57-213">A ready thread is not executed until it is the highest priority thread in ready state.</span></span> <span data-ttu-id="00e57-214">Gdy tak się stanie, ThreadX wykonuje wątek, a następnie zmienia jego stan na *wykonywanie*.</span><span class="sxs-lookup"><span data-stu-id="00e57-214">When this happens, ThreadX executes the thread, which then changes its state to *executing*.</span></span>

<span data-ttu-id="00e57-215">Jeśli wątek o wyższym priorytecie stanie się gotowy, wątek wykonawczy powróci do stanu *gotowości* .</span><span class="sxs-lookup"><span data-stu-id="00e57-215">If a higher-priority thread becomes ready, the executing thread reverts back to a *ready* state.</span></span> <span data-ttu-id="00e57-216">Nowo przygotowany wątek o wysokim priorytecie jest następnie wykonywany, co powoduje zmianę jego stanu logicznego na *wykonanie*.</span><span class="sxs-lookup"><span data-stu-id="00e57-216">The newly ready high-priority thread is then executed, which changes its logical state to *executing*.</span></span> <span data-ttu-id="00e57-217">To przejście między Stanami *gotowe* i *wykonawcze* odbywa się za każdym razem, gdy wystąpi zastępujący wątek.</span><span class="sxs-lookup"><span data-stu-id="00e57-217">This transition between *ready* and *executing* states occurs every time thread preemption occurs.</span></span>

<span data-ttu-id="00e57-218">W danym momencie tylko jeden wątek jest w stanie *wykonywania* .</span><span class="sxs-lookup"><span data-stu-id="00e57-218">At any given moment, only one thread is in an *executing* state.</span></span> <span data-ttu-id="00e57-219">Dzieje się tak, ponieważ wątek w stanie *wykonywania* ma kontrolę nad podstawowym procesorem.</span><span class="sxs-lookup"><span data-stu-id="00e57-219">This is because a thread in the *executing* state has control of the underlying processor.</span></span>

<span data-ttu-id="00e57-220">Wątki w stanie *wstrzymania* nie kwalifikują się do wykonania.</span><span class="sxs-lookup"><span data-stu-id="00e57-220">Threads in a *suspended* state are not eligible for execution.</span></span> <span data-ttu-id="00e57-221">Przyczyny *wstrzymania* w stanie zawieszenia obejmują zawieszenie czasu, komunikatów w kolejce, semaforów, muteksów, flag zdarzeń, pamięci i zawieszenia wątku podstawowego.</span><span class="sxs-lookup"><span data-stu-id="00e57-221">Reasons for being in a *suspended* state include suspension for time, queue messages, semaphores, mutexes, event flags, memory, and basic thread suspension.</span></span> <span data-ttu-id="00e57-222">Po usunięciu przyczyny zawieszenia wątek zostanie umieszczony w stanie *gotowości* .</span><span class="sxs-lookup"><span data-stu-id="00e57-222">After the cause for suspension is removed, the thread is placed back in a *ready* state.</span></span>

<span data-ttu-id="00e57-223">Wątek w stanie *ukończone* jest wątkiem, który ukończył przetwarzanie i zwraca z funkcji wejścia.</span><span class="sxs-lookup"><span data-stu-id="00e57-223">A thread in a *completed* state is a thread that has completed its processing and returned from its entry function.</span></span> <span data-ttu-id="00e57-224">Funkcja wprowadzania jest określana podczas tworzenia wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-224">The entry function is specified during thread creation.</span></span> <span data-ttu-id="00e57-225">Wątek w stanie *ukończenia* nie może zostać ponownie wykonany.</span><span class="sxs-lookup"><span data-stu-id="00e57-225">A thread in a *completed* state cannot execute again.</span></span>

<span data-ttu-id="00e57-226">Wątek jest w stanie *przerwania* , ponieważ inny wątek lub sam wątek o nazwie Usługa *tx_thread_terminate* .</span><span class="sxs-lookup"><span data-stu-id="00e57-226">A thread is in a *terminated* state because another thread or the thread itself called the *tx_thread_terminate* service.</span></span> <span data-ttu-id="00e57-227">Wątek w stanie *przerwania* nie może zostać ponownie wykonany.</span><span class="sxs-lookup"><span data-stu-id="00e57-227">A thread in a *terminated* state cannot execute again.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="00e57-228">*Jeśli pożądane jest ponowne uruchomienie wątku zakończony lub zakończony, aplikacja musi najpierw usunąć wątek. Następnie można go ponownie utworzyć i ponownie uruchomić.*</span><span class="sxs-lookup"><span data-stu-id="00e57-228">*If re-starting a completed or terminated thread is desired, the application must first delete the thread. It can then be re-created and re-started.*</span></span>

### <a name="thread-entryexit-notification"></a><span data-ttu-id="00e57-229">Powiadomienie o wejściu/wyjściu wątku</span><span class="sxs-lookup"><span data-stu-id="00e57-229">Thread Entry/Exit Notification</span></span>

<span data-ttu-id="00e57-230">Niektóre aplikacje mogą otrzymywać powiadomienia, gdy określony wątek zostanie wprowadzony po raz pierwszy, po jego zakończeniu lub zostanie zakończony.</span><span class="sxs-lookup"><span data-stu-id="00e57-230">Some applications may find it advantageous to be notified when a specific thread is entered for the first time, when it completes, or is terminated.</span></span> <span data-ttu-id="00e57-231">ThreadX zapewnia tę możliwość za pomocą usługi ***tx_thread_entry_exit_notify*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-231">ThreadX provides this ability through the ***tx_thread_entry_exit_notify*** service.</span></span> <span data-ttu-id="00e57-232">Ta usługa rejestruje funkcję powiadamiania aplikacji dla określonego wątku, który jest wywoływany przez ThreadX za każdym razem, gdy wątek zacznie działać, kończy lub zostaje zakończony.</span><span class="sxs-lookup"><span data-stu-id="00e57-232">This service registers an application notification function for a specific thread, which is called by ThreadX whenever the thread starts running, completes, or is terminated.</span></span> <span data-ttu-id="00e57-233">Po wywołaniu Funkcja powiadomień aplikacji może wykonać przetwarzanie specyficzne dla aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-233">After being invoked, the application notification function can perform the application-specific processing.</span></span> <span data-ttu-id="00e57-234">Zwykle polega to na poinformowaniu innego wątku aplikacji za pośrednictwem elementu podstawowego synchronizacji ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-234">This typically involves informing another application thread of the event via a ThreadX synchronization primitive.</span></span>

### <a name="thread-priorities"></a><span data-ttu-id="00e57-235">Priorytety wątków</span><span class="sxs-lookup"><span data-stu-id="00e57-235">Thread Priorities</span></span>

<span data-ttu-id="00e57-236">Jak wspomniano wcześniej, wątek jest niezależnym segmentem programu z dedykowanym przeznaczeniem.</span><span class="sxs-lookup"><span data-stu-id="00e57-236">As mentioned before, a thread is a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="00e57-237">Jednak wszystkie wątki nie są tworzone jako równe!</span><span class="sxs-lookup"><span data-stu-id="00e57-237">However, all threads are not created equal!</span></span> <span data-ttu-id="00e57-238">Dedykowany cel niektórych wątków jest znacznie ważniejszy niż inne.</span><span class="sxs-lookup"><span data-stu-id="00e57-238">The dedicated purpose of some threads is much more important than others.</span></span> <span data-ttu-id="00e57-239">Ten heterogeniczny typ ważności wątków to Hallmark osadzonych aplikacji w czasie rzeczywistym.</span><span class="sxs-lookup"><span data-stu-id="00e57-239">This heterogeneous type of thread importance is a hallmark of embedded realtime applications.</span></span>

<span data-ttu-id="00e57-240">ThreadX określa ważność wątku, gdy tworzony jest wątek przez przypisanie wartości liczbowej reprezentującej jej *priorytet*.</span><span class="sxs-lookup"><span data-stu-id="00e57-240">ThreadX determines a thread's importance when the thread is created by assigning a numerical value representing its *priority*.</span></span> <span data-ttu-id="00e57-241">Maksymalna liczba priorytetów ThreadX można konfigurować z 32 do 1024 w przyrostach wynoszących 32.</span><span class="sxs-lookup"><span data-stu-id="00e57-241">The maximum number of ThreadX priorities is configurable from 32 through 1024 in increments of 32.</span></span> <span data-ttu-id="00e57-242">Rzeczywista Maksymalna liczba priorytetów jest określana na podstawie stałej **TX_MAX_PRIORITIES** podczas kompilowania biblioteki ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-242">The actual maximum number of priorities is determined by the **TX_MAX_PRIORITIES** constant during compilation of the ThreadX library.</span></span> <span data-ttu-id="00e57-243">Posiadanie większej liczby priorytetów nie powoduje znacznego zwiększenia obciążenia związanego z przetwarzaniem.</span><span class="sxs-lookup"><span data-stu-id="00e57-243">Having a larger number of priorities does not significantly increase processing overhead.</span></span> <span data-ttu-id="00e57-244">Jednak dla każdej grupy poziomów priorytetów 32 do zarządzania nimi jest wymagane dodatkowe 128 bajtów pamięci RAM.</span><span class="sxs-lookup"><span data-stu-id="00e57-244">However, for each group of 32 priority levels an additional 128 bytes of RAM is required to manage them.</span></span> <span data-ttu-id="00e57-245">Na przykład 32 poziomów priorytetów wymaga 128 bajtów pamięci RAM, 64 poziomy priorytetu wymagają 256 bajtów pamięci RAM, a poziom priorytetu 96 wymaga 384 bajtów pamięci RAM.</span><span class="sxs-lookup"><span data-stu-id="00e57-245">For example, 32 priority levels require 128 bytes of RAM, 64 priority levels require 256 bytes of RAM, and 96 priority levels requires 384 bytes of RAM.</span></span>

<span data-ttu-id="00e57-246">Domyślnie ThreadX ma 32 poziomów priorytetów, od priorytetu od 0 do 31.</span><span class="sxs-lookup"><span data-stu-id="00e57-246">By default, ThreadX has 32 priority levels, ranging from priority 0 through priority 31.</span></span> <span data-ttu-id="00e57-247">Mniejsze wartości liczbowe oznaczają wyższy priorytet.</span><span class="sxs-lookup"><span data-stu-id="00e57-247">Numerically smaller values imply higher priority.</span></span> <span data-ttu-id="00e57-248">W związku z tym priorytet 0 reprezentuje najwyższy priorytet, a priorytet (**TX_MAX_PRIORITIES**-1) reprezentuje najniższy priorytet.</span><span class="sxs-lookup"><span data-stu-id="00e57-248">Hence, priority 0 represents the highest priority, while priority (**TX_MAX_PRIORITIES**-1) represents the lowest priority.</span></span>

<span data-ttu-id="00e57-249">Wiele wątków może mieć ten sam priorytet polegający na planowaniu współdziałania lub wycinku czasu.</span><span class="sxs-lookup"><span data-stu-id="00e57-249">Multiple threads can have the same priority relying on cooperative scheduling or time-slicing.</span></span> <span data-ttu-id="00e57-250">Ponadto priorytety wątków można zmieniać w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="00e57-250">In addition, thread priorities can be changed during run-time.</span></span>

### <a name="thread-scheduling"></a><span data-ttu-id="00e57-251">Planowanie wątków</span><span class="sxs-lookup"><span data-stu-id="00e57-251">Thread Scheduling</span></span>

<span data-ttu-id="00e57-252">ThreadX planuje wątki na podstawie ich priorytetu.</span><span class="sxs-lookup"><span data-stu-id="00e57-252">ThreadX schedules threads based on their priority.</span></span> <span data-ttu-id="00e57-253">Wątek gotowy z najwyższym priorytetem jest wykonywany jako pierwszy.</span><span class="sxs-lookup"><span data-stu-id="00e57-253">The ready thread with the highest priority is executed first.</span></span> <span data-ttu-id="00e57-254">Jeśli jest gotowych wiele wątków o takim samym priorytecie, są one wykonywane w sposób *pierwszy-pierwszy-wyewidencjonowany* (FIFO).</span><span class="sxs-lookup"><span data-stu-id="00e57-254">If multiple threads of the same priority are ready, they are executed in a *first-in-first-out* (FIFO) manner.</span></span>

### <a name="round-robin-scheduling"></a><span data-ttu-id="00e57-255">Planowanie okrężne</span><span class="sxs-lookup"><span data-stu-id="00e57-255">Round-robin Scheduling</span></span>

<span data-ttu-id="00e57-256">ThreadX obsługuje *Planowanie okrężne* wielu wątków mających taki sam priorytet.</span><span class="sxs-lookup"><span data-stu-id="00e57-256">ThreadX supports *round-robin* scheduling of multiple threads having the same priority.</span></span> <span data-ttu-id="00e57-257">Jest to realizowane poprzez wywołania wspólne do \***tx_thread_relinquish** _.</span><span class="sxs-lookup"><span data-stu-id="00e57-257">This is accomplished through cooperative calls to \***tx_thread_relinquish** _.</span></span> <span data-ttu-id="00e57-258">Ta usługa udostępnia wszystkie inne gotowe wątki o takim samym priorytecie, które można wykonać przed ponownym uruchomieniem programu _ \*_tx_thread_relinquish_\*\*.</span><span class="sxs-lookup"><span data-stu-id="00e57-258">This service gives all other ready threads of the same priority a chance to execute before the _ *_tx_thread_relinquish_*\* caller executes again.</span></span>

### <a name="time-slicing"></a><span data-ttu-id="00e57-259">Time-Slicing</span><span class="sxs-lookup"><span data-stu-id="00e57-259">Time-Slicing</span></span>

<span data-ttu-id="00e57-260">*Cięcie czasu* jest kolejną formą planowania działania okrężnego.</span><span class="sxs-lookup"><span data-stu-id="00e57-260">*Time-slicing* is another form of round-robin scheduling.</span></span> <span data-ttu-id="00e57-261">Wycinek czasu określa maksymalną liczbę taktów czasomierza (przerwań czasomierza), którą wątek można wykonać bez podawania procesora.</span><span class="sxs-lookup"><span data-stu-id="00e57-261">A time-slice specifies the maximum number of timer ticks (timer interrupts) that a thread can execute without giving up the processor.</span></span> <span data-ttu-id="00e57-262">W ThreadX skalowanie czasu jest dostępne dla każdego wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-262">In ThreadX, time-slicing is available on a per-thread basis.</span></span> <span data-ttu-id="00e57-263">Wycinek czasu wątku jest przypisywany podczas tworzenia i może być modyfikowany w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="00e57-263">The thread's time-slice is assigned during creation and can be modified during run-time.</span></span> <span data-ttu-id="00e57-264">Gdy wycinek czasu wygaśnie, wszystkie inne gotowe wątki o tym samym poziomie priorytetu otrzymają szansę wykonania przed ponownym uruchomieniem wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-264">When a time-slice expires, all other ready threads of the same priority level are given a chance to execute before the time-sliced thread executes again.</span></span>

<span data-ttu-id="00e57-265">Po zawieszeniu, że wycinek jest odświeżany przez cały wątek, zwalnia, sprawia, że wywołanie usługi ThreadX powoduje zastępujące lub sama jest wycinkiem.</span><span class="sxs-lookup"><span data-stu-id="00e57-265">A fresh thread time-slice is given to a thread after it suspends, relinquishes, makes a ThreadX service call that causes preemption, or is itself time-sliced.</span></span>

<span data-ttu-id="00e57-266">Po przeniesieniu wątku z podziałem czasowym zostanie ono wznowione przed innymi gotowe wątki o równym priorytecie dla pozostałej części czasu.</span><span class="sxs-lookup"><span data-stu-id="00e57-266">When a time-sliced thread is preempted, it will resume before other ready threads of equal priority for the remainder of its time-slice.</span></span>

> [!NOTE]
> <span data-ttu-id="00e57-267">*Korzystanie z wycinków czasu powoduje niewielkie obciążenie systemu. Ponieważ podział czasu jest przydatny tylko w przypadkach, w których wiele wątków ma ten sam priorytet, w wątkach mających unikatowy priorytet nie należy przypisywać wycinków czasu.*</span><span class="sxs-lookup"><span data-stu-id="00e57-267">*Using time-slicing results in a slight amount of system overhead. Because time-slicing is only useful in cases in which multiple threads share the same priority, threads having a unique priority should not be assigned a time-slice.*</span></span>

### <a name="preemption"></a><span data-ttu-id="00e57-268">Wywłaszczania</span><span class="sxs-lookup"><span data-stu-id="00e57-268">Preemption</span></span>

<span data-ttu-id="00e57-269">Zastępujący jest procesem tymczasowego przerwania wykonywania wątku na rzecz wątku o wyższym priorytecie.</span><span class="sxs-lookup"><span data-stu-id="00e57-269">Preemption is the process of temporarily interrupting an executing thread in favor of a higher-priority thread.</span></span> <span data-ttu-id="00e57-270">Ten proces jest niewidoczny dla wątku wykonawczego.</span><span class="sxs-lookup"><span data-stu-id="00e57-270">This process is invisible to the executing thread.</span></span> <span data-ttu-id="00e57-271">Po zakończeniu wątku o wyższym priorytecie kontrola jest przekazywana z powrotem do dokładnego miejsca, w którym nastąpiło przemieszczenie.</span><span class="sxs-lookup"><span data-stu-id="00e57-271">When the higher-priority thread is finished, control is transferred back to the exact place where the preemption took place.</span></span> <span data-ttu-id="00e57-272">Jest to bardzo ważna funkcja w systemach w czasie rzeczywistym, ponieważ ułatwia ona szybkie reagowanie na ważne zdarzenia aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-272">This is a very important feature in real-time systems because it facilitates fast response to important application events.</span></span> <span data-ttu-id="00e57-273">Mimo że jest to bardzo ważna funkcja, zastępujący może być również źródłem różnych problemów, w tym przeciążania, nadmiernego obciążenia i niewersjami priorytetów.</span><span class="sxs-lookup"><span data-stu-id="00e57-273">Although a very important feature, preemption can also be a source of a variety of problems, including starvation, excessive overhead, and priority inversion.</span></span>

### <a name="preemption-thresholdtrade"></a><span data-ttu-id="00e57-274">Próg przekroczenia&trade;</span><span class="sxs-lookup"><span data-stu-id="00e57-274">Preemption Threshold&trade;</span></span>

<span data-ttu-id="00e57-275">Aby uprościć niektóre z nietypowych problemów związanych z zastępując, ThreadX zapewnia unikatową i zaawansowaną funkcję o nazwie *próg* przekroczenia.</span><span class="sxs-lookup"><span data-stu-id="00e57-275">To ease some of the inherent problems of preemption, ThreadX provides a unique and advanced feature called *preemption-threshold*.</span></span>

<span data-ttu-id="00e57-276">Próg przekroczenia umożliwia wątek określający *priorytet dla* wyłączenia zastępujący.</span><span class="sxs-lookup"><span data-stu-id="00e57-276">A preemption-threshold allows a thread to specify a priority *ceiling* for disabling preemption.</span></span> <span data-ttu-id="00e57-277">Wątki, które mają wyższe priorytety niż limit, nadal mogą być przełożone, podczas gdy nie mogą być przełożone na mniejsze niż górny limit.</span><span class="sxs-lookup"><span data-stu-id="00e57-277">Threads that have higher priorities than the ceiling are still allowed to preempt, while those less than the ceiling are not allowed to preempt.</span></span>

<span data-ttu-id="00e57-278">Załóżmy na przykład, że wątek o priorytecie 20 współdziała tylko z grupą wątków o priorytetach od 15 do 20.</span><span class="sxs-lookup"><span data-stu-id="00e57-278">For example, suppose a thread of priority 20 only interacts with a group of threads that have priorities between 15 and 20.</span></span> <span data-ttu-id="00e57-279">W jej sekcjach krytycznych wątek o priorytecie 20 może ustawić jego próg przekroczenia na 15, uniemożliwiając tym samym przepełnianie ze wszystkich wątków, z którymi się komunikują.</span><span class="sxs-lookup"><span data-stu-id="00e57-279">During its critical sections, the thread of priority 20 can set its preemption-threshold to 15, thereby preventing preemption from all of the threads that it interacts with.</span></span> <span data-ttu-id="00e57-280">Nadal pozwala to na naprawdę ważne wątki (od 0 do 14), aby przewyższyć ten wątek podczas przetwarzania sekcji krytycznej, co skutkuje znacznie większą szybkością przetwarzania.</span><span class="sxs-lookup"><span data-stu-id="00e57-280">This still permits really important threads (priorities between 0 and 14) to preempt this thread during its critical section processing, which results in much more responsive processing.</span></span>

<span data-ttu-id="00e57-281">Oczywiście nadal jest możliwe, aby wątek wyłączył wszystkie przekroczenia przez ustawienie jego progu zastępujące na 0.</span><span class="sxs-lookup"><span data-stu-id="00e57-281">Of course, it is still possible for a thread to disable all preemption by setting its preemption-threshold to 0.</span></span> <span data-ttu-id="00e57-282">Dodatkowo można zmienić próg zastępujący w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="00e57-282">In addition, preemption-threshold can be changed during run-time.</span></span>

> [!NOTE]
> <span data-ttu-id="00e57-283">*Użycie wartości progowej przekroczenia powoduje wyłączenie wycinka czasu dla określonego wątku.*</span><span class="sxs-lookup"><span data-stu-id="00e57-283">*Using preemption-threshold disables time-slicing for the specified thread.*</span></span>

### <a name="priority-inheritance"></a><span data-ttu-id="00e57-284">Dziedziczenie priorytetów</span><span class="sxs-lookup"><span data-stu-id="00e57-284">Priority Inheritance</span></span>

<span data-ttu-id="00e57-285">ThreadX również obsługuje dziedziczenie opcjonalnego priorytetu w ramach usług muteksów opisanych w dalszej części tego rozdziału.</span><span class="sxs-lookup"><span data-stu-id="00e57-285">ThreadX also supports optional priority inheritance within its mutex services described later in this chapter.</span></span> <span data-ttu-id="00e57-286">Dziedziczenie priorytetowe umożliwia wątek o niższym priorytecie w celu tymczasowego założenia priorytetu wątku wysokiego priorytetu, który oczekuje na element mutex należący do wątku o niższym priorytecie.</span><span class="sxs-lookup"><span data-stu-id="00e57-286">Priority inheritance allows a lower priority thread to temporarily assume the priority of a high priority thread that is waiting for a mutex owned by the lower priority thread.</span></span> <span data-ttu-id="00e57-287">Ta funkcja ułatwia aplikacji uniknięcie niedeterministycznych priorytetów, eliminując zastępujące priorytety wątku pośredniego.</span><span class="sxs-lookup"><span data-stu-id="00e57-287">This capability helps the application to avoid nondeterministic priority inversion by eliminating preemption of intermediate thread priorities.</span></span> <span data-ttu-id="00e57-288">Oczywiście *próg zastępujący* może być używany do osiągnięcia podobnego wyniku.</span><span class="sxs-lookup"><span data-stu-id="00e57-288">Of course, *preemption-threshold* may be used to achieve a similar result.</span></span>

### <a name="thread-creation"></a><span data-ttu-id="00e57-289">Tworzenie wątku</span><span class="sxs-lookup"><span data-stu-id="00e57-289">Thread Creation</span></span>

<span data-ttu-id="00e57-290">Wątki aplikacji są tworzone podczas inicjowania lub podczas wykonywania innych wątków aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-290">Application threads are created during initialization or during the execution of other application threads.</span></span> <span data-ttu-id="00e57-291">Nie ma żadnego limitu liczby wątków, które mogą zostać utworzone przez aplikację.</span><span class="sxs-lookup"><span data-stu-id="00e57-291">There is no limit on the number of threads that can be created by an application.</span></span>

### <a name="thread-control-block-tx_thread"></a><span data-ttu-id="00e57-292">TX_THREAD bloku sterowania wątku</span><span class="sxs-lookup"><span data-stu-id="00e57-292">Thread Control Block TX_THREAD</span></span>

<span data-ttu-id="00e57-293">Charakterystyki każdego wątku są zawarte w jego bloku sterowania.</span><span class="sxs-lookup"><span data-stu-id="00e57-293">The characteristics of each thread are contained in its control block.</span></span> <span data-ttu-id="00e57-294">Ta struktura jest zdefiniowana w pliku ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-294">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="00e57-295">Blok sterowania wątku może znajdować się w dowolnym miejscu w pamięci, ale najczęściej jest to, że formant blokuje strukturę globalną poprzez definiowanie jej poza zakresem dowolnej funkcji.</span><span class="sxs-lookup"><span data-stu-id="00e57-295">A thread's control block can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

<span data-ttu-id="00e57-296">Lokalizowanie bloku sterowania w innych obszarach wymaga nieco więcej informacji, podobnie jak wszystkie dynamicznie przydzieloną pamięć.</span><span class="sxs-lookup"><span data-stu-id="00e57-296">Locating the control block in other areas requires a bit more care, just like all dynamically-allocated memory.</span></span> <span data-ttu-id="00e57-297">Jeśli blok sterowania jest przypisywany w ramach funkcji języka C, skojarzona z nim pamięć jest częścią stosu wywołującego wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-297">If a control block is allocated within a C function, the memory associated with it is part of the calling thread's stack.</span></span> <span data-ttu-id="00e57-298">Ogólnie rzecz biorąc, Unikaj używania lokalnego magazynu dla bloków kontroli, ponieważ po powrocie funkcji jest wydawana cała jego przestrzeń stosów zmiennych lokalnych, niezależnie od tego, czy inny wątek używa go dla bloku sterowania.</span><span class="sxs-lookup"><span data-stu-id="00e57-298">In general, avoid using local storage for control blocks because after the function returns, all of its local variable stack space is released—regardless of whether another thread is using it for a control block.</span></span>

<span data-ttu-id="00e57-299">W większości przypadków aplikacja jest Oblivious do zawartości bloku sterowania wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-299">In most cases, the application is oblivious to the contents of the thread's control block.</span></span> <span data-ttu-id="00e57-300">Istnieją jednak sytuacje, szczególnie podczas debugowania, które są przydatne w przypadku niektórych elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="00e57-300">However, there are some situations, especially during debug, in which looking at certain members is useful.</span></span> <span data-ttu-id="00e57-301">Poniżej przedstawiono niektóre z bardziej przydatnych elementów członkowskich bloku sterowania.</span><span class="sxs-lookup"><span data-stu-id="00e57-301">The following are some of the more useful control block members.</span></span>

<span data-ttu-id="00e57-302">**tx_thread_run_count** zawiera Licznik liczby wystąpień wątku, który został zaplanowany.</span><span class="sxs-lookup"><span data-stu-id="00e57-302">**tx_thread_run_count** contains a counter of the number of many times the thread has been scheduled.</span></span> <span data-ttu-id="00e57-303">Rosnący licznik wskazuje, że wątek jest zaplanowany i wykonywany.</span><span class="sxs-lookup"><span data-stu-id="00e57-303">An increasing counter indicates the thread is being scheduled and executed.</span></span>

<span data-ttu-id="00e57-304">**tx_thread_state** zawiera stan skojarzonego wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-304">**tx_thread_state** contains the state of the associated thread.</span></span> <span data-ttu-id="00e57-305">Poniżej wymieniono możliwe stany wątków.</span><span class="sxs-lookup"><span data-stu-id="00e57-305">The following lists the possible thread states.</span></span>

|  <span data-ttu-id="00e57-306">Stan wątku</span><span class="sxs-lookup"><span data-stu-id="00e57-306">Thread state</span></span>   | <span data-ttu-id="00e57-307">Wartość</span><span class="sxs-lookup"><span data-stu-id="00e57-307">Value</span></span> |
| --------------- | ------ |
| <span data-ttu-id="00e57-308">TX_READY</span><span class="sxs-lookup"><span data-stu-id="00e57-308">TX_READY</span></span>       | <span data-ttu-id="00e57-309">0x00</span><span class="sxs-lookup"><span data-stu-id="00e57-309">(0x00)</span></span> |
| <span data-ttu-id="00e57-310">TX_COMPLETED</span><span class="sxs-lookup"><span data-stu-id="00e57-310">TX_COMPLETED</span></span>   | <span data-ttu-id="00e57-311">0x01</span><span class="sxs-lookup"><span data-stu-id="00e57-311">(0x01)</span></span> |
| <span data-ttu-id="00e57-312">TX_TERMINATED</span><span class="sxs-lookup"><span data-stu-id="00e57-312">TX_TERMINATED</span></span>  | <span data-ttu-id="00e57-313">0x02</span><span class="sxs-lookup"><span data-stu-id="00e57-313">(0x02)</span></span> |
| <span data-ttu-id="00e57-314">TX_SUSPENDED</span><span class="sxs-lookup"><span data-stu-id="00e57-314">TX_SUSPENDED</span></span>   | <span data-ttu-id="00e57-315">(0x03)</span><span class="sxs-lookup"><span data-stu-id="00e57-315">(0x03)</span></span> |
| <span data-ttu-id="00e57-316">TX_SLEEP</span><span class="sxs-lookup"><span data-stu-id="00e57-316">TX_SLEEP</span></span>       | <span data-ttu-id="00e57-317">(0x04)</span><span class="sxs-lookup"><span data-stu-id="00e57-317">(0x04)</span></span> |
| <span data-ttu-id="00e57-318">TX_QUEUE_SUSP</span><span class="sxs-lookup"><span data-stu-id="00e57-318">TX_QUEUE_SUSP</span></span> | <span data-ttu-id="00e57-319">(0x05)</span><span class="sxs-lookup"><span data-stu-id="00e57-319">(0x05)</span></span> |
| <span data-ttu-id="00e57-320">TX_SEMAPHORE_SUSP</span><span class="sxs-lookup"><span data-stu-id="00e57-320">TX_SEMAPHORE_SUSP</span></span> | <span data-ttu-id="00e57-321">(0x06)</span><span class="sxs-lookup"><span data-stu-id="00e57-321">(0x06)</span></span> |
| <span data-ttu-id="00e57-322">TX_EVENT_FLAG</span><span class="sxs-lookup"><span data-stu-id="00e57-322">TX_EVENT_FLAG</span></span>   | <span data-ttu-id="00e57-323">(0x07)</span><span class="sxs-lookup"><span data-stu-id="00e57-323">(0x07)</span></span> |
| <span data-ttu-id="00e57-324">TX_BLOCK_MEMORY</span><span class="sxs-lookup"><span data-stu-id="00e57-324">TX_BLOCK_MEMORY</span></span> | <span data-ttu-id="00e57-325">(0x08)</span><span class="sxs-lookup"><span data-stu-id="00e57-325">(0x08)</span></span> |
| <span data-ttu-id="00e57-326">TX_BYTE_MEMORY</span><span class="sxs-lookup"><span data-stu-id="00e57-326">TX_BYTE_MEMORY</span></span>  | <span data-ttu-id="00e57-327">0x09</span><span class="sxs-lookup"><span data-stu-id="00e57-327">(0x09)</span></span> |
| <span data-ttu-id="00e57-328">TX_MUTEX_SUSP</span><span class="sxs-lookup"><span data-stu-id="00e57-328">TX_MUTEX_SUSP</span></span>   | <span data-ttu-id="00e57-329">0x0D</span><span class="sxs-lookup"><span data-stu-id="00e57-329">(0x0D)</span></span> |

> [!NOTE]
> <span data-ttu-id="00e57-330">*Oczywiście istnieje wiele innych interesujących pól w bloku sterowania wątku, w tym Wskaźnik stosu, wartość wycinka czasu, priorytety itp. Użytkownicy mogą przeglądać elementy członkowskie bloku kontrolki, ale modyfikacje są absolutnie zabronione.*</span><span class="sxs-lookup"><span data-stu-id="00e57-330">*Of course there are many other interesting fields in the thread control block, including the stack pointer, time-slice value, priorities, etc. Users are welcome to review control block members, but modifications are strictly prohibited!*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="00e57-331">*Nie ma żadnego elementu równego dla stanu "Executing" wymienionego wcześniej w tej sekcji. Nie jest to konieczne, ponieważ w danym momencie istnieje tylko jeden wykonywany wątek. Stan wątku wykonywania jest również* **TX_READY**.</span><span class="sxs-lookup"><span data-stu-id="00e57-331">*There is no equate for the "executing" state mentioned earlier in this section. It is not necessary because there is only one executing thread at a given time. The state of an executing thread is also* **TX_READY**.</span></span>

### <a name="currently-executing-thread"></a><span data-ttu-id="00e57-332">Aktualnie wykonywany wątek</span><span class="sxs-lookup"><span data-stu-id="00e57-332">Currently Executing Thread</span></span>

<span data-ttu-id="00e57-333">Jak wspomniano wcześniej, w danym momencie jest wykonywany tylko jeden wątek.</span><span class="sxs-lookup"><span data-stu-id="00e57-333">As mentioned before, there is only one thread executing at any given time.</span></span> <span data-ttu-id="00e57-334">Istnieje kilka sposobów identyfikacji wątku wykonującego, w zależności od tego, który wątek wykonuje żądanie.</span><span class="sxs-lookup"><span data-stu-id="00e57-334">There are several ways to identify the executing thread, depending on which thread is making the request.</span></span>
<span data-ttu-id="00e57-335">Segment programu może uzyskać adres bloku sterowania wykonywanego wątku przez wywołanie ***tx_thread_identify***.</span><span class="sxs-lookup"><span data-stu-id="00e57-335">A program segment can get the control block address of the executing thread by calling ***tx_thread_identify***.</span></span> <span data-ttu-id="00e57-336">Jest to przydatne w przypadku udostępnionych części kodu aplikacji, które są wykonywane z wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="00e57-336">This is useful in shared portions of application code that are executed from multiple threads.</span></span>

<span data-ttu-id="00e57-337">W sesji debugowania użytkownicy mogą przeanalizować wewnętrzny wskaźnik ThreadX ***_tx_thread_current_ptr***.</span><span class="sxs-lookup"><span data-stu-id="00e57-337">In debug sessions, users can examine the internal ThreadX pointer ***_tx_thread_current_ptr***.</span></span> <span data-ttu-id="00e57-338">Zawiera adres bloku kontroli aktualnie wykonywanego wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-338">It contains the control block address of the currently executing thread.</span></span> <span data-ttu-id="00e57-339">Jeśli ten wskaźnik ma wartość NULL, żaden wątek aplikacji nie jest wykonywany; oznacza to, że ThreadX oczekuje w pętli planowania, aby wątek stał się gotowy.</span><span class="sxs-lookup"><span data-stu-id="00e57-339">If this pointer is NULL, no application thread is executing; i.e., ThreadX is waiting in its scheduling loop for a thread to become ready.</span></span>

### <a name="thread-stack-area"></a><span data-ttu-id="00e57-340">Obszar stosu wątków</span><span class="sxs-lookup"><span data-stu-id="00e57-340">Thread Stack Area</span></span>

<span data-ttu-id="00e57-341">Każdy wątek musi mieć własny stos do zapisywania kontekstu ostatniego wykonywania i użycia kompilatora.</span><span class="sxs-lookup"><span data-stu-id="00e57-341">Each thread must have its own stack for saving the context of its last execution and compiler use.</span></span> <span data-ttu-id="00e57-342">Większość kompilatorów języka C używa stosu do tworzenia wywołań funkcji i tymczasowej alokacji zmiennych lokalnych.</span><span class="sxs-lookup"><span data-stu-id="00e57-342">Most C compilers use the stack for making function calls and for temporarily allocating local variables.</span></span> <span data-ttu-id="00e57-343">Rysunek 6 przedstawia stos typowego wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-343">Figure 6 shows a typical thread's stack.</span></span>

<span data-ttu-id="00e57-344">Miejsce, w którym stos wątków znajduje się w pamięci, jest do aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-344">Where a thread stack is located in memory is up to the application.</span></span> <span data-ttu-id="00e57-345">Obszar stosu jest określany podczas tworzenia wątku i może znajdować się w dowolnym miejscu w przestrzeni adresowej docelowej.</span><span class="sxs-lookup"><span data-stu-id="00e57-345">The stack area is specified during thread creation and can be located anywhere in the target's address space.</span></span> <span data-ttu-id="00e57-346">Jest to ważna funkcja, ponieważ umożliwia aplikacjom Ulepszanie wydajności ważnych wątków przez umieszczenie ich stosu w dużej szybkości pamięci RAM.</span><span class="sxs-lookup"><span data-stu-id="00e57-346">This is an important feature because it allows applications to improve performance of important threads by placing their stack in high-speed RAM.</span></span>

<span data-ttu-id="00e57-347">**Obszar pamięci stosu** (przykład)</span><span class="sxs-lookup"><span data-stu-id="00e57-347">**Stack Memory Area** (example)</span></span>

![Typowy stos wątków](./media/user-guide/typical-thread-stack.png)

<span data-ttu-id="00e57-349">**RYSUNEK 6. Typowy stos wątków**</span><span class="sxs-lookup"><span data-stu-id="00e57-349">**FIGURE 6. Typical Thread Stack**</span></span>

<span data-ttu-id="00e57-350">Jak duży stos powinien być jednym z najczęściej zadawanych pytań dotyczących wątków.</span><span class="sxs-lookup"><span data-stu-id="00e57-350">How big a stack should be is one of the most frequently asked questions about threads.</span></span> <span data-ttu-id="00e57-351">Obszar stosu wątku musi być wystarczająco duży, aby pomieścić najgorsze wywołanie funkcji, alokację zmiennej lokalnej i zapisanie jej ostatniego kontekstu wykonania.</span><span class="sxs-lookup"><span data-stu-id="00e57-351">A thread's stack area must be large enough to accommodate worst-case function call nesting, local variable allocation, and saving its last execution context.</span></span>

<span data-ttu-id="00e57-352">Minimalny rozmiar stosu, **TX_MINIMUM_STACK**, jest definiowany przez ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-352">The minimum stack size, **TX_MINIMUM_STACK**, is defined by ThreadX.</span></span> <span data-ttu-id="00e57-353">Stos tego rozmiaru obsługuje zapisywanie kontekstu wątku i minimalnej liczby wywołań funkcji i alokacji zmiennych lokalnych.</span><span class="sxs-lookup"><span data-stu-id="00e57-353">A stack of this size supports saving a thread's context and minimum amount of function calls and local variable allocation.</span></span>

<span data-ttu-id="00e57-354">W przypadku większości wątków jednak minimalny rozmiar stosu jest zbyt mały, a użytkownik musi upewnić się, że wymaganie rozmiaru najgorszej wielkości liter poprzez sprawdzenie zagnieżdżenia wywołań funkcji i alokacji zmiennych lokalnych.</span><span class="sxs-lookup"><span data-stu-id="00e57-354">For most threads, however, the minimum stack size is too small, and the user must ascertain the worst-case size requirement by examining function-call nesting and local variable allocation.</span></span> <span data-ttu-id="00e57-355">Oczywiście lepiej jest zacząć od większego obszaru stosu.</span><span class="sxs-lookup"><span data-stu-id="00e57-355">Of course, it is always better to start with a larger stack area.</span></span>

<span data-ttu-id="00e57-356">Po debugowaniu aplikacji można dostosować rozmiary stosu wątków, jeśli ilość pamięci jest nietrwała.</span><span class="sxs-lookup"><span data-stu-id="00e57-356">After the application is debugged, it is possible to tune the thread stack sizes if memory is scarce.</span></span> <span data-ttu-id="00e57-357">Ulubioną lewę jest to, aby ustawić wszystkie obszary stosu z łatwym do zidentyfikowania wzorcem danych, takim jak (0xEFEF) przed utworzeniem wątków.</span><span class="sxs-lookup"><span data-stu-id="00e57-357">A favorite trick is to preset all stack areas with an easily identifiable data pattern like (0xEFEF) prior to creating the threads.</span></span> <span data-ttu-id="00e57-358">Po dokładnym umieszczeniu aplikacji przez tępy obszary stosu można sprawdzić, aby zobaczyć, jak dużo stosu zostało faktycznie zużyte przez znalezienie obszaru stosu, w którym wzorzec danych jest wciąż nienaruszony.</span><span class="sxs-lookup"><span data-stu-id="00e57-358">After the application has been thoroughly put through its paces, the stack areas can be examined to see how much stack was actually used by finding the area of the stack where the data pattern is still intact.</span></span> <span data-ttu-id="00e57-359">Rysunek 7 przedstawia ustawienia wstępne stosu 0xEFEF po dokładnym wykonaniu wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-359">Figure 7 shows a stack preset to 0xEFEF after thorough thread execution.</span></span>

<span data-ttu-id="00e57-360">**Obszar pamięci stosu** (inny przykład)</span><span class="sxs-lookup"><span data-stu-id="00e57-360">**Stack Memory Area** (another example)</span></span>

![Ustawienia wstępne stosu do 0xEFEF \*](./media/user-guide/stack-preset.png)

<span data-ttu-id="00e57-362">**RYSUNEK 7. Ustawienia wstępne stosu do 0xEFEF**</span><span class="sxs-lookup"><span data-stu-id="00e57-362">**FIGURE 7. Stack Preset to 0xEFEF**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="00e57-363">*Domyślnie ThreadX inicjuje każdy bajt każdego stosu wątku z wartością 0xEF.*</span><span class="sxs-lookup"><span data-stu-id="00e57-363">*By default, ThreadX initializes every byte of each thread stack with a value of 0xEF.*</span></span>

### <a name="memory-pitfalls"></a><span data-ttu-id="00e57-364">Pułapek pamięci</span><span class="sxs-lookup"><span data-stu-id="00e57-364">Memory Pitfalls</span></span>

<span data-ttu-id="00e57-365">Wymagania dotyczące stosu dla wątków mogą być duże.</span><span class="sxs-lookup"><span data-stu-id="00e57-365">The stack requirements for threads can be large.</span></span> <span data-ttu-id="00e57-366">W związku z tym ważne jest, aby zaprojektować aplikację w celu uzyskania odpowiedniej liczby wątków.</span><span class="sxs-lookup"><span data-stu-id="00e57-366">Therefore, it is important to design the application to have a reasonable number of threads.</span></span> <span data-ttu-id="00e57-367">Ponadto należy podjąć pewne czynności, aby uniknąć nadmiernego użycia stosu w wątkach.</span><span class="sxs-lookup"><span data-stu-id="00e57-367">Furthermore, some care must be taken to avoid excessive stack usage within threads.</span></span> <span data-ttu-id="00e57-368">Należy unikać stosowania algorytmów cyklicznych i dużych lokalnych struktur danych.</span><span class="sxs-lookup"><span data-stu-id="00e57-368">Recursive algorithms and large local data structures should be avoided.</span></span>

<span data-ttu-id="00e57-369">W większości przypadków nadmiarowy stos sprawia, że wykonanie wątku powoduje uszkodzenie pamięci sąsiedniej (zwykle przed) jej obszaru stosu.</span><span class="sxs-lookup"><span data-stu-id="00e57-369">In most cases, an overflowed stack causes thread execution to corrupt memory adjacent (usually before) its stack area.</span></span> <span data-ttu-id="00e57-370">Wyniki są nieprzewidywalne, ale większość często powoduje nienaturalną zmianę w liczniku programu.</span><span class="sxs-lookup"><span data-stu-id="00e57-370">The results are unpredictable, but most often result in an unnatural change in the program counter.</span></span> <span data-ttu-id="00e57-371">Jest to często nazywane "przechodzeniem do chwastów".</span><span class="sxs-lookup"><span data-stu-id="00e57-371">This is often called "jumping into the weeds."</span></span> <span data-ttu-id="00e57-372">Oczywiście jedynym sposobem na uniknięcie tego jest upewnienie się, że wszystkie stosy wątków są wystarczająco duże.</span><span class="sxs-lookup"><span data-stu-id="00e57-372">Of course, the only way to prevent this is to ensure all thread stacks are large enough.</span></span>

### <a name="optional-run-time-stack-checking"></a><span data-ttu-id="00e57-373">Opcjonalne sprawdzanie stosu czasu wykonywania</span><span class="sxs-lookup"><span data-stu-id="00e57-373">Optional Run-time Stack Checking</span></span>

<span data-ttu-id="00e57-374">ThreadX zapewnia możliwość sprawdzania stosu każdego wątku w celu uszkodzenia w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="00e57-374">ThreadX provides the ability to check each thread's stack for corruption during run-time.</span></span> <span data-ttu-id="00e57-375">Domyślnie ThreadX wypełnia każdy bajt stosów wątków przy użyciu wzorca danych 0xEF podczas tworzenia.</span><span class="sxs-lookup"><span data-stu-id="00e57-375">By default, ThreadX fills every byte of thread stacks with a 0xEF data pattern during creation.</span></span> <span data-ttu-id="00e57-376">Jeśli aplikacja kompiluje bibliotekę ThreadX z definicją **TX_ENABLE_STACK_CHECKING** , ThreadX będzie przeanalizować stos każdego wątku pod kątem uszkodzenia w miarę jego wstrzymania lub wznowienia.</span><span class="sxs-lookup"><span data-stu-id="00e57-376">If the application builds the ThreadX library with **TX_ENABLE_STACK_CHECKING** defined, ThreadX will examine each thread's stack for corruption as it is suspended or resumed.</span></span> <span data-ttu-id="00e57-377">Jeśli wykryto uszkodzenie stosu, ThreadX wywoła procedurę obsługi błędów stosu aplikacji określoną przez wywołanie do **_tx_thread_stack_error_notify_*_. W przeciwnym razie, jeśli nie określono żadnej procedury obsługi błędów stosu, ThreadX wywoła procedurę wewnętrzną _\* _ _tx_thread_stack_error_handler_*\* .</span><span class="sxs-lookup"><span data-stu-id="00e57-377">If stack corruption is detected, ThreadX will call the application's stack error handling routine as specified by the call to **_tx_thread_stack_error_notify_*_. Otherwise, if no stack error handler was specified, ThreadX will call the internal _\* _ _tx_thread_stack_error_handler_*\* routine.</span></span>

### <a name="reentrancy"></a><span data-ttu-id="00e57-378">Ponowne wejścia</span><span class="sxs-lookup"><span data-stu-id="00e57-378">Reentrancy</span></span>

<span data-ttu-id="00e57-379">Jednym z prawdziwych Beauties wielowątkowości jest to, że ta sama funkcja języka C może być wywoływana z wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="00e57-379">One of the real beauties of multithreading is that the same C function can be called from multiple threads.</span></span> <span data-ttu-id="00e57-380">Zapewnia to doskonałe możliwości, a także pomaga zmniejszyć ilość miejsca w kodzie.</span><span class="sxs-lookup"><span data-stu-id="00e57-380">This provides great power and also helps reduce code space.</span></span> <span data-ttu-id="00e57-381">Jednak wymaga to, aby funkcje języka C wywoływane z wielu wątków były *współużytkowane*.</span><span class="sxs-lookup"><span data-stu-id="00e57-381">However, it does require that C functions called from multiple threads are *reentrant*.</span></span>

<span data-ttu-id="00e57-382">Zasadniczo funkcja współużytkowania przechowuje adres zwrotny obiektu wywołującego na bieżącym stosie i nie bazuje na globalnych lub statycznych zmiennych języka C, które wcześniej zostały skonfigurowane.</span><span class="sxs-lookup"><span data-stu-id="00e57-382">Basically, a reentrant function stores the caller's return address on the current stack and does not rely on global or static C variables that it previously set up.</span></span> <span data-ttu-id="00e57-383">Większość kompilatorów umieszcza adres zwrotny na stosie.</span><span class="sxs-lookup"><span data-stu-id="00e57-383">Most compilers place the return address on the stack.</span></span> <span data-ttu-id="00e57-384">W związku z tym deweloperzy aplikacji mogą martwić się o użycie *Globals* i elementów *statycznych*.</span><span class="sxs-lookup"><span data-stu-id="00e57-384">Hence, application developers must only worry about the use of *globals* and *statics*.</span></span>

<span data-ttu-id="00e57-385">Przykładem funkcji, która nie jest współużytkowana, jest funkcja tokenu ciągu ***strtok*** znaleziona w standardowej bibliotece C.</span><span class="sxs-lookup"><span data-stu-id="00e57-385">An example of a non-reentrant function is the string token function ***strtok*** found in the standard C library.</span></span> <span data-ttu-id="00e57-386">Ta funkcja "zapamiętuje" poprzedni wskaźnik ciągu dla kolejnych wywołań.</span><span class="sxs-lookup"><span data-stu-id="00e57-386">This function "remembers" the previous string pointer on subsequent calls.</span></span> <span data-ttu-id="00e57-387">Robi to ze statycznym wskaźnikiem ciągu.</span><span class="sxs-lookup"><span data-stu-id="00e57-387">It does this with a static string pointer.</span></span> <span data-ttu-id="00e57-388">Jeśli ta funkcja jest wywoływana z wielu wątków, prawdopodobnie zwróci nieprawidłowy wskaźnik.</span><span class="sxs-lookup"><span data-stu-id="00e57-388">If this function is called from multiple threads, it would most likely return an invalid pointer.</span></span>

### <a name="thread-priority-pitfalls"></a><span data-ttu-id="00e57-389">Priorytet wątku pułapek</span><span class="sxs-lookup"><span data-stu-id="00e57-389">Thread Priority Pitfalls</span></span>

<span data-ttu-id="00e57-390">Wybór priorytetów wątków jest jednym z najważniejszych aspektów wielowątkowości.</span><span class="sxs-lookup"><span data-stu-id="00e57-390">Selecting thread priorities is one of the most important aspects of multithreading.</span></span> <span data-ttu-id="00e57-391">Czasami bardzo zachęca się do przypisywania priorytetów na podstawie postrzeganych koncepcji o znaczeniu wątku zamiast określania, co jest dokładnie wymagane w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="00e57-391">It is sometimes very tempting to assign priorities based on a perceived notion of thread importance rather than determining what is exactly required during run-time.</span></span> <span data-ttu-id="00e57-392">Nieprawidłowe użycie priorytetów wątków może zablokować dostęp inne wątki, utworzyć niewersję priorytetu, zmniejszyć przepustowość przetwarzania i sprawić, że zachowanie w czasie wykonywania aplikacji jest trudne do zrozumienia.</span><span class="sxs-lookup"><span data-stu-id="00e57-392">Misuse of thread priorities can starve other threads, create priority inversion, reduce processing bandwidth, and make the application's run-time behavior difficult to understand.</span></span>

<span data-ttu-id="00e57-393">Jak wspomniano wcześniej, ThreadX zapewnia oparty na priorytetach algorytm planowania z przeznaczeniem.</span><span class="sxs-lookup"><span data-stu-id="00e57-393">As mentioned before, ThreadX provides a priority-based, preemptive scheduling algorithm.</span></span> <span data-ttu-id="00e57-394">Wątki o niższym priorytecie nie są wykonywane, dopóki nie są gotowe do wykonania żadne wątki o wyższym priorytecie.</span><span class="sxs-lookup"><span data-stu-id="00e57-394">Lower priority threads do not execute until there are no higher priority threads ready for execution.</span></span> <span data-ttu-id="00e57-395">Jeśli wątek o wyższym priorytecie zawsze jest gotowy, wątki o niższym priorytecie nigdy nie są wykonywane.</span><span class="sxs-lookup"><span data-stu-id="00e57-395">If a higher priority thread is always ready, the lower priority threads never execute.</span></span> <span data-ttu-id="00e57-396">Ten warunek jest nazywany *przetrzymaniem wątku*.</span><span class="sxs-lookup"><span data-stu-id="00e57-396">This condition is called *thread starvation*.</span></span>

<span data-ttu-id="00e57-397">Większość problemów z zablokowanie wątków jest wykrywanych wczesnie w debugowaniu i można je rozwiązać przez zapewnienie, że priorytety o wyższym priorytecie nie są stale wykonywane.</span><span class="sxs-lookup"><span data-stu-id="00e57-397">Most thread starvation problems are detected early in debug and can be solved by ensuring that higher priority threads don't execute continuously.</span></span> <span data-ttu-id="00e57-398">Alternatywnie można dodać logikę do aplikacji, która stopniowo podnosi priorytet wątków Starved do momentu uzyskania szansy do wykonania.</span><span class="sxs-lookup"><span data-stu-id="00e57-398">Alternatively, logic can be added to the application that gradually raises the priority of starved threads until they get a chance to execute.</span></span>

<span data-ttu-id="00e57-399">Inna Pitfall skojarzona z priorytetami wątków jest w *wersji priorytetowej*.</span><span class="sxs-lookup"><span data-stu-id="00e57-399">Another pitfall associated with thread priorities is *priority inversion*.</span></span> <span data-ttu-id="00e57-400">Priorytetowa wersja ma miejsce, gdy wątek o wyższym priorytecie jest zawieszony, ponieważ wątek o niższym priorytecie ma wymagany zasób.</span><span class="sxs-lookup"><span data-stu-id="00e57-400">Priority inversion takes place when a higher priority thread is suspended because a lower priority thread has a needed resource.</span></span> <span data-ttu-id="00e57-401">Oczywiście w niektórych przypadkach jest konieczne, aby dwa wątki o różnym priorytecie współdzielą wspólne zasoby.</span><span class="sxs-lookup"><span data-stu-id="00e57-401">Of course, in some instances it is necessary for two threads of different priority to share a common resource.</span></span> <span data-ttu-id="00e57-402">Jeśli te wątki są jedynymi aktywnymi, czas niewersji priorytetu jest ograniczany przez czas, w którym wątek niższego priorytetu utrzymuje zasób.</span><span class="sxs-lookup"><span data-stu-id="00e57-402">If these threads are the only ones active, the priority inversion time is bounded by the time the lower priority thread holds the resource.</span></span> <span data-ttu-id="00e57-403">Ten warunek jest deterministyczny i całkiem normalny.</span><span class="sxs-lookup"><span data-stu-id="00e57-403">This condition is both deterministic and quite normal.</span></span> <span data-ttu-id="00e57-404">Jeśli jednak wątki o priorytecie pośrednim staną się aktywne w stanie niewersji priorytetu, czas braku wersji nie jest już deterministyczny i może spowodować błąd aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-404">However, if threads of intermediate priority become active during this priority inversion condition, the priority inversion time is no longer deterministic and could cause an application failure.</span></span>

<span data-ttu-id="00e57-405">Istnieją głównie trzy różne metody uniemożliwiające niedeterministyczną wersję priorytetu w ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-405">There are principally three distinct methods of preventing nondeterministic priority inversion in ThreadX.</span></span> <span data-ttu-id="00e57-406">Najpierw wybór priorytetu aplikacji oraz zachowanie w czasie wykonywania mogą być zaprojektowane w sposób, który uniemożliwia problem z nieprawidłową wersją.</span><span class="sxs-lookup"><span data-stu-id="00e57-406">First, the application priority selections and run-time behavior can be designed in a manner that prevents the priority inversion problem.</span></span> <span data-ttu-id="00e57-407">Drugi, wątki o niższym priorytecie mogą korzystać z *progu* przekroczenia, aby blokować przekroczenie z wątków pośrednich, a współużytkują zasoby o wyższym priorytecie.</span><span class="sxs-lookup"><span data-stu-id="00e57-407">Second, lower priority threads can utilize *preemption threshold* to block preemption from intermediate threads while they share resources with higher priority threads.</span></span> <span data-ttu-id="00e57-408">Na koniec wątki korzystające z obiektów mutex ThreadX do ochrony zasobów systemowych mogą korzystać z opcjonalnego *dziedziczenia priorytetu* muteksu w celu wyeliminowania niedeterministycznej wersji priorytetu.</span><span class="sxs-lookup"><span data-stu-id="00e57-408">Finally, threads using ThreadX mutex objects to protect system resources may utilize the optional mutex *priority inheritance* to eliminate nondeterministic priority inversion.</span></span>

### <a name="priority-overhead"></a><span data-ttu-id="00e57-409">Priorytetowe narzuty</span><span class="sxs-lookup"><span data-stu-id="00e57-409">Priority Overhead</span></span>

<span data-ttu-id="00e57-410">Jednym z najczęstszych sposobów zmniejszenia obciążenia w wielowątkowości jest zmniejszenie liczby przełączeń kontekstu.</span><span class="sxs-lookup"><span data-stu-id="00e57-410">One of the most overlooked ways to reduce overhead in multithreading is to reduce the number of context switches.</span></span> <span data-ttu-id="00e57-411">Jak wspomniano wcześniej, przełącznik kontekstu występuje, gdy wykonywanie wątku o wyższym priorytecie jest preferowane przez wykonywany wątek.</span><span class="sxs-lookup"><span data-stu-id="00e57-411">As previously mentioned, a context switch occurs when execution of a higher priority thread is favored over that of the executing thread.</span></span> <span data-ttu-id="00e57-412">Należy zauważyć, że wątki o wyższym priorytecie mogą stać się gotowe jako wynik obu zdarzeń zewnętrznych (na przykład przerwań) i od wywołań usługi wykonanych przez wątek wykonujący.</span><span class="sxs-lookup"><span data-stu-id="00e57-412">It is worthwhile to mention that higher priority threads can become ready as a result of both external events (like interrupts) and from service calls made by the executing thread.</span></span>

<span data-ttu-id="00e57-413">W celu zilustrowania priorytetów wątków związanych z przełączaniem kontekstu należy założyć trzy środowiska wątku z wątkami o nazwie *thread_1*, *thread_2* i *thread_3*.</span><span class="sxs-lookup"><span data-stu-id="00e57-413">To illustrate the effects thread priorities have on context switch overhead, assume a three thread environment with threads named *thread_1*, *thread_2*, and *thread_3*.</span></span> <span data-ttu-id="00e57-414">Załóżmy, że wszystkie wątki w stanie zawieszania oczekują na komunikat.</span><span class="sxs-lookup"><span data-stu-id="00e57-414">Assume further that all of the threads are in a state of suspension waiting for a message.</span></span> <span data-ttu-id="00e57-415">Gdy thread_1 otrzymuje komunikat, natychmiast przekaże go do thread_2.</span><span class="sxs-lookup"><span data-stu-id="00e57-415">When thread_1 receives a message, it immediately forwards it to thread_2.</span></span> <span data-ttu-id="00e57-416">Następnie Thread_2 przekazuje komunikat do thread_3.</span><span class="sxs-lookup"><span data-stu-id="00e57-416">Thread_2 then forwards the message to thread_3.</span></span> <span data-ttu-id="00e57-417">Thread_3 po prostu odrzuca komunikat.</span><span class="sxs-lookup"><span data-stu-id="00e57-417">Thread_3 just discards the message.</span></span> <span data-ttu-id="00e57-418">Gdy każdy wątek przetwarza swój komunikat, wraca i czeka na kolejną wiadomość.</span><span class="sxs-lookup"><span data-stu-id="00e57-418">After each thread processes its message, it goes back and waits for another message.</span></span>

<span data-ttu-id="00e57-419">Przetwarzanie wymagane do wykonania tych trzech wątków różni się znacznie w zależności od ich priorytetów.</span><span class="sxs-lookup"><span data-stu-id="00e57-419">The processing required to execute these three threads varies greatly depending on their priorities.</span></span> <span data-ttu-id="00e57-420">Jeśli wszystkie wątki mają ten sam priorytet, przełączenie do jednego kontekstu następuje przed wykonaniem każdego wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-420">If all of the threads have the same priority, a single context switch occurs before the execution of each thread.</span></span> <span data-ttu-id="00e57-421">Przełącznik kontekstu występuje, gdy każdy wątek zawiesza się w pustej kolejce komunikatów.</span><span class="sxs-lookup"><span data-stu-id="00e57-421">The context switch occurs when each thread suspends on an empty message queue.</span></span>

<span data-ttu-id="00e57-422">Jeśli jednak thread_2 ma wyższy priorytet niż thread_1, a thread_3 jest wyższym priorytetem niż thread_2, Liczba przełączeń kontekstu podwaja się.</span><span class="sxs-lookup"><span data-stu-id="00e57-422">However, if thread_2 is higher priority than thread_1 and thread_3 is higher priority than thread_2, the number of context switches doubles.</span></span> <span data-ttu-id="00e57-423">Jest to spowodowane tym, że inny przełącznik kontekstu występuje w ramach usługi *tx_queue_send* , gdy wykryje, że jest teraz gotowy wątek o wyższym priorytecie.</span><span class="sxs-lookup"><span data-stu-id="00e57-423">This is because another context switch occurs inside of the *tx_queue_send* service when it detects that a higher priority thread is now ready.</span></span>

<span data-ttu-id="00e57-424">Mechanizm przekroczenia ThreadXu może uniknąć tych dodatkowych przełączników kontekstowych i nadal zezwalać na wcześniej wymienione priorytety.</span><span class="sxs-lookup"><span data-stu-id="00e57-424">The ThreadX preemption-threshold mechanism can avoid these extra context switches and still allow the previously mentioned priority selections.</span></span> <span data-ttu-id="00e57-425">Jest to ważna funkcja, ponieważ pozwala ona na kilka priorytetów wątków podczas planowania, jednocześnie eliminując niektóre niechciane przełączanie kontekstu między nimi podczas wykonywania wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-425">This is an important feature because it allows several thread priorities during scheduling, while at the same time eliminating some of the unwanted context switching between them during thread execution.</span></span>

### <a name="run-time-thread-performance-information"></a><span data-ttu-id="00e57-426">Informacje o wydajności wątku czasu wykonywania</span><span class="sxs-lookup"><span data-stu-id="00e57-426">Run-time Thread Performance Information</span></span>

<span data-ttu-id="00e57-427">ThreadX zapewnia opcjonalne informacje o wydajności wątku czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="00e57-427">ThreadX provides optional run-time thread performance information.</span></span> <span data-ttu-id="00e57-428">Jeśli biblioteka i aplikacja ThreadX została skompilowana przy użyciu zdefiniowanych **TX_THREAD_ENABLE_PERFORMANCE_INFO** , ThreadX gromadzi poniższe informacje.</span><span class="sxs-lookup"><span data-stu-id="00e57-428">If the ThreadX library and application is built with **TX_THREAD_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="00e57-429">Łączna liczba dla całego systemu:</span><span class="sxs-lookup"><span data-stu-id="00e57-429">Total number for the overall system:</span></span>

  - <span data-ttu-id="00e57-430">wznowienia wątków</span><span class="sxs-lookup"><span data-stu-id="00e57-430">thread resumptions</span></span>

  - <span data-ttu-id="00e57-431">zawieszenie wątku</span><span class="sxs-lookup"><span data-stu-id="00e57-431">thread suspensions</span></span>

  - <span data-ttu-id="00e57-432">zastępujące wywołania usług</span><span class="sxs-lookup"><span data-stu-id="00e57-432">service call preemptions</span></span>

  - <span data-ttu-id="00e57-433">zastępujące przerwania</span><span class="sxs-lookup"><span data-stu-id="00e57-433">interrupt preemptions</span></span>

  - <span data-ttu-id="00e57-434">priorytetowe wersje</span><span class="sxs-lookup"><span data-stu-id="00e57-434">priority inversions</span></span>

  - <span data-ttu-id="00e57-435">wycinki czasu</span><span class="sxs-lookup"><span data-stu-id="00e57-435">time-slices</span></span>

  - <span data-ttu-id="00e57-436">braki</span><span class="sxs-lookup"><span data-stu-id="00e57-436">relinquishes</span></span>

  - <span data-ttu-id="00e57-437">limity czasu wątków</span><span class="sxs-lookup"><span data-stu-id="00e57-437">thread timeouts</span></span>

  - <span data-ttu-id="00e57-438">przerwania zawieszenia</span><span class="sxs-lookup"><span data-stu-id="00e57-438">suspension aborts</span></span>

  - <span data-ttu-id="00e57-439">bezczynne zwracanie systemu</span><span class="sxs-lookup"><span data-stu-id="00e57-439">idle system returns</span></span>

  - <span data-ttu-id="00e57-440">bezczynne przywrócenie systemu</span><span class="sxs-lookup"><span data-stu-id="00e57-440">non-idle system returns</span></span>

<span data-ttu-id="00e57-441">Łączna liczba dla każdego wątku:</span><span class="sxs-lookup"><span data-stu-id="00e57-441">Total number for each thread:</span></span>

  - <span data-ttu-id="00e57-442">Dzięki wznawianiu</span><span class="sxs-lookup"><span data-stu-id="00e57-442">resumptions</span></span>

  - <span data-ttu-id="00e57-443">zawieszeniach</span><span class="sxs-lookup"><span data-stu-id="00e57-443">suspensions</span></span>

  - <span data-ttu-id="00e57-444">zastępujące wywołania usług</span><span class="sxs-lookup"><span data-stu-id="00e57-444">service call preemptions</span></span>

  - <span data-ttu-id="00e57-445">zastępujące przerwania</span><span class="sxs-lookup"><span data-stu-id="00e57-445">interrupt preemptions</span></span>

  - <span data-ttu-id="00e57-446">priorytetowe wersje</span><span class="sxs-lookup"><span data-stu-id="00e57-446">priority inversions</span></span>

  - <span data-ttu-id="00e57-447">wycinki czasu</span><span class="sxs-lookup"><span data-stu-id="00e57-447">time-slices</span></span>

  - <span data-ttu-id="00e57-448">zrzeczenia się wątków</span><span class="sxs-lookup"><span data-stu-id="00e57-448">thread relinquishes</span></span>

  - <span data-ttu-id="00e57-449">limity czasu wątków</span><span class="sxs-lookup"><span data-stu-id="00e57-449">thread timeouts</span></span>

  - <span data-ttu-id="00e57-450">przerwania zawieszenia</span><span class="sxs-lookup"><span data-stu-id="00e57-450">suspension aborts</span></span>

<span data-ttu-id="00e57-451">Te informacje są dostępne w czasie wykonywania za pomocą usług \***tx_thread_performance_info_get** _ i _ *_tx_thread_performance_system_info_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="00e57-451">This information is available at run-time through the services ***tx_thread_performance_info_get** _ and _*_tx_thread_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="00e57-452">Informacje o wydajności wątków są przydatne podczas ustalania, czy aplikacja działa prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="00e57-452">Thread performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="00e57-453">Jest on również przydatny do optymalizowania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-453">It is also useful in optimizing the application.</span></span> <span data-ttu-id="00e57-454">Na przykład stosunkowo wysoka liczba przeniesień wywołań usług może zasugerować priorytet wątku i/lub przekroczenie — próg jest zbyt niski.</span><span class="sxs-lookup"><span data-stu-id="00e57-454">For example, a relatively high number of service call preemptions might suggest the thread's priority and/or preemption-threshold is too low.</span></span> <span data-ttu-id="00e57-455">Ponadto stosunkowo niska liczba bezczynnych funkcji zwracanych przez system może sugerować, że wątki o niższym priorytecie nie są wystarczająco zawieszone.</span><span class="sxs-lookup"><span data-stu-id="00e57-455">Furthermore, a relatively low number of idle system returns might suggest that lower priority threads are not suspending enough.</span></span>

### <a name="debugging-pitfalls"></a><span data-ttu-id="00e57-456">Debugowanie pułapek</span><span class="sxs-lookup"><span data-stu-id="00e57-456">Debugging Pitfalls</span></span>

<span data-ttu-id="00e57-457">Debugowanie aplikacji wielowątkowych jest nieco trudniejsze, ponieważ ten sam kod programu może być wykonywany z wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="00e57-457">Debugging multithreaded applications is a little more difficult because the same program code can be executed from multiple threads.</span></span> <span data-ttu-id="00e57-458">W takich przypadkach sama punkt przerwania może być niewystarczająca.</span><span class="sxs-lookup"><span data-stu-id="00e57-458">In such cases, a break-point alone may not be enough.</span></span> <span data-ttu-id="00e57-459">Debuger musi również wyświetlać wskaźnik bieżącego wątku **_tx_thread_current_ptr** przy użyciu warunkowego punktu przerwania, aby sprawdzić, czy wywoływany wątek jest obiektem do debugowania.</span><span class="sxs-lookup"><span data-stu-id="00e57-459">The debugger must also view the current thread pointer **_tx_thread_current_ptr** using a conditional breakpoint to see if the calling thread is the one to debug.</span></span>

<span data-ttu-id="00e57-460">Większość z nich jest obsługiwana w pakietach obsługi wielowątkowości oferowanych przez różnych dostawców narzędzi programistycznych.</span><span class="sxs-lookup"><span data-stu-id="00e57-460">Much of this is being handled in multithreading support packages offered through various development tool vendors.</span></span> <span data-ttu-id="00e57-461">Ze względu na prosty projekt integrowanie ThreadX z różnymi narzędziami programistycznymi jest stosunkowo proste.</span><span class="sxs-lookup"><span data-stu-id="00e57-461">Because of its simple design, integrating ThreadX with different development tools is relatively easy.</span></span>

<span data-ttu-id="00e57-462">Rozmiar stosu jest zawsze ważnym tematem debugowania w wielowątkowości.</span><span class="sxs-lookup"><span data-stu-id="00e57-462">Stack size is always an important debug topic in multithreading.</span></span> <span data-ttu-id="00e57-463">Zawsze, gdy zaobserwowano niewyjaśnione zachowanie, zwykle jest to dobre pierwsze odgadnięcie w celu zwiększenia rozmiaru stosu dla wszystkich wątków — szczególnie rozmiaru stosu dla ostatniego wątku do wykonania.</span><span class="sxs-lookup"><span data-stu-id="00e57-463">Whenever unexplained behavior is observed, it is usually a good first guess to increase stack sizes for all threads—especially the stack size of the last thread to execute!</span></span>

> [!TIP]
> <span data-ttu-id="00e57-464">*Dobrym pomysłem jest również skompilowanie biblioteki ThreadX z definicją **TX_ENABLE_STACK_CHECKING** . Pomoże to w wyizolowaniu problemów z uszkodzeniem stosu tak wcześnie jak to możliwe.*</span><span class="sxs-lookup"><span data-stu-id="00e57-464">*It is also a good idea to build the ThreadX library with **TX_ENABLE_STACK_CHECKING** defined. This will help isolate stack corruption problems as early in the processing as possible.*</span></span>

## <a name="message-queues"></a><span data-ttu-id="00e57-465">Kolejki komunikatów</span><span class="sxs-lookup"><span data-stu-id="00e57-465">Message Queues</span></span>

<span data-ttu-id="00e57-466">Kolejki komunikatów są podstawowym sposobem komunikacji między wątkami w ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-466">Message queues are the primary means of inter-thread communication in ThreadX.</span></span> <span data-ttu-id="00e57-467">Co najmniej jeden komunikat może znajdować się w kolejce komunikatów.</span><span class="sxs-lookup"><span data-stu-id="00e57-467">One or more messages can reside in a message queue.</span></span> <span data-ttu-id="00e57-468">Kolejka komunikatów, która przechowuje pojedynczy komunikat, jest zazwyczaj nazywana *skrzynką pocztową*.</span><span class="sxs-lookup"><span data-stu-id="00e57-468">A message queue that holds a single message is commonly called a *mailbox*.</span></span>

<span data-ttu-id="00e57-469">Komunikaty są kopiowane do kolejki przez \***tx_queue_send** _ i kopiowane z kolejki przez _ *_tx_queue_receive_* \*.</span><span class="sxs-lookup"><span data-stu-id="00e57-469">Messages are copied to a queue by ***tx_queue_send** _ and are copied from a queue by _*_tx_queue_receive_\*\*.</span></span> <span data-ttu-id="00e57-470">Jedynym wyjątkiem jest zawieszenie wątku podczas oczekiwania na komunikat w pustej kolejce.</span><span class="sxs-lookup"><span data-stu-id="00e57-470">The only exception to this is when a thread is suspended while waiting for a message on an empty queue.</span></span> <span data-ttu-id="00e57-471">W takim przypadku Następna wiadomość wysłana do kolejki zostanie umieszczona bezpośrednio w obszarze docelowym wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-471">In this case, the next message sent to the queue is placed directly into the thread's destination area.</span></span>

<span data-ttu-id="00e57-472">Każda kolejka komunikatów jest zasobem publicznym.</span><span class="sxs-lookup"><span data-stu-id="00e57-472">Each message queue is a public resource.</span></span> <span data-ttu-id="00e57-473">ThreadX nie ma żadnych ograniczeń dotyczących sposobu używania kolejek komunikatów.</span><span class="sxs-lookup"><span data-stu-id="00e57-473">ThreadX places no constraints on how message queues are used.</span></span>

### <a name="creating-message-queues"></a><span data-ttu-id="00e57-474">Tworzenie kolejek komunikatów</span><span class="sxs-lookup"><span data-stu-id="00e57-474">Creating Message Queues</span></span>

<span data-ttu-id="00e57-475">Kolejki komunikatów są tworzone podczas inicjacji lub w czasie wykonywania przez wątki aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-475">Message queues are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="00e57-476">Nie ma limitu liczby kolejek komunikatów w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-476">There is no limit on the number of message queues in an application.</span></span>

### <a name="message-size"></a><span data-ttu-id="00e57-477">Rozmiar komunikatu</span><span class="sxs-lookup"><span data-stu-id="00e57-477">Message Size</span></span>

<span data-ttu-id="00e57-478">Każda kolejka komunikatów obsługuje wiele komunikatów o ustalonym rozmiarze.</span><span class="sxs-lookup"><span data-stu-id="00e57-478">Each message queue supports a number of fixed-sized messages.</span></span> <span data-ttu-id="00e57-479">Dostępne rozmiary wiadomości to od 1 do 16 32-bitowych słów włącznie.</span><span class="sxs-lookup"><span data-stu-id="00e57-479">The available message sizes are 1 through 16 32-bit words inclusive.</span></span> <span data-ttu-id="00e57-480">Rozmiar komunikatu jest określany podczas tworzenia kolejki.</span><span class="sxs-lookup"><span data-stu-id="00e57-480">The message size is specified when the queue is created.</span></span> <span data-ttu-id="00e57-481">Komunikaty aplikacji o więcej niż 16 wyrazach muszą być przesyłane przez wskaźnik.</span><span class="sxs-lookup"><span data-stu-id="00e57-481">Application messages greater than 16 words must be passed by pointer.</span></span> <span data-ttu-id="00e57-482">W tym celu można utworzyć kolejkę z rozmiarem komunikatu wynoszącym 1 wyraz (wystarczająco mały, aby pomieścić wskaźnik), a następnie wysyłać i odbierać wskaźniki komunikatów zamiast całego komunikatu.</span><span class="sxs-lookup"><span data-stu-id="00e57-482">This is accomplished by creating a queue with a message size of 1 word (enough to hold a pointer) and then sending and receiving message pointers instead of the entire message.</span></span>

### <a name="message-queue-capacity"></a><span data-ttu-id="00e57-483">Pojemność kolejki komunikatów</span><span class="sxs-lookup"><span data-stu-id="00e57-483">Message Queue Capacity</span></span>

<span data-ttu-id="00e57-484">Liczba komunikatów, które mogą być przechowywane w kolejce jest funkcją rozmiaru komunikatu oraz rozmiarem obszaru pamięci dostarczonego podczas tworzenia.</span><span class="sxs-lookup"><span data-stu-id="00e57-484">The number of messages a queue can hold is a function of its message size and the size of the memory area supplied during creation.</span></span> <span data-ttu-id="00e57-485">Całkowita pojemność wiadomości w kolejce jest obliczana przez podzielenie liczby bajtów w poszczególnych komunikatach na całkowitą liczbę bajtów w podanym obszarze pamięci.</span><span class="sxs-lookup"><span data-stu-id="00e57-485">The total message capacity of the queue is calculated by dividing the number of bytes in each message into the total number of bytes in the supplied memory area.</span></span>

<span data-ttu-id="00e57-486">Na przykład, jeśli kolejka komunikatów obsługująca rozmiar komunikatu 1 32-bit (4 bajty) jest tworzona z obszarem pamięci 100 bajtów, jego pojemność to 25 komunikatów.</span><span class="sxs-lookup"><span data-stu-id="00e57-486">For example, if a message queue that supports a message size of 1 32-bit word (4 bytes) is created with a 100-byte memory area, its capacity is 25 messages.</span></span>

### <a name="queue-memory-area"></a><span data-ttu-id="00e57-487">Obszar pamięci kolejki</span><span class="sxs-lookup"><span data-stu-id="00e57-487">Queue Memory Area</span></span>

<span data-ttu-id="00e57-488">Jak wspomniano wcześniej, obszar pamięci do buforowania komunikatów jest określany podczas tworzenia kolejki.</span><span class="sxs-lookup"><span data-stu-id="00e57-488">As mentioned previously, the memory area for buffering messages is specified during queue creation.</span></span> <span data-ttu-id="00e57-489">Podobnie jak w przypadku innych obszarów pamięci w ThreadX, może ona znajdować się w dowolnym miejscu w przestrzeni adresowej docelowej.</span><span class="sxs-lookup"><span data-stu-id="00e57-489">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span>

<span data-ttu-id="00e57-490">Jest to ważna funkcja, ponieważ zapewnia znaczną elastyczność aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-490">This is an important feature because it gives the application considerable flexibility.</span></span> <span data-ttu-id="00e57-491">Na przykład aplikacja może zlokalizować obszar pamięci ważnej kolejki w pamięci RAM o dużej szybkości, aby zwiększyć wydajność.</span><span class="sxs-lookup"><span data-stu-id="00e57-491">For example, an application might locate the memory area of an important queue in high-speed RAM to improve performance.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="00e57-492">Zawieszenie wątku</span><span class="sxs-lookup"><span data-stu-id="00e57-492">Thread Suspension</span></span>

<span data-ttu-id="00e57-493">Wątki aplikacji mogą wstrzymywać podczas próby wysłania lub odebrania komunikatu z kolejki.</span><span class="sxs-lookup"><span data-stu-id="00e57-493">Application threads can suspend while attempting to send or receive a message from a queue.</span></span> <span data-ttu-id="00e57-494">Zazwyczaj zawieszenie wątku obejmuje oczekiwanie na komunikat z pustej kolejki.</span><span class="sxs-lookup"><span data-stu-id="00e57-494">Typically, thread suspension involves waiting for a message from an empty queue.</span></span> <span data-ttu-id="00e57-495">Istnieje również możliwość zawieszenia przez wątek próby wysłania komunikatu do pełnej kolejki.</span><span class="sxs-lookup"><span data-stu-id="00e57-495">However, it is also possible for a thread to suspend trying to send a message to a full queue.</span></span>

<span data-ttu-id="00e57-496">Po rozwiązaniu problemu z zawieszeniem żądana usługa zostanie zakończona, a wątek Oczekujący zostanie wznowiony.</span><span class="sxs-lookup"><span data-stu-id="00e57-496">After the condition for suspension is resolved, the service requested is completed and the waiting thread is resumed.</span></span> <span data-ttu-id="00e57-497">Jeśli wiele wątków jest zawieszonych w tej samej kolejce, zostaną wznowione w kolejności, w której zostały wstrzymane (FIFO).</span><span class="sxs-lookup"><span data-stu-id="00e57-497">If multiple threads are suspended on the same queue, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="00e57-498">Jednak możliwość wznowienia priorytetu jest również możliwa, jeśli aplikacja wywołuje ***tx_queue_prioritize*** przed usługą kolejki, która zawieszania wątku Wind.</span><span class="sxs-lookup"><span data-stu-id="00e57-498">However, priority resumption is also possible if the application calls ***tx_queue_prioritize*** prior to the queue service that lifts thread suspension.</span></span> <span data-ttu-id="00e57-499">Usługa Queue priorytetyzacji usługi umieszcza wątek o najwyższym priorytecie na początku listy zawieszania, pozostawiając wszystkie pozostałe zawieszone wątki w tej samej kolejności FIFO.</span><span class="sxs-lookup"><span data-stu-id="00e57-499">The queue prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

<span data-ttu-id="00e57-500">Limity czasu są również dostępne dla wszystkich zawieszeń kolejki.</span><span class="sxs-lookup"><span data-stu-id="00e57-500">Time-outs are also available for all queue suspensions.</span></span> <span data-ttu-id="00e57-501">W zasadzie limit czasu określa maksymalną liczbę cykli czasomierza, przez jaką wątek pozostanie zawieszony.</span><span class="sxs-lookup"><span data-stu-id="00e57-501">Basically, a time-out specifies the maximum number of timer ticks the thread will stay suspended.</span></span> <span data-ttu-id="00e57-502">W przypadku wystąpienia limitu czasu wątek zostaje wznowiony, a usługa zwraca odpowiedni kod błędu.</span><span class="sxs-lookup"><span data-stu-id="00e57-502">If a time-out occurs, the thread is resumed and the service returns with the appropriate error code.</span></span>

### <a name="queue-send-notification"></a><span data-ttu-id="00e57-503">Powiadomienie o wysłaniu kolejki</span><span class="sxs-lookup"><span data-stu-id="00e57-503">Queue Send Notification</span></span>

<span data-ttu-id="00e57-504">Niektóre aplikacje mogą otrzymywać powiadomienia za każdym razem, gdy komunikat zostanie umieszczony w kolejce.</span><span class="sxs-lookup"><span data-stu-id="00e57-504">Some applications may find it advantageous to be notified whenever a message is placed on a queue.</span></span> <span data-ttu-id="00e57-505">ThreadX zapewnia tę możliwość za pomocą usługi ***tx_queue_send_notify*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-505">ThreadX provides this ability through the ***tx_queue_send_notify*** service.</span></span> <span data-ttu-id="00e57-506">Ta usługa rejestruje podaną funkcję powiadamiania aplikacji z określoną kolejką.</span><span class="sxs-lookup"><span data-stu-id="00e57-506">This service registers the supplied application notification function with the specified queue.</span></span> <span data-ttu-id="00e57-507">ThreadX następnie wywoła funkcję powiadamiania o tej aplikacji za każdym razem, gdy komunikat zostanie wysłany do kolejki.</span><span class="sxs-lookup"><span data-stu-id="00e57-507">ThreadX will subsequently invoke this application notification function whenever a message is sent to the queue.</span></span> <span data-ttu-id="00e57-508">Dokładne przetwarzanie w ramach funkcji powiadomień aplikacji jest określane przez aplikację; jednak zwykle składa się z wznawiania odpowiedniego wątku w celu przetworzenia nowej wiadomości.</span><span class="sxs-lookup"><span data-stu-id="00e57-508">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new message.</span></span>

### <a name="queue-event-chainingtrade"></a><span data-ttu-id="00e57-509">Tworzenie łańcucha zdarzeń kolejki&trade;</span><span class="sxs-lookup"><span data-stu-id="00e57-509">Queue Event chaining&trade;</span></span>

<span data-ttu-id="00e57-510">Funkcje powiadamiania w programie ThreadX mogą służyć do łańcucha różnych zdarzeń synchronizacji razem.</span><span class="sxs-lookup"><span data-stu-id="00e57-510">The notification capabilities in ThreadX can be used to chain various synchronization events together.</span></span> <span data-ttu-id="00e57-511">Jest to zazwyczaj przydatne, gdy pojedynczy wątek musi przetwarzać wiele zdarzeń synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-511">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="00e57-512">Załóżmy na przykład, że jeden wątek jest odpowiedzialny za przetwarzanie komunikatów z pięciu różnych kolejek i musi również zostać zawieszony, gdy nie są dostępne żadne komunikaty.</span><span class="sxs-lookup"><span data-stu-id="00e57-512">For example, suppose a single thread is responsible for processing messages from five different queues and must also suspend when no messages are available.</span></span> <span data-ttu-id="00e57-513">Jest to łatwo realizowane przez zarejestrowanie funkcji powiadomień aplikacji dla każdej kolejki i wprowadzenie dodatkowego semafora zliczania.</span><span class="sxs-lookup"><span data-stu-id="00e57-513">This is easily accomplished by registering an application notification function for each queue and introducing an additional counting semaphore.</span></span> <span data-ttu-id="00e57-514">W odróżnieniu od tego, czy funkcja powiadamiania aplikacji wykonuje *tx_semaphore_put* przy każdym wywołaniu (liczba semaforów reprezentuje łączną liczbę komunikatów we wszystkich pięciu kolejkach).</span><span class="sxs-lookup"><span data-stu-id="00e57-514">Specifically, the application notification function performs a *tx_semaphore_put* whenever it is called (the semaphore count represents the total number of messages in all five queues).</span></span> <span data-ttu-id="00e57-515">Wątek przetwarzania zawiesza się w tym semaforze za pośrednictwem usługi *tx_semaphore_get* .</span><span class="sxs-lookup"><span data-stu-id="00e57-515">The processing thread suspends on this semaphore via the *tx_semaphore_get* service.</span></span> <span data-ttu-id="00e57-516">Gdy semafor jest dostępny (w tym przypadku, gdy komunikat jest dostępny!), wątek przetwarzania zostaje wznowiony.</span><span class="sxs-lookup"><span data-stu-id="00e57-516">When the semaphore is available (in this case, when a message is available!), the processing thread is resumed.</span></span> <span data-ttu-id="00e57-517">Następnie interrogates każdą kolejkę dla wiadomości, przetwarza znaleziony komunikat i wykonuje inne ***tx_semaphore_get*** , aby oczekiwać na następny komunikat.</span><span class="sxs-lookup"><span data-stu-id="00e57-517">It then interrogates each queue for a message, processes the found message, and performs another ***tx_semaphore_get*** to wait for the next message.</span></span> <span data-ttu-id="00e57-518">Ukończenie tego procesu bez łańcucha zdarzeń jest dość trudne i prawdopodobnie będzie wymagało większej liczby wątków i/lub dodatkowego kodu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-518">Accomplishing this without event-chaining is quite difficult and likely would require more threads and/or additional application code.</span></span>

<span data-ttu-id="00e57-519">Ogólnie rzecz biorąc, *łańcuch zdarzeń* powoduje zmniejszenie liczby wątków, mniejsze obciążenie i mniejsze wymagania dotyczące pamięci RAM.</span><span class="sxs-lookup"><span data-stu-id="00e57-519">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="00e57-520">Zapewnia również wysoce elastyczny mechanizm obsługujący wymagania dotyczące synchronizacji bardziej złożonych systemów.</span><span class="sxs-lookup"><span data-stu-id="00e57-520">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-queue-performance-information"></a><span data-ttu-id="00e57-521">Informacje o wydajności kolejki czasu wykonywania</span><span class="sxs-lookup"><span data-stu-id="00e57-521">Run-time Queue Performance Information</span></span>
<span data-ttu-id="00e57-522">ThreadX zapewnia opcjonalne informacje o wydajności kolejki czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="00e57-522">ThreadX provides optional run-time queue performance information.</span></span> <span data-ttu-id="00e57-523">Jeśli biblioteka i aplikacja ThreadX została skompilowana przy użyciu zdefiniowanych ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** , ThreadX gromadzi poniższe informacje.</span><span class="sxs-lookup"><span data-stu-id="00e57-523">If the ThreadX library and application is built with ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="00e57-524">Łączna liczba dla całego systemu:</span><span class="sxs-lookup"><span data-stu-id="00e57-524">Total number for the overall system:</span></span>

  - <span data-ttu-id="00e57-525">Wysłane komunikaty</span><span class="sxs-lookup"><span data-stu-id="00e57-525">messages sent</span></span>

  - <span data-ttu-id="00e57-526">odebrane komunikaty</span><span class="sxs-lookup"><span data-stu-id="00e57-526">messages received</span></span>

  - <span data-ttu-id="00e57-527">zawieszanie pustych kolejek</span><span class="sxs-lookup"><span data-stu-id="00e57-527">queue empty suspensions</span></span>

  - <span data-ttu-id="00e57-528">pełne zawieszenie kolejki</span><span class="sxs-lookup"><span data-stu-id="00e57-528">queue full suspensions</span></span>

  - <span data-ttu-id="00e57-529">błąd pełnej kolejki (zawieszenie nie zostało określone)</span><span class="sxs-lookup"><span data-stu-id="00e57-529">queue full error returns (suspension not specified)</span></span>

  - <span data-ttu-id="00e57-530">limity czasu kolejki</span><span class="sxs-lookup"><span data-stu-id="00e57-530">queue timeouts</span></span>

<span data-ttu-id="00e57-531">Łączna liczba dla każdej kolejki:</span><span class="sxs-lookup"><span data-stu-id="00e57-531">Total number for each queue:</span></span>

  - <span data-ttu-id="00e57-532">Wysłane komunikaty</span><span class="sxs-lookup"><span data-stu-id="00e57-532">messages sent</span></span>

  - <span data-ttu-id="00e57-533">odebrane komunikaty</span><span class="sxs-lookup"><span data-stu-id="00e57-533">messages received</span></span>

  - <span data-ttu-id="00e57-534">zawieszanie pustych kolejek</span><span class="sxs-lookup"><span data-stu-id="00e57-534">queue empty suspensions</span></span>

  - <span data-ttu-id="00e57-535">pełne zawieszenie kolejki</span><span class="sxs-lookup"><span data-stu-id="00e57-535">queue full suspensions</span></span>

  - <span data-ttu-id="00e57-536">błąd pełnej kolejki (zawieszenie nie zostało określone)</span><span class="sxs-lookup"><span data-stu-id="00e57-536">queue full error returns (suspension not specified)</span></span>

  - <span data-ttu-id="00e57-537">limity czasu kolejki</span><span class="sxs-lookup"><span data-stu-id="00e57-537">queue timeouts</span></span>

<span data-ttu-id="00e57-538">Te informacje są dostępne w czasie wykonywania za pomocą usług \***tx_queue_performance_info_get** _ i _ *_tx_queue_performance_system_info_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="00e57-538">This information is available at run-time through the services ***tx_queue_performance_info_get** _ and _*_tx_queue_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="00e57-539">Informacje o wydajności kolejki są przydatne podczas ustalania, czy aplikacja działa prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="00e57-539">Queue performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="00e57-540">Jest on również przydatny do optymalizowania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-540">It is also useful in optimizing the application.</span></span> <span data-ttu-id="00e57-541">Na przykład stosunkowo wysoka liczba zawieszeń "queue fulls" sugeruje zwiększenie rozmiaru kolejki może być korzystne.</span><span class="sxs-lookup"><span data-stu-id="00e57-541">For example, a relatively high number of "queue full suspensions" suggests an increase in the queue size might be beneficial.</span></span>

### <a name="queue-control-block-tx_queue"></a><span data-ttu-id="00e57-542">Blok kontrolny kolejki TX_QUEUE</span><span class="sxs-lookup"><span data-stu-id="00e57-542">Queue Control Block TX_QUEUE</span></span>

<span data-ttu-id="00e57-543">Charakterystyka każdej kolejki komunikatów znajduje się w jego bloku sterowania.</span><span class="sxs-lookup"><span data-stu-id="00e57-543">The characteristics of each message queue are found in its control block.</span></span> <span data-ttu-id="00e57-544">Zawiera interesujące informacje, takie jak liczba komunikatów w kolejce.</span><span class="sxs-lookup"><span data-stu-id="00e57-544">It contains interesting information such as the number of messages in the queue.</span></span> <span data-ttu-id="00e57-545">Ta struktura jest zdefiniowana w pliku ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-545">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="00e57-546">Bloki sterujące kolejki komunikatów mogą również znajdować się w dowolnym miejscu w pamięci, ale najczęściej jest to, że formant blokuje strukturę globalną przez definiowanie jej poza zakresem dowolnej funkcji.</span><span class="sxs-lookup"><span data-stu-id="00e57-546">Message queue control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="message-destination-pitfall"></a><span data-ttu-id="00e57-547">Pitfall miejsca docelowego wiadomości</span><span class="sxs-lookup"><span data-stu-id="00e57-547">Message Destination Pitfall</span></span>

<span data-ttu-id="00e57-548">Jak wspomniano wcześniej, komunikaty są kopiowane między obszarami kolejki i danymi aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-548">As mentioned previously, messages are copied between the queue area and application data areas.</span></span> <span data-ttu-id="00e57-549">Należy upewnić się, że miejsce docelowe odebranej wiadomości jest wystarczająco duże, aby pomieścić całą wiadomość.</span><span class="sxs-lookup"><span data-stu-id="00e57-549">It is important to ensure the destination for a received message is large enough to hold the entire message.</span></span> <span data-ttu-id="00e57-550">W przeciwnym razie pamięć następująca po miejscu docelowym wiadomości prawdopodobnie zostanie uszkodzona.</span><span class="sxs-lookup"><span data-stu-id="00e57-550">If not, the memory following the message destination will likely be corrupted.</span></span>

> [!NOTE]
> <span data-ttu-id="00e57-551">*Jest to szczególnie ważne, gdy na stosie znajduje się zbyt małe miejsce docelowe komunikatów — nic jak uszkodzenie adresu zwrotnego funkcji!*</span><span class="sxs-lookup"><span data-stu-id="00e57-551">*This is especially lethal when a too-small message destination is on the stack—nothing like corrupting the return address of a function!*</span></span>

## <a name="counting-semaphores"></a><span data-ttu-id="00e57-552">Zliczanie semaforów</span><span class="sxs-lookup"><span data-stu-id="00e57-552">Counting Semaphores</span></span>

<span data-ttu-id="00e57-553">ThreadX zapewnia 32-bitowe semafory zliczania, które mają wartość z zakresu od 0 do 4 294 967 295.</span><span class="sxs-lookup"><span data-stu-id="00e57-553">ThreadX provides 32-bit counting semaphores that range in value between 0 and 4,294,967,295.</span></span> <span data-ttu-id="00e57-554">Istnieją dwie operacje zliczania semaforów: *tx_semaphore_get* i *tx_semaphore_put*.</span><span class="sxs-lookup"><span data-stu-id="00e57-554">There are two operations for counting semaphores: *tx_semaphore_get* and *tx_semaphore_put*.</span></span> <span data-ttu-id="00e57-555">Operacja get zmniejsza semafor o jeden.</span><span class="sxs-lookup"><span data-stu-id="00e57-555">The get operation decreases the semaphore by one.</span></span> <span data-ttu-id="00e57-556">Jeśli semafor ma wartość 0, operacja get nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="00e57-556">If the semaphore is 0, the get operation is not successful.</span></span> <span data-ttu-id="00e57-557">Odwrotność operacji pobierania jest operacją Put.</span><span class="sxs-lookup"><span data-stu-id="00e57-557">The inverse of the get operation is the put operation.</span></span>
<span data-ttu-id="00e57-558">Zwiększa semafor o jeden.</span><span class="sxs-lookup"><span data-stu-id="00e57-558">It increases the semaphore by one.</span></span>

<span data-ttu-id="00e57-559">Każdy semafor zliczania jest zasobem publicznym.</span><span class="sxs-lookup"><span data-stu-id="00e57-559">Each counting semaphore is a public resource.</span></span> <span data-ttu-id="00e57-560">ThreadX nie ma żadnych ograniczeń dotyczących sposobu używania semaforów zliczania.</span><span class="sxs-lookup"><span data-stu-id="00e57-560">ThreadX places no constraints on how counting semaphores are used.</span></span>

<span data-ttu-id="00e57-561">Licznik semaforów jest zwykle używany do *wzajemnego wykluczania*.</span><span class="sxs-lookup"><span data-stu-id="00e57-561">Counting semaphores are typically used for *mutual exclusion*.</span></span> <span data-ttu-id="00e57-562">Jednak zliczanie semaforów może być również używane jako metoda powiadamiania o zdarzeniach.</span><span class="sxs-lookup"><span data-stu-id="00e57-562">However, counting semaphores can also be used as a method for event notification.</span></span>

### <a name="mutual-exclusion"></a><span data-ttu-id="00e57-563">Wzajemne wykluczenie</span><span class="sxs-lookup"><span data-stu-id="00e57-563">Mutual Exclusion</span></span>

 <span data-ttu-id="00e57-564">Wzajemne wykluczenie dotyczy kontroli dostępu wątków do określonych obszarów aplikacji (nazywanych także *sekcjami krytycznymi* lub *zasobami aplikacji*).</span><span class="sxs-lookup"><span data-stu-id="00e57-564">Mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="00e57-565">W przypadku użycia do wzajemnego wykluczania "Bieżąca liczba" semafora reprezentuje łączną liczbę wątków, które są dozwolone.</span><span class="sxs-lookup"><span data-stu-id="00e57-565">When used for mutual exclusion, the "current count" of a semaphore represents the total number of threads that are allowed access.</span></span> <span data-ttu-id="00e57-566">W większości przypadków zliczanie semaforów używanych do wzajemnego wykluczania będzie miało wartość początkową 1, co oznacza, że tylko jeden wątek może uzyskać dostęp do skojarzonego zasobu w danym momencie.</span><span class="sxs-lookup"><span data-stu-id="00e57-566">In most cases, counting semaphores used for mutual exclusion will have an initial value of 1, meaning that only one thread can access the associated resource at a time.</span></span> <span data-ttu-id="00e57-567">Zliczanie semaforów, które mają tylko wartości 0 lub 1, są zwykle nazywane *semaforami binarnymi*.</span><span class="sxs-lookup"><span data-stu-id="00e57-567">Counting semaphores that only have values of 0 or 1 are commonly called *binary semaphores*.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="00e57-568">*Jeśli jest używany semafor binarny, użytkownik musi uniemożliwić wykonanie operacji get przez ten sam wątek na semaforze, który jest już właścicielem. Druga wartość nie powiedzie się i może spowodować niepowodzenie zawieszenia wątku wywołującego i trwałej niedostępności zasobu.*</span><span class="sxs-lookup"><span data-stu-id="00e57-568">*If a binary semaphore is being used, the user must prevent the same thread from performing a get operation on a semaphore it already owns. A second get would be unsuccessful and could cause indefinite suspension of the calling thread and permanent unavailability of the resource.*</span></span>

### <a name="event-notification"></a><span data-ttu-id="00e57-569">Powiadomienie o zdarzeniu</span><span class="sxs-lookup"><span data-stu-id="00e57-569">Event Notification</span></span>

<span data-ttu-id="00e57-570">Można również użyć zliczania semaforów jako powiadomienia o zdarzeniach, w sposób przeznaczony dla konsumentów.</span><span class="sxs-lookup"><span data-stu-id="00e57-570">It is also possible to use counting semaphores as event notification, in a producer-consumer fashion.</span></span> <span data-ttu-id="00e57-571">Odbiorca podejmuje próbę uzyskania semafora zliczania, gdy producent zwiększa semafor, gdy coś jest dostępne.</span><span class="sxs-lookup"><span data-stu-id="00e57-571">The consumer attempts to get the counting semaphore while the producer increases the semaphore whenever something is available.</span></span> <span data-ttu-id="00e57-572">Takie semafory zwykle mają wartość początkową 0 i nie zostaną zwiększone do momentu, gdy producent ma coś gotowego dla konsumenta.</span><span class="sxs-lookup"><span data-stu-id="00e57-572">Such semaphores usually have an initial value of 0 and will not increase until the producer has something ready for the consumer.</span></span> <span data-ttu-id="00e57-573">Semafory używane na potrzeby powiadomień o zdarzeniach mogą również korzystać z wywołania usługi ***tx_semaphore_ceiling_put*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-573">Semaphores used for event notification may also benefit from use of the ***tx_semaphore_ceiling_put*** service call.</span></span> <span data-ttu-id="00e57-574">Ta usługa zapewnia, że liczba semaforów nigdy nie przekracza wartości podanej w wywołaniu.</span><span class="sxs-lookup"><span data-stu-id="00e57-574">This service ensures that the semaphore count never exceeds the value supplied in the call.</span></span>

### <a name="creating-counting-semaphores"></a><span data-ttu-id="00e57-575">Tworzenie semaforów zliczania</span><span class="sxs-lookup"><span data-stu-id="00e57-575">Creating Counting Semaphores</span></span>

<span data-ttu-id="00e57-576">Zliczanie semaforów jest tworzone podczas inicjacji lub w czasie wykonywania przez wątki aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-576">Counting semaphores are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="00e57-577">Początkowa liczba semaforów jest określana podczas tworzenia.</span><span class="sxs-lookup"><span data-stu-id="00e57-577">The initial count of the semaphore is specified during creation.</span></span> <span data-ttu-id="00e57-578">Nie ma żadnego limitu liczby semaforów zliczania w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-578">There is no limit on the number of counting semaphores in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="00e57-579">Zawieszenie wątku</span><span class="sxs-lookup"><span data-stu-id="00e57-579">Thread Suspension</span></span>

<span data-ttu-id="00e57-580">Wątki aplikacji mogą wstrzymywać podczas próby wykonania operacji get na semaforze z bieżącą liczbą 0.</span><span class="sxs-lookup"><span data-stu-id="00e57-580">Application threads can suspend while attempting to perform a get operation on a semaphore with a current count of 0.</span></span>

<span data-ttu-id="00e57-581">Po wykonaniu operacji put jest wykonywana operacja pobrania zawieszonego wątku, a wątek zostaje wznowiony.</span><span class="sxs-lookup"><span data-stu-id="00e57-581">After a put operation is performed, the suspended thread's get operation is performed and the thread is resumed.</span></span> <span data-ttu-id="00e57-582">Jeśli wiele wątków jest zawieszonych na tym samym semaforze zliczania, zostaną wznowione w tej samej kolejności, w jakiej zostały wstrzymane (FIFO).</span><span class="sxs-lookup"><span data-stu-id="00e57-582">If multiple threads are suspended on the same counting semaphore, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="00e57-583">Jednak możliwość wznowienia priorytetu jest również możliwa, jeśli aplikacja wywołuje ***tx_semaphore_prioritize*** przed wywołaniem semafora, które zawiesić wątek dźwigu.</span><span class="sxs-lookup"><span data-stu-id="00e57-583">However, priority resumption is also possible if the application calls ***tx_semaphore_prioritize*** prior to the semaphore put call that lifts thread suspension.</span></span> <span data-ttu-id="00e57-584">Usługa semafor priorytetyzacji powoduje umieszczenie wątku o najwyższym priorytecie na początku listy zawieszania, pozostawiając wszystkie pozostałe zawieszone wątki w tej samej kolejności FIFO.</span><span class="sxs-lookup"><span data-stu-id="00e57-584">The semaphore prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="semaphore-put-notification"></a><span data-ttu-id="00e57-585">Powiadomienie o wprowadzeniu semafora</span><span class="sxs-lookup"><span data-stu-id="00e57-585">Semaphore Put Notification</span></span>

<span data-ttu-id="00e57-586">Niektóre aplikacje mogą otrzymywać powiadomienia o każdym umieszczeniu semafora.</span><span class="sxs-lookup"><span data-stu-id="00e57-586">Some applications may find it advantageous to be notified whenever a semaphore is put.</span></span> <span data-ttu-id="00e57-587">ThreadX zapewnia tę możliwość za pomocą usługi ***tx_semaphore_put_notify*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-587">ThreadX provides this ability through the ***tx_semaphore_put_notify*** service.</span></span> <span data-ttu-id="00e57-588">Ta usługa rejestruje podaną funkcję powiadamiania aplikacji z określonym semaforem.</span><span class="sxs-lookup"><span data-stu-id="00e57-588">This service registers the supplied application notification function with the specified semaphore.</span></span> <span data-ttu-id="00e57-589">ThreadX następnie wywoła tę funkcję powiadamiania aplikacji za każdym razem, gdy semafor zostanie umieszczony.</span><span class="sxs-lookup"><span data-stu-id="00e57-589">ThreadX will subsequently invoke this application notification function whenever the semaphore is put.</span></span> <span data-ttu-id="00e57-590">Dokładne przetwarzanie w ramach funkcji powiadomień aplikacji jest określane przez aplikację; jednak zwykle składa się z wznawiania odpowiedniego wątku do przetwarzania nowego zdarzenia Put.</span><span class="sxs-lookup"><span data-stu-id="00e57-590">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new semaphore put event.</span></span>

### <a name="semaphore-event-chainingtrade"></a><span data-ttu-id="00e57-591">Łańcuch zdarzeń semaforów&trade;</span><span class="sxs-lookup"><span data-stu-id="00e57-591">Semaphore Event chaining&trade;</span></span>

<span data-ttu-id="00e57-592">Funkcje powiadamiania w programie ThreadX mogą służyć do łańcucha różnych zdarzeń synchronizacji razem.</span><span class="sxs-lookup"><span data-stu-id="00e57-592">The notification capabilities in ThreadX can be used to chain various synchronization events together.</span></span> <span data-ttu-id="00e57-593">Jest to zazwyczaj przydatne, gdy pojedynczy wątek musi przetwarzać wiele zdarzeń synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-593">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="00e57-594">Na przykład zamiast konieczności zawieszania oddzielnych wątków dla komunikatu kolejki, flag zdarzeń i semafora aplikacja może zarejestrować procedurę powiadamiania dla każdego obiektu.</span><span class="sxs-lookup"><span data-stu-id="00e57-594">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="00e57-595">Po wywołaniu procedura powiadamiania aplikacji może następnie wznowić pojedynczy wątek, który może przejrzeć każdy obiekt, aby znaleźć i przetworzyć nowe zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="00e57-595">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="00e57-596">Ogólnie rzecz biorąc, *łańcuch zdarzeń* powoduje zmniejszenie liczby wątków, mniejsze obciążenie i mniejsze wymagania dotyczące pamięci RAM.</span><span class="sxs-lookup"><span data-stu-id="00e57-596">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="00e57-597">Zapewnia również wysoce elastyczny mechanizm obsługujący wymagania dotyczące synchronizacji bardziej złożonych systemów.</span><span class="sxs-lookup"><span data-stu-id="00e57-597">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-semaphore-performance-information"></a><span data-ttu-id="00e57-598">Informacje o wydajności semafora czasu wykonywania</span><span class="sxs-lookup"><span data-stu-id="00e57-598">Run-time Semaphore Performance Information</span></span>

<span data-ttu-id="00e57-599">ThreadX zapewnia opcjonalne informacje o wydajności semaforów czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="00e57-599">ThreadX provides optional run-time semaphore performance information.</span></span> <span data-ttu-id="00e57-600">Jeśli biblioteka i aplikacja ThreadX została skompilowana przy użyciu zdefiniowanych **TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO** , ThreadX gromadzi poniższe informacje.</span><span class="sxs-lookup"><span data-stu-id="00e57-600">If the ThreadX library and application is built with **TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="00e57-601">Łączna liczba dla całego systemu:</span><span class="sxs-lookup"><span data-stu-id="00e57-601">Total number for the overall system:</span></span>

  - <span data-ttu-id="00e57-602">Umieszczanie semaforów</span><span class="sxs-lookup"><span data-stu-id="00e57-602">semaphore puts</span></span>

  - <span data-ttu-id="00e57-603">Pobieranie semafora</span><span class="sxs-lookup"><span data-stu-id="00e57-603">semaphore gets</span></span>

  - <span data-ttu-id="00e57-604">zawieszenie pobierania semaforów</span><span class="sxs-lookup"><span data-stu-id="00e57-604">semaphore get suspensions</span></span>

  - <span data-ttu-id="00e57-605">limity czasu pobierania semaforów</span><span class="sxs-lookup"><span data-stu-id="00e57-605">semaphore get timeouts</span></span>

<span data-ttu-id="00e57-606">Łączna liczba dla każdego semafora:</span><span class="sxs-lookup"><span data-stu-id="00e57-606">Total number for each semaphore:</span></span>

  - <span data-ttu-id="00e57-607">Umieszczanie semaforów</span><span class="sxs-lookup"><span data-stu-id="00e57-607">semaphore puts</span></span>

  - <span data-ttu-id="00e57-608">Pobieranie semafora</span><span class="sxs-lookup"><span data-stu-id="00e57-608">semaphore gets</span></span>

  - <span data-ttu-id="00e57-609">zawieszenie pobierania semaforów</span><span class="sxs-lookup"><span data-stu-id="00e57-609">semaphore get suspensions</span></span>

  - <span data-ttu-id="00e57-610">limity czasu pobierania semaforów</span><span class="sxs-lookup"><span data-stu-id="00e57-610">semaphore get timeouts</span></span>

<span data-ttu-id="00e57-611">Te informacje są dostępne w czasie wykonywania za pomocą usług \***tx_semaphore_performance_info_get** _ i _ *_tx_semaphore_performance_system_info_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="00e57-611">This information is available at run-time through the services ***tx_semaphore_performance_info_get** _ and _*_tx_semaphore_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="00e57-612">Informacje o wydajności semaforów są przydatne w ustaleniu, czy aplikacja działa prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="00e57-612">Semaphore performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="00e57-613">Jest on również przydatny do optymalizowania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-613">It is also useful in optimizing the application.</span></span> <span data-ttu-id="00e57-614">Na przykład stosunkowo wysoka liczba przekroczeń limitu czasu "Semafor" może sugerować, że inne wątki są zbyt długie.</span><span class="sxs-lookup"><span data-stu-id="00e57-614">For example, a relatively high number of "semaphore get timeouts" might suggest that other threads are holding resources too long.</span></span>

### <a name="semaphore-control-block-tx_semaphore"></a><span data-ttu-id="00e57-615">Blok sterowania semaforem TX_SEMAPHORE</span><span class="sxs-lookup"><span data-stu-id="00e57-615">Semaphore Control Block TX_SEMAPHORE</span></span>

<span data-ttu-id="00e57-616">Charakterystyka każdego semafora zliczania znajduje się w jego bloku sterowania.</span><span class="sxs-lookup"><span data-stu-id="00e57-616">The characteristics of each counting semaphore are found in its control block.</span></span> <span data-ttu-id="00e57-617">Zawiera informacje, takie jak bieżąca liczba semaforów.</span><span class="sxs-lookup"><span data-stu-id="00e57-617">It contains information such as the current semaphore count.</span></span> <span data-ttu-id="00e57-618">Ta struktura jest zdefiniowana w pliku ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-618">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="00e57-619">Bloki sterujące semaforów mogą znajdować się w dowolnym miejscu w pamięci, ale najczęściej jest to, że formant blokuje strukturę globalną poprzez definiowanie jej poza zakresem dowolnej funkcji.</span><span class="sxs-lookup"><span data-stu-id="00e57-619">Semaphore control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="00e57-620">Deadly</span><span class="sxs-lookup"><span data-stu-id="00e57-620">Deadly Embrace</span></span>

<span data-ttu-id="00e57-621">Jednym z najbardziej interesujących i niebezpiecznych pułapek związanych z semaforami używanymi do wzajemnego wykluczania jest *Deadly*.</span><span class="sxs-lookup"><span data-stu-id="00e57-621">One of the most interesting and dangerous pitfalls associated with semaphores used for mutual exclusion is the *deadly embrace*.</span></span> <span data-ttu-id="00e57-622">Deadly to *warunek, w* którym co najmniej dwa wątki są zawieszane w nieskończoność podczas próby uzyskania semaforów, które są już własnością siebie.</span><span class="sxs-lookup"><span data-stu-id="00e57-622">A deadly embrace, or *deadlock*, is a condition in which two or more threads are suspended indefinitely while attempting to get semaphores already owned by each other.</span></span>

<span data-ttu-id="00e57-623">Ten warunek jest najlepiej zilustrowany przez dwa wątki, dwa przykładowe semafory.</span><span class="sxs-lookup"><span data-stu-id="00e57-623">This condition is best illustrated by a two thread, two semaphore example.</span></span> <span data-ttu-id="00e57-624">Załóżmy, że pierwszy wątek jest właścicielem pierwszego semafora, a drugi wątek jest właścicielem drugiego semafora.</span><span class="sxs-lookup"><span data-stu-id="00e57-624">Suppose the first thread owns the first semaphore and the second thread owns the second semaphore.</span></span> <span data-ttu-id="00e57-625">Jeśli pierwszy wątek próbuje uzyskać drugi semafor i w tym samym czasie drugi wątek próbuje uzyskać pierwszy semafor, oba wątki wprowadzają warunek zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="00e57-625">If the first thread attempts to get the second semaphore and at the same time the second thread attempts to get the first semaphore, both threads enter a deadlock condition.</span></span> <span data-ttu-id="00e57-626">Ponadto, jeśli te wątki pozostają nieznacznie zawieszone, ich skojarzone zasoby są domyślnie zablokowane.</span><span class="sxs-lookup"><span data-stu-id="00e57-626">In addition, if these threads stay suspended forever, their associated resources are locked-out forever as well.</span></span> <span data-ttu-id="00e57-627">Rysunek 8 ilustruje ten przykład.</span><span class="sxs-lookup"><span data-stu-id="00e57-627">Figure 8 illustrates this example.</span></span>

<span data-ttu-id="00e57-628">**Deadly** (przykład)</span><span class="sxs-lookup"><span data-stu-id="00e57-628">**Deadly Embrace** (example)</span></span>

![Przykład zawieszonych wątków](./media/user-guide/example-suspended-threads.png)

<span data-ttu-id="00e57-630">**RYSUNEK 8. Przykład zawieszonych wątków**</span><span class="sxs-lookup"><span data-stu-id="00e57-630">**FIGURE 8. Example of Suspended Threads**</span></span>

<span data-ttu-id="00e57-631">W przypadku systemów w czasie rzeczywistym Deadly można zapobiec, wprowadzając pewne ograniczenia dotyczące sposobu, w jaki wątki uzyskują semafory.</span><span class="sxs-lookup"><span data-stu-id="00e57-631">For real-time systems, deadly embraces can be prevented by placing certain restrictions on how threads obtain semaphores.</span></span> <span data-ttu-id="00e57-632">Wątki mogą mieć tylko jeden semafor jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="00e57-632">Threads can only have one semaphore at a time.</span></span> <span data-ttu-id="00e57-633">Alternatywnie wątki mogą mieć wiele semaforów, jeśli zbierają je w takiej samej kolejności.</span><span class="sxs-lookup"><span data-stu-id="00e57-633">Alternatively, threads can own multiple semaphores if they gather them in the same order.</span></span> <span data-ttu-id="00e57-634">W poprzednim przykładzie, jeśli pierwszy i drugi wątek uzyskuje pierwszy i drugi semafor w kolejności, wdrożenie Deadly jest uniemożliwione.</span><span class="sxs-lookup"><span data-stu-id="00e57-634">In the previous example, if the first and second thread obtain the first and second semaphore in order, the deadly embrace is prevented.</span></span>

> [!TIP]
> <span data-ttu-id="00e57-635">*Można również użyć limitu czasu zawieszenia skojarzonego z operacją pobierania, aby odzyskać z Deadly.*</span><span class="sxs-lookup"><span data-stu-id="00e57-635">*It is also possible to use the suspension time-out associated with the get operation to recover from a deadly embrace.*</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="00e57-636">Priorytetowa wersja</span><span class="sxs-lookup"><span data-stu-id="00e57-636">Priority Inversion</span></span>

<span data-ttu-id="00e57-637">Inna Pitfall skojarzona z wzajemnymi semaforami wykluczeń jest w wersji priorytetowej.</span><span class="sxs-lookup"><span data-stu-id="00e57-637">Another pitfall associated with mutual exclusion semaphores is priority inversion.</span></span> <span data-ttu-id="00e57-638">Ten temat został omówiony w pełni w sekcji "[priorytet wątku pułapek](#thread-priority-pitfalls)".</span><span class="sxs-lookup"><span data-stu-id="00e57-638">This topic is discussed more fully in "[Thread Priority Pitfalls](#thread-priority-pitfalls)".</span></span>

<span data-ttu-id="00e57-639">Podstawowy problem wynika z sytuacji, w której wątek o niższym priorytecie ma semafor, którego potrzebuje wątek o wyższym priorytecie.</span><span class="sxs-lookup"><span data-stu-id="00e57-639">The basic problem results from a situation in which a lower-priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="00e57-640">Jest to normalne.</span><span class="sxs-lookup"><span data-stu-id="00e57-640">This in itself is normal.</span></span> <span data-ttu-id="00e57-641">Jednak wątki z priorytetami między nimi mogą spowodować, że priorytet Inwersja do ostatniego niedeterministycznego czasu.</span><span class="sxs-lookup"><span data-stu-id="00e57-641">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="00e57-642">Może to być obsługiwane przez staranne wybranie priorytetów wątków, użycie wartości progowej przechodzenia i tymczasowe zwiększenie priorytetu wątku, który jest właścicielem zasobu, do tego wątku o wysokim priorytecie.</span><span class="sxs-lookup"><span data-stu-id="00e57-642">This can be handled through careful selection of thread priorities, using preemption-threshold, and temporarily raising the priority of the thread that owns the resource to that of the high priority thread.</span></span>

## <a name="mutexes"></a><span data-ttu-id="00e57-643">Muteksy</span><span class="sxs-lookup"><span data-stu-id="00e57-643">Mutexes</span></span>

<span data-ttu-id="00e57-644">Oprócz semaforów ThreadX udostępnia również obiekt mutex.</span><span class="sxs-lookup"><span data-stu-id="00e57-644">In addition to semaphores, ThreadX also provides a mutex object.</span></span> <span data-ttu-id="00e57-645">Mutex jest zasadniczo binarny semafor, co oznacza, że tylko jeden wątek może być właścicielem obiektu mutex jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="00e57-645">A mutex is basically a binary semaphore, which means that only one thread can own a mutex at a time.</span></span> <span data-ttu-id="00e57-646">Ponadto ten sam wątek może wykonać pomyślną operację pobrania muteksa na należącym do obiektu mutex wiele razy, 4 294 967 295.</span><span class="sxs-lookup"><span data-stu-id="00e57-646">In addition, the same thread may perform a successful mutex get operation on an owned mutex multiple times, 4,294,967,295 to be exact.</span></span> <span data-ttu-id="00e57-647">Istnieją dwie operacje na obiekcie mutex: \***tx_mutex_get** _ i _ *_tx_mutex_put_* \*.</span><span class="sxs-lookup"><span data-stu-id="00e57-647">There are two operations on the mutex object: ***tx_mutex_get** _ and _*_tx_mutex_put_\*\*.</span></span> <span data-ttu-id="00e57-648">Operacja get uzyskuje mutex, który nie należy do innego wątku, podczas gdy operacja Put zwalnia poprzednio uzyskany obiekt mutex.</span><span class="sxs-lookup"><span data-stu-id="00e57-648">The get operation obtains a mutex not owned by another thread, while the put operation releases a previously obtained mutex.</span></span> <span data-ttu-id="00e57-649">W przypadku wątku do zwolnienia muteksu liczba operacji Put musi być równa liczbie wcześniejszych operacji pobierania.</span><span class="sxs-lookup"><span data-stu-id="00e57-649">For a thread to release a mutex, the number of put operations must equal the number of prior get operations.</span></span>

<span data-ttu-id="00e57-650">Każdy mutex jest zasobem publicznym.</span><span class="sxs-lookup"><span data-stu-id="00e57-650">Each mutex is a public resource.</span></span> <span data-ttu-id="00e57-651">ThreadX nie nakłada żadnych ograniczeń dotyczących sposobu używania muteksów.</span><span class="sxs-lookup"><span data-stu-id="00e57-651">ThreadX places no constraints on how mutexes are used.</span></span>

<span data-ttu-id="00e57-652">Muteksy ThreadX są używane wyłącznie do *wzajemnego wykluczania*.</span><span class="sxs-lookup"><span data-stu-id="00e57-652">ThreadX mutexes are used solely for *mutual exclusion*.</span></span> <span data-ttu-id="00e57-653">W przeciwieństwie do zliczania semaforów, muteksy nie mają zastosowania jako metody powiadamiania o zdarzeniach.</span><span class="sxs-lookup"><span data-stu-id="00e57-653">Unlike counting semaphores, mutexes have no use as a method for event notification.</span></span>

### <a name="mutex-mutual-exclusion"></a><span data-ttu-id="00e57-654">Wzajemne wykluczenie obiektu mutex</span><span class="sxs-lookup"><span data-stu-id="00e57-654">Mutex Mutual Exclusion</span></span>

<span data-ttu-id="00e57-655">Podobnie jak w przypadku dyskusji w sekcji zliczanie semaforów, wzajemne wykluczenia dotyczy kontroli dostępu wątków do określonych obszarów aplikacji (nazywanych także *sekcjami krytycznymi* lub *zasobami aplikacji*).</span><span class="sxs-lookup"><span data-stu-id="00e57-655">Similar to the discussion in the counting semaphore section, mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="00e57-656">Jeśli jest dostępny, ThreadX mutex będzie miał liczbę własności równą 0.</span><span class="sxs-lookup"><span data-stu-id="00e57-656">When available, a ThreadX mutex will have an ownership count of 0.</span></span> <span data-ttu-id="00e57-657">Po uzyskaniu elementu mutex przez wątek licznik własności jest zwiększany raz dla każdego pomyślnego wykonania operacji pobrania dla obiektu mutex i zmniejszany dla każdej pomyślnej operacji Put.</span><span class="sxs-lookup"><span data-stu-id="00e57-657">After the mutex is obtained by a thread, the ownership count is incremented once for every successful get operation performed on the mutex and decremented for every successful put operation.</span></span>

### <a name="creating-mutexes"></a><span data-ttu-id="00e57-658">Tworzenie muteksów</span><span class="sxs-lookup"><span data-stu-id="00e57-658">Creating Mutexes</span></span>

<span data-ttu-id="00e57-659">ThreadX muteksy są tworzone podczas inicjacji lub w czasie wykonywania przez wątki aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-659">ThreadX mutexes are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="00e57-660">Początkowy warunek elementu mutex jest zawsze dostępny.</span><span class="sxs-lookup"><span data-stu-id="00e57-660">The initial condition of a mutex is always "available."</span></span> <span data-ttu-id="00e57-661">Można również utworzyć element mutex z wybranym *dziedziczeniem priorytetu* .</span><span class="sxs-lookup"><span data-stu-id="00e57-661">A mutex may also be created with *priority inheritance* selected.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="00e57-662">Zawieszenie wątku</span><span class="sxs-lookup"><span data-stu-id="00e57-662">Thread Suspension</span></span>

<span data-ttu-id="00e57-663">Wątki aplikacji mogą wstrzymywać się podczas próby wykonania operacji get na elemencie mutex, który jest już własnością innego wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-663">Application threads can suspend while attempting to perform a get operation on a mutex already owned by another thread.</span></span>

<span data-ttu-id="00e57-664">Po wykonaniu tej samej liczby operacji Put przez wątek będącego właścicielem zostanie wykonana operacja pobrania zawieszonego wątku, która nadaje mu własność elementu mutex, a wątek zostaje wznowiony.</span><span class="sxs-lookup"><span data-stu-id="00e57-664">After the same number of put operations are performed by the owning thread, the suspended thread's get operation is performed, giving it ownership of the mutex, and the thread is resumed.</span></span> <span data-ttu-id="00e57-665">Jeśli wiele wątków jest zawieszonych na tym samym elemencie mutex, są wznawiane w tej samej kolejności, w jakiej zostały zawieszone (FIFO).</span><span class="sxs-lookup"><span data-stu-id="00e57-665">If multiple threads are suspended on the same mutex, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="00e57-666">Jednak wznowienie priorytetu odbywa się automatycznie, jeśli podczas tworzenia wybrano dziedziczenie priorytetu obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="00e57-666">However, priority resumption is done automatically if the mutex priority inheritance was selected during creation.</span></span> <span data-ttu-id="00e57-667">Możliwe jest również wznowienie priorytetu, jeśli aplikacja wywołuje ***tx_mutex_prioritize*** przed wywołaniem obiektu mutex, które zawieszania wątku Wind.</span><span class="sxs-lookup"><span data-stu-id="00e57-667">Priority resumption is also possible if the application calls ***tx_mutex_prioritize*** prior to the mutex put call that lifts thread suspension.</span></span> <span data-ttu-id="00e57-668">Usługa określania priorytetów obiektów mutex umieszcza wątek o najwyższym priorytecie na początku listy zawieszania, pozostawiając wszystkie pozostałe zawieszone wątki w tej samej kolejności FIFO.</span><span class="sxs-lookup"><span data-stu-id="00e57-668">The mutex prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-mutex-performance-information"></a><span data-ttu-id="00e57-669">Informacje o wydajności muteksu w czasie wykonywania</span><span class="sxs-lookup"><span data-stu-id="00e57-669">Run-time Mutex Performance Information</span></span>

<span data-ttu-id="00e57-670">ThreadX zapewnia opcjonalne informacje o wydajności muteksu w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="00e57-670">ThreadX provides optional run-time mutex performance information.</span></span> <span data-ttu-id="00e57-671">Jeśli biblioteka i aplikacja ThreadX została skompilowana przy użyciu zdefiniowanych **TX_MUTEX_ENABLE_PERFORMANCE_INFO** , ThreadX gromadzi poniższe informacje.</span><span class="sxs-lookup"><span data-stu-id="00e57-671">If the ThreadX library and application is built with **TX_MUTEX_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="00e57-672">Łączna liczba dla całego systemu:</span><span class="sxs-lookup"><span data-stu-id="00e57-672">Total number for the overall system:</span></span>

- <span data-ttu-id="00e57-673">Umieszczanie obiektów mutex</span><span class="sxs-lookup"><span data-stu-id="00e57-673">mutex puts</span></span>

- <span data-ttu-id="00e57-674">Pobieranie obiektu mutex</span><span class="sxs-lookup"><span data-stu-id="00e57-674">mutex gets</span></span>

- <span data-ttu-id="00e57-675">wstrzymanie pobierania obiektu mutex</span><span class="sxs-lookup"><span data-stu-id="00e57-675">mutex get suspensions</span></span>

- <span data-ttu-id="00e57-676">limity czasu pobierania dla obiektu mutex</span><span class="sxs-lookup"><span data-stu-id="00e57-676">mutex get timeouts</span></span>

- <span data-ttu-id="00e57-677">Brak wersji priorytetu obiektu mutex</span><span class="sxs-lookup"><span data-stu-id="00e57-677">mutex priority inversions</span></span>

- <span data-ttu-id="00e57-678">Dziedziczenie priorytetu obiektu mutex</span><span class="sxs-lookup"><span data-stu-id="00e57-678">mutex priority inheritances</span></span>

<span data-ttu-id="00e57-679">Łączna liczba dla każdego muteksu:</span><span class="sxs-lookup"><span data-stu-id="00e57-679">Total number for each mutex:</span></span>

  - <span data-ttu-id="00e57-680">Umieszczanie obiektów mutex</span><span class="sxs-lookup"><span data-stu-id="00e57-680">mutex puts</span></span>

  - <span data-ttu-id="00e57-681">Pobieranie obiektu mutex</span><span class="sxs-lookup"><span data-stu-id="00e57-681">mutex gets</span></span>

  - <span data-ttu-id="00e57-682">wstrzymanie pobierania obiektu mutex</span><span class="sxs-lookup"><span data-stu-id="00e57-682">mutex get suspensions</span></span>

  - <span data-ttu-id="00e57-683">limity czasu pobierania dla obiektu mutex</span><span class="sxs-lookup"><span data-stu-id="00e57-683">mutex get timeouts</span></span>

  - <span data-ttu-id="00e57-684">Brak wersji priorytetu obiektu mutex</span><span class="sxs-lookup"><span data-stu-id="00e57-684">mutex priority inversions</span></span>

  - <span data-ttu-id="00e57-685">Dziedziczenie priorytetu obiektu mutex</span><span class="sxs-lookup"><span data-stu-id="00e57-685">mutex priority inheritances</span></span>

<span data-ttu-id="00e57-686">Te informacje są dostępne w czasie wykonywania za pomocą usług \***tx_mutex_performance_info_get** _ i _ *_tx_mutex_performance_system_info_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="00e57-686">This information is available at run-time through the services ***tx_mutex_performance_info_get** _ and _*_tx_mutex_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="00e57-687">Informacje o wydajności muteksu są przydatne podczas ustalania, czy aplikacja działa prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="00e57-687">Mutex performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="00e57-688">Jest on również przydatny do optymalizowania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-688">It is also useful in optimizing the application.</span></span> <span data-ttu-id="00e57-689">Na przykład stosunkowo wysoka liczba przekroczeń limitu czasu "mutex" może sugerować, że inne wątki są zbyt długie.</span><span class="sxs-lookup"><span data-stu-id="00e57-689">For example, a relatively high number of "mutex get timeouts" might suggest that other threads are holding resources too long.</span></span>

### <a name="mutex-control-block-tx_mutex"></a><span data-ttu-id="00e57-690">Blok sterowania muteksem TX_MUTEX</span><span class="sxs-lookup"><span data-stu-id="00e57-690">Mutex Control Block TX_MUTEX</span></span>

<span data-ttu-id="00e57-691">Charakterystyki każdego obiektu mutex są dostępne w jego bloku sterowania.</span><span class="sxs-lookup"><span data-stu-id="00e57-691">The characteristics of each mutex are found in its control block.</span></span> <span data-ttu-id="00e57-692">Zawiera informacje, takie jak bieżąca liczba własności obiektu mutex oraz wskaźnik wątku, który jest właścicielem obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="00e57-692">It contains information such as the current mutex ownership count along with the pointer of the thread that owns the mutex.</span></span> <span data-ttu-id="00e57-693">Ta struktura jest zdefiniowana w pliku ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-693">This structure is defined in the ***tx_api.h*** file.</span></span> <span data-ttu-id="00e57-694">Bloki sterujące muteksem mogą znajdować się w dowolnym miejscu w pamięci, ale najczęściej jest to, że formant blokuje strukturę globalną poprzez definiowanie jej poza zakresem dowolnej funkcji.</span><span class="sxs-lookup"><span data-stu-id="00e57-694">Mutex control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="00e57-695">Deadly</span><span class="sxs-lookup"><span data-stu-id="00e57-695">Deadly Embrace</span></span>

<span data-ttu-id="00e57-696">Jednym z najbardziej interesujących i niebezpiecznych pułapek związanych z własnością obiektu mutex jest *Deadly*.</span><span class="sxs-lookup"><span data-stu-id="00e57-696">One of the most interesting and dangerous pitfalls associated with mutex ownership is the *deadly embrace*.</span></span> <span data-ttu-id="00e57-697">Deadly, lub *zakleszczenie*, to warunek, w którym co najmniej dwa wątki są zawieszane w nieskończoność podczas próby uzyskania obiektu mutex, który jest już własnością innych wątków.</span><span class="sxs-lookup"><span data-stu-id="00e57-697">A deadly embrace, or *deadlock*, is a condition where two or more threads are suspended indefinitely while attempting to get a mutex already owned by the other threads.</span></span> <span data-ttu-id="00e57-698">Dyskusja dotycząca *Deadly* i ich środki zaradcze są całkowicie prawidłowe dla obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="00e57-698">The discussion of *deadly embrace* and its remedies are completely valid for the mutex object as well.</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="00e57-699">Priorytetowa wersja</span><span class="sxs-lookup"><span data-stu-id="00e57-699">Priority Inversion</span></span>

<span data-ttu-id="00e57-700">Jak wspomniano wcześniej, głównym pitfallą skojarzoną z wzajemnym wykluczeniem jest priorytetowa wersja.</span><span class="sxs-lookup"><span data-stu-id="00e57-700">As mentioned previously, a major pitfall associated with mutual exclusion is priority inversion.</span></span> <span data-ttu-id="00e57-701">Ten temat został omówiony w pełni w sekcji "[priorytet wątku pułapek](#thread-priority-pitfalls)".</span><span class="sxs-lookup"><span data-stu-id="00e57-701">This topic is discussed more fully in "[Thread Priority Pitfalls](#thread-priority-pitfalls)".</span></span>

<span data-ttu-id="00e57-702">Podstawowy problem wynika z sytuacji, w której wątek o niższym priorytecie ma semafor, którego potrzebuje wątek o wyższym priorytecie.</span><span class="sxs-lookup"><span data-stu-id="00e57-702">The basic problem results from a situation in which a lower priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="00e57-703">Jest to normalne.</span><span class="sxs-lookup"><span data-stu-id="00e57-703">This in itself is normal.</span></span> <span data-ttu-id="00e57-704">Jednak wątki z priorytetami między nimi mogą spowodować, że priorytet Inwersja do ostatniego niedeterministycznego czasu.</span><span class="sxs-lookup"><span data-stu-id="00e57-704">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="00e57-705">W przeciwieństwie do semaforów omówionych wcześniej, obiekt mutex ThreadX ma opcjonalne *dziedziczenie priorytetu*.</span><span class="sxs-lookup"><span data-stu-id="00e57-705">Unlike semaphores discussed previously, the ThreadX mutex object has optional *priority inheritance*.</span></span> <span data-ttu-id="00e57-706">Podstawowym pomysłem związanym z dziedziczeniem priorytetu jest to, że priorytet wątku o niższym priorytecie jest tymczasowo podniesiony do priorytetu wątku o wysokim priorytecie, który chce mieć ten sam mutex, którego właścicielem jest wątek o niższym priorytecie.</span><span class="sxs-lookup"><span data-stu-id="00e57-706">The basic idea behind priority inheritance is that a lower priority thread has its priority raised temporarily to the priority of a high priority thread that wants the same mutex owned by the lower priority thread.</span></span> <span data-ttu-id="00e57-707">Gdy wątek o niższym priorytecie zwalnia element mutex, jego oryginalny priorytet jest następnie przywracany, a wątek o wyższym priorytecie otrzymuje własność obiektu mutex.</span><span class="sxs-lookup"><span data-stu-id="00e57-707">When the lower priority thread releases the mutex, its original priority is then restored and the higher priority thread is given ownership of the mutex.</span></span> <span data-ttu-id="00e57-708">Ta funkcja eliminuje niedeterministyczną wersję priorytetu, zależnie od ilości inwersji do momentu, w którym wątek o niższym priorytecie utrzymuje element mutex.</span><span class="sxs-lookup"><span data-stu-id="00e57-708">This feature eliminates nondeterministic priority inversion by bounding the amount of inversion to the time the lower priority thread holds the mutex.</span></span> <span data-ttu-id="00e57-709">Oczywiście techniki omówione wcześniej w tym rozdziale do obsługi niedeterministycznych nieposiadanych priorytetów są również prawidłowe dla muteksów.</span><span class="sxs-lookup"><span data-stu-id="00e57-709">Of course, the techniques discussed earlier in this chapter to handle nondeterministic priority inversion are also valid with mutexes as well.</span></span>

## <a name="event-flags"></a><span data-ttu-id="00e57-710">Flagi zdarzeń</span><span class="sxs-lookup"><span data-stu-id="00e57-710">Event Flags</span></span>

<span data-ttu-id="00e57-711">Flagi zdarzeń zapewniają zaawansowane narzędzie do synchronizacji wątków.</span><span class="sxs-lookup"><span data-stu-id="00e57-711">Event flags provide a powerful tool for thread synchronization.</span></span> <span data-ttu-id="00e57-712">Każda flaga zdarzenia jest reprezentowana przez jeden bit.</span><span class="sxs-lookup"><span data-stu-id="00e57-712">Each event flag is represented by a single bit.</span></span> <span data-ttu-id="00e57-713">Flagi zdarzeń są rozmieszczone w grupach 32.</span><span class="sxs-lookup"><span data-stu-id="00e57-713">Event flags are arranged in groups of 32.</span></span> <span data-ttu-id="00e57-714">Wątki mogą obsługiwać wszystkie flagi zdarzeń 32 w grupie w tym samym czasie.</span><span class="sxs-lookup"><span data-stu-id="00e57-714">Threads can operate on all 32 event flags in a group at the same time.</span></span> <span data-ttu-id="00e57-715">Zdarzenia są ustawiane przez \***tx_event_flags_set** _ i pobierane przez _ *_tx_event_flags_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="00e57-715">Events are set by ***tx_event_flags_set** _ and are retrieved by _*_tx_event_flags_get_\*\*.</span></span>

<span data-ttu-id="00e57-716">Ustawianie flag zdarzeń odbywa się z użyciem operacji logicznej i/lub między bieżącymi flagami zdarzenia i nowymi flagami zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="00e57-716">Setting event flags is done with a logical AND/OR operation between the current event flags and the new event flags.</span></span> <span data-ttu-id="00e57-717">Typ operacji logicznej (i lub lub) jest określony w wywołaniu ***tx_event_flags_set*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-717">The type of logical operation (either an AND or OR) is specified in the ***tx_event_flags_set*** call.</span></span>

<span data-ttu-id="00e57-718">Istnieją podobne opcje logiczne do pobierania flag zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="00e57-718">There are similar logical options for retrieval of event flags.</span></span> <span data-ttu-id="00e57-719">Żądanie Get może określać, że wszystkie określone flagi zdarzeń są wymagane (logiczne i).</span><span class="sxs-lookup"><span data-stu-id="00e57-719">A get request can specify that all specified event flags are required (a logical AND).</span></span>

<span data-ttu-id="00e57-720">Alternatywnie żądanie Get może określać, że dowolne z określonych flag zdarzeń będzie spełniać żądanie (logiczne lub).</span><span class="sxs-lookup"><span data-stu-id="00e57-720">Alternatively, a get request can specify that any of the specified event flags will satisfy the request (a logical OR).</span></span> <span data-ttu-id="00e57-721">Typ operacji logicznej skojarzonej z pobieraniem flag zdarzeń jest określany w wywołaniu ***tx_event_flags_get*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-721">The type of logical operation associated with event flags retrieval is specified in the ***tx_event_flags_get*** call.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="00e57-722">*Flagi zdarzeń, które spełniają żądanie Get, są używane, tj. ustawione na zero, jeśli* **TX_OR_CLEAR** *lub* **TX_AND_CLEAR** *są określone przez żądanie.*</span><span class="sxs-lookup"><span data-stu-id="00e57-722">*Event flags that satisfy a get request are consumed, i.e., set to zero, if* **TX_OR_CLEAR** *or* **TX_AND_CLEAR** *are specified by the request.*</span></span>

<span data-ttu-id="00e57-723">Każda grupa flag zdarzeń jest zasobem publicznym.</span><span class="sxs-lookup"><span data-stu-id="00e57-723">Each event flags group is a public resource.</span></span> <span data-ttu-id="00e57-724">ThreadX nie wprowadza żadnych ograniczeń dotyczących sposobu używania grup flag zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="00e57-724">ThreadX places no constraints on how event flags groups are used.</span></span>

### <a name="creating-event-flags-groups"></a><span data-ttu-id="00e57-725">Tworzenie grup flag zdarzeń</span><span class="sxs-lookup"><span data-stu-id="00e57-725">Creating Event Flags Groups</span></span>

<span data-ttu-id="00e57-726">Grupy flag zdarzeń są tworzone podczas inicjacji lub w czasie wykonywania przez wątki aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-726">Event flags groups are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="00e57-727">W momencie ich tworzenia wszystkie flagi zdarzeń w grupie mają ustawioną wartość zero.</span><span class="sxs-lookup"><span data-stu-id="00e57-727">At the time of their creation, all event flags in the group are set to zero.</span></span> <span data-ttu-id="00e57-728">Nie ma żadnego limitu liczby grup flag zdarzeń w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-728">There is no limit on the number of event flags groups in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="00e57-729">Zawieszenie wątku</span><span class="sxs-lookup"><span data-stu-id="00e57-729">Thread Suspension</span></span>

<span data-ttu-id="00e57-730">Wątki aplikacji mogą wstrzymywać się podczas próby pobrania logicznej kombinacji flag zdarzeń z grupy.</span><span class="sxs-lookup"><span data-stu-id="00e57-730">Application threads can suspend while attempting to get any logical combination of event flags from a group.</span></span> <span data-ttu-id="00e57-731">Po ustawieniu flagi zdarzenia żądania GET wszystkich zawieszonych wątków są przeglądane.</span><span class="sxs-lookup"><span data-stu-id="00e57-731">After an event flag is set, the get requests of all suspended threads are reviewed.</span></span> <span data-ttu-id="00e57-732">Wszystkie wątki, które mają teraz wymagane flagi zdarzeń, są wznawiane.</span><span class="sxs-lookup"><span data-stu-id="00e57-732">All the threads that now have the required event flags are resumed.</span></span>

> [!NOTE]
> <span data-ttu-id="00e57-733">*Wszystkie zawieszone wątki w grupie flag zdarzeń są przeglądane po ustawieniu flag zdarzeń. Oczywiście wprowadzają dodatkowe koszty. W związku z tym dobrym sposobem jest ograniczenie liczby wątków przy użyciu tej samej grupy flag zdarzeń do odpowiedniej liczby.*</span><span class="sxs-lookup"><span data-stu-id="00e57-733">*All suspended threads on an event flag group are reviewed when its event flags are set. This, of course, introduces additional overhead. Therefore, it is good practice to limit the number of threads using the same event flag group to a reasonable number.*</span></span>

### <a name="event-flags-set-notification"></a><span data-ttu-id="00e57-734">Powiadomienie o ustawieniu flag zdarzeń</span><span class="sxs-lookup"><span data-stu-id="00e57-734">Event Flags Set Notification</span></span>

<span data-ttu-id="00e57-735">Niektóre aplikacje mogą otrzymywać powiadomienia, gdy flaga zdarzenia jest ustawiona.</span><span class="sxs-lookup"><span data-stu-id="00e57-735">Some applications may find it advantageous to be notified whenever an event flag is set.</span></span> <span data-ttu-id="00e57-736">ThreadX zapewnia tę możliwość za pomocą usługi ***tx_event_flags_set_notify*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-736">ThreadX provides this ability through the ***tx_event_flags_set_notify*** service.</span></span> <span data-ttu-id="00e57-737">Ta usługa rejestruje podaną funkcję powiadamiania aplikacji z określoną grupą flag zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="00e57-737">This service registers the supplied application notification function with the specified event flags group.</span></span> <span data-ttu-id="00e57-738">ThreadX następnie wywoła tę funkcję powiadamiania aplikacji za każdym razem, gdy flaga zdarzenia w grupie zostanie ustawiona.</span><span class="sxs-lookup"><span data-stu-id="00e57-738">ThreadX will subsequently invoke this application notification function whenever an event flag in the group is set.</span></span> <span data-ttu-id="00e57-739">Dokładne przetwarzanie w ramach funkcji powiadomień aplikacji jest określane przez aplikację, ale zazwyczaj polega na wznowieniu odpowiedniego wątku w celu przetworzenia nowej flagi zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="00e57-739">The exact processing within the application notification function is determined by the application, but it typically consists of resuming the appropriate thread for processing the new event flag.</span></span>

### <a name="event-flags-event-chainingtrade"></a><span data-ttu-id="00e57-740">Tworzenie łańcucha zdarzeń flag zdarzeń&trade;</span><span class="sxs-lookup"><span data-stu-id="00e57-740">Event Flags Event chaining&trade;</span></span>

<span data-ttu-id="00e57-741">Możliwości powiadomień w programie ThreadX mogą służyć do łączenia różnych zdarzeń synchronizacji ze sobą.</span><span class="sxs-lookup"><span data-stu-id="00e57-741">The notification capabilities in ThreadX can be used to "chain" various synchronization events together.</span></span> <span data-ttu-id="00e57-742">Jest to zazwyczaj przydatne, gdy pojedynczy wątek musi przetwarzać wiele zdarzeń synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-742">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="00e57-743">Na przykład zamiast konieczności zawieszania oddzielnych wątków dla komunikatu kolejki, flag zdarzeń i semafora aplikacja może zarejestrować procedurę powiadamiania dla każdego obiektu.</span><span class="sxs-lookup"><span data-stu-id="00e57-743">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="00e57-744">Po wywołaniu procedura powiadamiania aplikacji może następnie wznowić pojedynczy wątek, który może przejrzeć każdy obiekt, aby znaleźć i przetworzyć nowe zdarzenie.</span><span class="sxs-lookup"><span data-stu-id="00e57-744">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="00e57-745">Ogólnie rzecz biorąc, *łańcuch zdarzeń* powoduje zmniejszenie liczby wątków, mniejsze obciążenie i mniejsze wymagania dotyczące pamięci RAM.</span><span class="sxs-lookup"><span data-stu-id="00e57-745">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="00e57-746">Zapewnia również wysoce elastyczny mechanizm obsługujący wymagania dotyczące synchronizacji bardziej złożonych systemów.</span><span class="sxs-lookup"><span data-stu-id="00e57-746">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-event-flags-performance-information"></a><span data-ttu-id="00e57-747">Informacje o wydajności flag zdarzeń czasu wykonywania</span><span class="sxs-lookup"><span data-stu-id="00e57-747">Run-time Event Flags Performance Information</span></span>

<span data-ttu-id="00e57-748">ThreadX zapewnia opcjonalne informacje o wydajności flag w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="00e57-748">ThreadX provides optional run-time event flags performance information.</span></span> <span data-ttu-id="00e57-749">Jeśli biblioteka i aplikacja ThreadX została skompilowana przy użyciu zdefiniowanych **TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO** , ThreadX gromadzi poniższe informacje.</span><span class="sxs-lookup"><span data-stu-id="00e57-749">If the ThreadX library and application is built with **TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="00e57-750">Łączna liczba dla całego systemu:</span><span class="sxs-lookup"><span data-stu-id="00e57-750">Total number for the overall system:</span></span>

  - <span data-ttu-id="00e57-751">Zestawy flag zdarzeń</span><span class="sxs-lookup"><span data-stu-id="00e57-751">event flags sets</span></span>

  - <span data-ttu-id="00e57-752">flagi zdarzeń są pobierane</span><span class="sxs-lookup"><span data-stu-id="00e57-752">event flags gets</span></span>

  - <span data-ttu-id="00e57-753">flagi zdarzeń pobieranie zawieszeń</span><span class="sxs-lookup"><span data-stu-id="00e57-753">event flags get suspensions</span></span>

  - <span data-ttu-id="00e57-754">flagi zdarzeń pobierają limity czasu</span><span class="sxs-lookup"><span data-stu-id="00e57-754">event flags get timeouts</span></span>

<span data-ttu-id="00e57-755">Łączna liczba dla każdej grupy flag zdarzeń:</span><span class="sxs-lookup"><span data-stu-id="00e57-755">Total number for each event flags group:</span></span>

  - <span data-ttu-id="00e57-756">Zestawy flag zdarzeń</span><span class="sxs-lookup"><span data-stu-id="00e57-756">event flags sets</span></span>

  - <span data-ttu-id="00e57-757">flagi zdarzeń są pobierane</span><span class="sxs-lookup"><span data-stu-id="00e57-757">event flags gets</span></span>

  - <span data-ttu-id="00e57-758">flagi zdarzeń pobieranie zawieszeń</span><span class="sxs-lookup"><span data-stu-id="00e57-758">event flags get suspensions</span></span>

  - <span data-ttu-id="00e57-759">flagi zdarzeń pobierają limity czasu</span><span class="sxs-lookup"><span data-stu-id="00e57-759">event flags get timeouts</span></span>

<span data-ttu-id="00e57-760">Te informacje są dostępne w czasie wykonywania za pomocą usług ***tx_event_flags_performance_info_get** _ i _*_tx_event_flags_performance_system_info_get_\*_.</span><span class="sxs-lookup"><span data-stu-id="00e57-760">This information is available at run-time through the services ***tx_event_flags_performance_info_get** _ and _*_tx_event_flags_performance_system_info_get_\*_.</span></span> <span data-ttu-id="00e57-761">Informacje o wydajności flag zdarzeń są przydatne w ustaleniu, czy aplikacja działa prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="00e57-761">The performance information of event flags is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="00e57-762">Jest on również przydatny do optymalizowania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-762">It is also useful in optimizing the application.</span></span> <span data-ttu-id="00e57-763">Na przykład stosunkowo duża liczba przekroczeń limitu czasu w usłudze _ *_tx_event_flags_get_*\* może sugerować, że limit czasu zawieszenia flag zdarzeń jest za krótki.</span><span class="sxs-lookup"><span data-stu-id="00e57-763">For example, a relatively high number of timeouts on the _ *_tx_event_flags_get_*\* service might suggest that the event flags suspension timeout is too short.</span></span>

### <a name="event-flags-group-control-block-tx_event_flags_group"></a><span data-ttu-id="00e57-764">Flagi zdarzeń grupuje blok sterowania TX_EVENT_FLAGS_GROUP</span><span class="sxs-lookup"><span data-stu-id="00e57-764">Event Flags Group Control Block TX_EVENT_FLAGS_GROUP</span></span>

<span data-ttu-id="00e57-765">Właściwości każdej grupy flag zdarzeń znajdują się w bloku sterowania.</span><span class="sxs-lookup"><span data-stu-id="00e57-765">The characteristics of each event flags group are found in its control block.</span></span> <span data-ttu-id="00e57-766">Zawiera informacje takie jak bieżące ustawienia flag zdarzeń oraz liczbę wątków zawieszonych dla zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="00e57-766">It contains information such as the current event flags settings and the number of threads suspended for events.</span></span> <span data-ttu-id="00e57-767">Ta struktura jest zdefiniowana w pliku ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-767">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="00e57-768">Bloki sterujące grupą zdarzeń mogą znajdować się w dowolnym miejscu w pamięci, ale najczęściej jest to, że formant blokuje strukturę globalną przez definiowanie jej poza zakresem dowolnej funkcji.</span><span class="sxs-lookup"><span data-stu-id="00e57-768">Event group control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="memory-block-pools"></a><span data-ttu-id="00e57-769">Pule bloków pamięci</span><span class="sxs-lookup"><span data-stu-id="00e57-769">Memory Block Pools</span></span>

<span data-ttu-id="00e57-770">Przydzielanie pamięci w sposób szybki i deterministyczny jest zawsze wyzwaniem w aplikacjach w czasie rzeczywistym.</span><span class="sxs-lookup"><span data-stu-id="00e57-770">Allocating memory in a fast and deterministic manner is always a challenge in real-time applications.</span></span> <span data-ttu-id="00e57-771">Z tego względu ThreadX zapewnia możliwość tworzenia wielu pul bloków pamięci o stałym rozmiarze i zarządzania nimi.</span><span class="sxs-lookup"><span data-stu-id="00e57-771">With this in mind, ThreadX provides the ability to create and manage multiple pools of fixed-size memory blocks.</span></span>

<span data-ttu-id="00e57-772">Ponieważ pule bloków pamięci składają się z bloków o stałym rozmiarze, nigdy nie występują żadne problemy z fragmentacją.</span><span class="sxs-lookup"><span data-stu-id="00e57-772">Because memory block pools consist of fixed-size blocks, there are never any fragmentation problems.</span></span> <span data-ttu-id="00e57-773">Oczywiście fragmentacja powoduje, że zachowanie, które jest niedeterministyczne.</span><span class="sxs-lookup"><span data-stu-id="00e57-773">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span> <span data-ttu-id="00e57-774">Ponadto czas wymagany do przydzielenia i zwolnienia bloku pamięci o ustalonym rozmiarze jest porównywalny z tym, że proste manipulowanie listą.</span><span class="sxs-lookup"><span data-stu-id="00e57-774">In addition, the time required to allocate and free a fixed-size memory block is comparable to that of simple linked-list manipulation.</span></span> <span data-ttu-id="00e57-775">Ponadto alokacja bloku pamięci i cofnięcie alokacji są wykonywane na końcu listy dostępnych.</span><span class="sxs-lookup"><span data-stu-id="00e57-775">Furthermore, memory block allocation and de-allocation is done at the head of the available list.</span></span> <span data-ttu-id="00e57-776">Zapewnia to najszybszy możliwy do przetwarzania listy połączonej i może pomóc zachować rzeczywisty blok pamięci w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="00e57-776">This provides the fastest possible linked list processing and might help keep the actual memory block in cache.</span></span>

<span data-ttu-id="00e57-777">Brak elastyczności jest główną wadą dla pul pamięci o stałym rozmiarze.</span><span class="sxs-lookup"><span data-stu-id="00e57-777">Lack of flexibility is the main drawback of fixed-size memory pools.</span></span> <span data-ttu-id="00e57-778">Rozmiar bloku puli musi być wystarczająco duży, aby obsługiwał najgorsze wymagania dotyczące pamięci dla swoich użytkowników.</span><span class="sxs-lookup"><span data-stu-id="00e57-778">The block size of a pool must be large enough to handle the worst case memory requirements of its users.</span></span> <span data-ttu-id="00e57-779">Oczywiście pamięć może być tracona, jeśli wiele żądań pamięci o różnych rozmiarach jest wykonywanych w tej samej puli.</span><span class="sxs-lookup"><span data-stu-id="00e57-779">Of course, memory may be wasted if many different size memory requests are made to the same pool.</span></span> <span data-ttu-id="00e57-780">Możliwe rozwiązanie polega na utworzeniu kilku różnych pul bloków pamięci, które zawierają różne rozmiary bloków pamięci.</span><span class="sxs-lookup"><span data-stu-id="00e57-780">A possible solution is to make several different memory block pools that contain different sized memory blocks.</span></span>

<span data-ttu-id="00e57-781">Każda pula bloków pamięci jest zasobem publicznym.</span><span class="sxs-lookup"><span data-stu-id="00e57-781">Each memory block pool is a public resource.</span></span> <span data-ttu-id="00e57-782">ThreadX nie ma żadnych ograniczeń dotyczących sposobu używania pul.</span><span class="sxs-lookup"><span data-stu-id="00e57-782">ThreadX places no constraints on how pools are used.</span></span>

### <a name="creating-memory-block-pools"></a><span data-ttu-id="00e57-783">Tworzenie pul bloków pamięci</span><span class="sxs-lookup"><span data-stu-id="00e57-783">Creating Memory Block Pools</span></span>

<span data-ttu-id="00e57-784">Pule bloków pamięci są tworzone podczas inicjacji lub w czasie wykonywania przez wątki aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-784">Memory block pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="00e57-785">Nie ma limitu liczby pul bloków pamięci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-785">There is no limit on the number of memory block pools in an application.</span></span>

### <a name="memory-block-size"></a><span data-ttu-id="00e57-786">Rozmiar bloku pamięci</span><span class="sxs-lookup"><span data-stu-id="00e57-786">Memory Block Size</span></span>

<span data-ttu-id="00e57-787">Jak wspomniano wcześniej, pule bloków pamięci zawierają wiele bloków o stałym rozmiarze.</span><span class="sxs-lookup"><span data-stu-id="00e57-787">As mentioned earlier, memory block pools contain a number of fixed-size blocks.</span></span> <span data-ttu-id="00e57-788">Rozmiar bloku (w bajtach) jest określany podczas tworzenia puli.</span><span class="sxs-lookup"><span data-stu-id="00e57-788">The block size, in bytes, is specified during creation of the pool.</span></span>

> [!NOTE]
> <span data-ttu-id="00e57-789">*ThreadX dodaje niewielki nakład pracy — rozmiar wskaźnika C — do każdego bloku pamięci w puli. Ponadto ThreadX może być konieczne uzupełnienie rozmiaru bloku, aby zachować początek każdego bloku pamięci na odpowiednim wyrównaniu.*</span><span class="sxs-lookup"><span data-stu-id="00e57-789">*ThreadX adds a small amount of overhead—the size of a C pointer—to each memory block in the pool. In addition, ThreadX might have to pad the block size to keep the beginning of each memory block on proper alignment.*</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="00e57-790">Pojemność puli</span><span class="sxs-lookup"><span data-stu-id="00e57-790">Pool Capacity</span></span>

<span data-ttu-id="00e57-791">Liczba bloków pamięci w puli jest funkcją rozmiaru bloku i łączną liczbę bajtów w obszarze pamięci dostarczonym podczas tworzenia.</span><span class="sxs-lookup"><span data-stu-id="00e57-791">The number of memory blocks in a pool is a function of the block size and the total number of bytes in the memory area supplied during creation.</span></span> <span data-ttu-id="00e57-792">Pojemność puli jest obliczana przez podzielenie rozmiaru bloku (włącznie z uzupełnieniem i wskaźnikiem bajtów) do całkowitej liczby bajtów w podanym obszarze pamięci.</span><span class="sxs-lookup"><span data-stu-id="00e57-792">The capacity of a pool is calculated by dividing the block size (including padding and the pointer overhead bytes) into the total number of bytes in the supplied memory area.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="00e57-793">Obszar pamięci puli</span><span class="sxs-lookup"><span data-stu-id="00e57-793">Pool's Memory Area</span></span>

<span data-ttu-id="00e57-794">Jak wspomniano wcześniej, obszar pamięci dla puli bloków jest określany podczas tworzenia.</span><span class="sxs-lookup"><span data-stu-id="00e57-794">As mentioned before, the memory area for the block pool is specified during creation.</span></span> <span data-ttu-id="00e57-795">Podobnie jak w przypadku innych obszarów pamięci w ThreadX, może ona znajdować się w dowolnym miejscu w przestrzeni adresowej docelowej.</span><span class="sxs-lookup"><span data-stu-id="00e57-795">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span>

<span data-ttu-id="00e57-796">Jest to ważna funkcja ze względu na znaczną elastyczność, którą zapewnia.</span><span class="sxs-lookup"><span data-stu-id="00e57-796">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="00e57-797">Załóżmy na przykład, że produkt komunikacyjny ma obszar pamięci HighSpeed dla operacji we/wy.</span><span class="sxs-lookup"><span data-stu-id="00e57-797">For example, suppose that a communication product has a highspeed memory area for I/O.</span></span> <span data-ttu-id="00e57-798">Ten obszar pamięci jest łatwo zarządzany przez umieszczenie go w puli bloków pamięci ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-798">This memory area is easily managed by making it into a ThreadX memory block pool.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="00e57-799">Zawieszenie wątku</span><span class="sxs-lookup"><span data-stu-id="00e57-799">Thread Suspension</span></span>

<span data-ttu-id="00e57-800">Wątki aplikacji mogą wstrzymywać się podczas oczekiwania na blok pamięci z pustej puli.</span><span class="sxs-lookup"><span data-stu-id="00e57-800">Application threads can suspend while waiting for a memory block from an empty pool.</span></span> <span data-ttu-id="00e57-801">Gdy blok jest zwracany do puli, zawieszony wątek otrzymuje ten blok, a wątek zostaje wznowiony.</span><span class="sxs-lookup"><span data-stu-id="00e57-801">When a block is returned to the pool, the suspended thread is given this block and the thread is resumed.</span></span>

<span data-ttu-id="00e57-802">Jeśli wiele wątków jest zawieszonych w tej samej puli bloków pamięci, zostaną wznowione w kolejności, w której zostały wstrzymane (FIFO).</span><span class="sxs-lookup"><span data-stu-id="00e57-802">If multiple threads are suspended on the same memory block pool, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="00e57-803">Jednak możliwość wznowienia priorytetu jest również możliwa, jeśli aplikacja wywołuje ***tx_block_pool_prioritize*** przed wywołaniem bloku zwalniania wątku Wind.</span><span class="sxs-lookup"><span data-stu-id="00e57-803">However, priority resumption is also possible if the application calls ***tx_block_pool_prioritize*** prior to the block release call that lifts thread suspension.</span></span> <span data-ttu-id="00e57-804">Usługa Blocking Pool priorytetyzacja powoduje umieszczenie wątku o najwyższym priorytecie na początku listy zawieszania, pozostawiając wszystkie pozostałe zawieszone wątki w tej samej kolejności FIFO.</span><span class="sxs-lookup"><span data-stu-id="00e57-804">The block pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-block-pool-performance-information"></a><span data-ttu-id="00e57-805">Informacje o wydajności bloku blokowego czasu wykonywania</span><span class="sxs-lookup"><span data-stu-id="00e57-805">Run-time Block Pool Performance Information</span></span>

<span data-ttu-id="00e57-806">ThreadX zapewnia opcjonalne informacje o wydajności puli bloku czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="00e57-806">ThreadX provides optional run-time block pool performance information.</span></span> <span data-ttu-id="00e57-807">Jeśli biblioteka i aplikacja ThreadX została skompilowana przy użyciu zdefiniowanych **TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO** , ThreadX gromadzi poniższe informacje.</span><span class="sxs-lookup"><span data-stu-id="00e57-807">If the ThreadX library and application is built with **TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="00e57-808">Łączna liczba dla całego systemu:</span><span class="sxs-lookup"><span data-stu-id="00e57-808">Total number for the overall system:</span></span>

  - <span data-ttu-id="00e57-809">przydzielono bloki</span><span class="sxs-lookup"><span data-stu-id="00e57-809">blocks allocated</span></span>

  - <span data-ttu-id="00e57-810">bloki wydane</span><span class="sxs-lookup"><span data-stu-id="00e57-810">blocks released</span></span>

  - <span data-ttu-id="00e57-811">zawieszenie alokacji</span><span class="sxs-lookup"><span data-stu-id="00e57-811">allocation suspensions</span></span>

  - <span data-ttu-id="00e57-812">limity czasu alokacji</span><span class="sxs-lookup"><span data-stu-id="00e57-812">allocation timeouts</span></span>

<span data-ttu-id="00e57-813">Łączna liczba dla każdej puli bloków:</span><span class="sxs-lookup"><span data-stu-id="00e57-813">Total number for each block pool:</span></span>

  - <span data-ttu-id="00e57-814">przydzielono bloki</span><span class="sxs-lookup"><span data-stu-id="00e57-814">blocks allocated</span></span>

  - <span data-ttu-id="00e57-815">bloki wydane</span><span class="sxs-lookup"><span data-stu-id="00e57-815">blocks released</span></span>

  - <span data-ttu-id="00e57-816">zawieszenie alokacji</span><span class="sxs-lookup"><span data-stu-id="00e57-816">allocation suspensions</span></span>

  - <span data-ttu-id="00e57-817">limity czasu alokacji</span><span class="sxs-lookup"><span data-stu-id="00e57-817">allocation timeouts</span></span>

<span data-ttu-id="00e57-818">Te informacje są dostępne w czasie wykonywania za pomocą usług \***tx_block_pool_performance_info_get** _ i _ *_tx_block_pool_performance_system_info_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="00e57-818">This information is available at run-time through the services ***tx_block_pool_performance_info_get** _ and _*_tx_block_pool_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="00e57-819">Informacje o wydajności puli bloku są przydatne podczas ustalania, czy aplikacja działa prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="00e57-819">Block pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="00e57-820">Jest on również przydatny do optymalizowania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-820">It is also useful in optimizing the application.</span></span> <span data-ttu-id="00e57-821">Na przykład stosunkowo wysoka liczba "zawieszeń alokacji" może sugerować, że Pula bloków jest za mała.</span><span class="sxs-lookup"><span data-stu-id="00e57-821">For example, a relatively high number of "allocation suspensions" might suggest that the block pool is too small.</span></span>

### <a name="memory-block-pool-control-block-tx_block_pool"></a><span data-ttu-id="00e57-822">Blok sterowania puli bloków pamięci TX_BLOCK_POOL</span><span class="sxs-lookup"><span data-stu-id="00e57-822">Memory Block Pool Control Block TX_BLOCK_POOL</span></span>

<span data-ttu-id="00e57-823">Charakterystyki każdej puli bloków pamięci znajdują się w bloku sterowania.</span><span class="sxs-lookup"><span data-stu-id="00e57-823">The characteristics of each memory block pool are found in its control block.</span></span> <span data-ttu-id="00e57-824">Zawiera informacje, takie jak liczba dostępnych bloków pamięci i rozmiar bloku puli pamięci.</span><span class="sxs-lookup"><span data-stu-id="00e57-824">It contains information such as the number of memory blocks available and the memory pool block size.</span></span> <span data-ttu-id="00e57-825">Ta struktura jest zdefiniowana w pliku ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-825">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="00e57-826">Bloki sterujące puli mogą znajdować się w dowolnym miejscu w pamięci, ale najczęściej jest to, że formant blokuje strukturę globalną poprzez definiowanie jej poza zakresem dowolnej funkcji.</span><span class="sxs-lookup"><span data-stu-id="00e57-826">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="00e57-827">Zastępowanie bloków pamięci</span><span class="sxs-lookup"><span data-stu-id="00e57-827">Overwriting Memory Blocks</span></span>

<span data-ttu-id="00e57-828">Ważne jest, aby upewnić się, że użytkownik przydzielony blok pamięci nie zapisuje poza granicami.</span><span class="sxs-lookup"><span data-stu-id="00e57-828">It is important to ensure that the user of an allocated memory block does not write outside its boundaries.</span></span> <span data-ttu-id="00e57-829">W takim przypadku uszkodzenie występuje w sąsiednim (zazwyczaj następnym) obszarze pamięci.</span><span class="sxs-lookup"><span data-stu-id="00e57-829">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="00e57-830">Wyniki są nieprzewidywalne i często krytyczne dla aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-830">The results are unpredictable and often fatal to the application.</span></span>

## <a name="memory-byte-pools"></a><span data-ttu-id="00e57-831">Pule bajtów pamięci</span><span class="sxs-lookup"><span data-stu-id="00e57-831">Memory Byte Pools</span></span>

<span data-ttu-id="00e57-832">Pule bajtów pamięci ThreadX są podobne do standardowej sterty języka C.</span><span class="sxs-lookup"><span data-stu-id="00e57-832">ThreadX memory byte pools are similar to a standard C heap.</span></span> <span data-ttu-id="00e57-833">W przeciwieństwie do standardowej sterty C, możliwe jest posiadanie wielu pul bajtów pamięci.</span><span class="sxs-lookup"><span data-stu-id="00e57-833">Unlike the standard C heap, it is possible to have multiple memory byte pools.</span></span> <span data-ttu-id="00e57-834">Ponadto wątki mogą wstrzymywać się w puli, dopóki żądana pamięć nie jest dostępna.</span><span class="sxs-lookup"><span data-stu-id="00e57-834">In addition, threads can suspend on a pool until the requested memory is available.</span></span>

<span data-ttu-id="00e57-835">Alokacje z pul bajtów pamięci są podobne do tradycyjnych \***malloc** _ wywołań, które obejmują ilość żądanej pamięci (w bajtach).</span><span class="sxs-lookup"><span data-stu-id="00e57-835">Allocations from memory byte pools are similar to traditional \***malloc** _ calls, which include the amount of memory desired (in bytes).</span></span> <span data-ttu-id="00e57-836">Pamięć jest przydzielna z puli w postaci, w której występuje _first. oznacza to, że jest używany pierwszy blok wolnej pamięci, który spełnia żądanie.</span><span class="sxs-lookup"><span data-stu-id="00e57-836">Memory is allocated from the pool in a _first-fit\* manner; i.e., the first free memory block that satisfies the request is used.</span></span> <span data-ttu-id="00e57-837">Nadmierna ilość pamięci z tego bloku jest konwertowana na nowy blok i umieszczana z powrotem na liście wolnej pamięci.</span><span class="sxs-lookup"><span data-stu-id="00e57-837">Excess memory from this block is converted into a new block and placed back in the free memory list.</span></span> <span data-ttu-id="00e57-838">Ten proces jest nazywany *fragmentacją*.</span><span class="sxs-lookup"><span data-stu-id="00e57-838">This process is called *fragmentation*.</span></span>

<span data-ttu-id="00e57-839">Sąsiadujące bloki wolnej pamięci są *scalane* podczas kolejnego wyszukiwania alokacji dla dużej ilości wolnego bloku pamięci.</span><span class="sxs-lookup"><span data-stu-id="00e57-839">Adjacent free memory blocks are *merged* together during a subsequent allocation search for a large enough free memory block.</span></span> <span data-ttu-id="00e57-840">Ten proces jest nazywany *defragmentacją*.</span><span class="sxs-lookup"><span data-stu-id="00e57-840">This process is called *defragmentation*.</span></span>

<span data-ttu-id="00e57-841">Każda pula bajtów pamięci jest zasobem publicznym.</span><span class="sxs-lookup"><span data-stu-id="00e57-841">Each memory byte pool is a public resource.</span></span> <span data-ttu-id="00e57-842">ThreadX nie ma żadnych ograniczeń dotyczących sposobu używania pul, z tą różnicą, że nie można wywoływać usług bajtów pamięci z procedury ISR.</span><span class="sxs-lookup"><span data-stu-id="00e57-842">ThreadX places no constraints on how pools are used, except that memory byte services cannot be called from ISRs.</span></span>

### <a name="creating-memory-byte-pools"></a><span data-ttu-id="00e57-843">Tworzenie pul bajtów pamięci</span><span class="sxs-lookup"><span data-stu-id="00e57-843">Creating Memory Byte Pools</span></span>

<span data-ttu-id="00e57-844">Pule bajtów pamięci są tworzone podczas inicjacji lub w czasie wykonywania przez wątki aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-844">Memory byte pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="00e57-845">Nie ma żadnego limitu liczby pul bajtów pamięci w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-845">There is no limit on the number of memory byte pools in an application.</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="00e57-846">Pojemność puli</span><span class="sxs-lookup"><span data-stu-id="00e57-846">Pool Capacity</span></span>

<span data-ttu-id="00e57-847">Liczba bajtów do przydzielenia w puli bajtów pamięci jest nieco mniejsza niż wartość określona podczas tworzenia.</span><span class="sxs-lookup"><span data-stu-id="00e57-847">The number of allocatable bytes in a memory byte pool is slightly less than what was specified during creation.</span></span> <span data-ttu-id="00e57-848">Wynika to z faktu, że zarządzanie obszarem wolnej pamięci wprowadza pewne obciążenie.</span><span class="sxs-lookup"><span data-stu-id="00e57-848">This is because management of the free memory area introduces some overhead.</span></span> <span data-ttu-id="00e57-849">Każdy blok wolnej pamięci w puli wymaga odpowiedniku dwóch wskaźników C w obciążeniu.</span><span class="sxs-lookup"><span data-stu-id="00e57-849">Each free memory block in the pool requires the equivalent of two C pointers of overhead.</span></span> <span data-ttu-id="00e57-850">Ponadto Pula jest tworzona z dwoma blokami, dużym bezpłatnym blokiem i niewielkim trwale przydzielonym blokiem na końcu obszaru pamięci.</span><span class="sxs-lookup"><span data-stu-id="00e57-850">In addition, the pool is created with two blocks, a large free block and a small permanently allocated block at the end of the memory area.</span></span> <span data-ttu-id="00e57-851">Ten przydzielony blok służy do poprawienia wydajności algorytmu alokacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-851">This allocated block is used to improve performance of the allocation algorithm.</span></span> <span data-ttu-id="00e57-852">Eliminuje to konieczność ciągłego sprawdzania pod kątem końca obszaru puli podczas scalania.</span><span class="sxs-lookup"><span data-stu-id="00e57-852">It eliminates the need to continuously check for the end of the pool area during merging.</span></span>

<span data-ttu-id="00e57-853">W czasie wykonywania ilość narzutów w puli zwykle rośnie.</span><span class="sxs-lookup"><span data-stu-id="00e57-853">During run-time, the amount of overhead in the pool typically increases.</span></span> <span data-ttu-id="00e57-854">Alokacje nieparzystej liczby bajtów są uzupełniane w celu zapewnienia prawidłowego wyrównania następnego bloku pamięci.</span><span class="sxs-lookup"><span data-stu-id="00e57-854">Allocations of an odd number of bytes are padded to ensure proper alignment of the next memory block.</span></span> <span data-ttu-id="00e57-855">Dodatkowo narzuty zwiększają się, ponieważ pula jest bardziej pofragmentowana.</span><span class="sxs-lookup"><span data-stu-id="00e57-855">In addition, overhead increases as the pool becomes more fragmented.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="00e57-856">Obszar pamięci puli</span><span class="sxs-lookup"><span data-stu-id="00e57-856">Pool's Memory Area</span></span>

<span data-ttu-id="00e57-857">Obszar pamięci dla puli bajtów pamięci jest określany podczas tworzenia.</span><span class="sxs-lookup"><span data-stu-id="00e57-857">The memory area for a memory byte pool is specified during creation.</span></span> <span data-ttu-id="00e57-858">Podobnie jak w przypadku innych obszarów pamięci w ThreadX, może ona znajdować się w dowolnym miejscu w przestrzeni adresowej docelowej.</span><span class="sxs-lookup"><span data-stu-id="00e57-858">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span> <span data-ttu-id="00e57-859">Jest to ważna funkcja ze względu na znaczną elastyczność, którą zapewnia.</span><span class="sxs-lookup"><span data-stu-id="00e57-859">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="00e57-860">Na przykład jeśli sprzęt docelowy ma obszar pamięci o dużej szybkości i obszar pamięci o małej szybkości, użytkownik może zarządzać alokacją pamięci dla obu obszarów, tworząc pulę w każdym z nich.</span><span class="sxs-lookup"><span data-stu-id="00e57-860">For example, if the target hardware has a high-speed memory area and a low-speed memory area, the user can manage memory allocation for both areas by creating a pool in each of them.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="00e57-861">Zawieszenie wątku</span><span class="sxs-lookup"><span data-stu-id="00e57-861">Thread Suspension</span></span>

<span data-ttu-id="00e57-862">Wątki aplikacji mogą wstrzymywać się podczas oczekiwania na bajty pamięci z puli.</span><span class="sxs-lookup"><span data-stu-id="00e57-862">Application threads can suspend while waiting for memory bytes from a pool.</span></span> <span data-ttu-id="00e57-863">Gdy dostępna jest wystarczająca ciągła pamięć, zawieszone wątki otrzymują żądaną pamięć, a wątki są wznawiane.</span><span class="sxs-lookup"><span data-stu-id="00e57-863">When sufficient contiguous memory becomes available, the suspended threads are given their requested memory and the threads are resumed.</span></span>

<span data-ttu-id="00e57-864">Jeśli wiele wątków jest zawieszonych w tej samej puli bajtów pamięci, zostanie określona pamięć (wznowiona) w kolejności, w jakiej zostały wstrzymane (FIFO).</span><span class="sxs-lookup"><span data-stu-id="00e57-864">If multiple threads are suspended on the same memory byte pool, they are given memory (resumed) in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="00e57-865">Jednak możliwość wznowienia priorytetu jest również możliwa, jeśli aplikacja wywołuje ***tx_byte_pool_prioritize*** przed wywołaniem zwolnienia bajtów, które zawieszania wątku Wind.</span><span class="sxs-lookup"><span data-stu-id="00e57-865">However, priority resumption is also possible if the application calls ***tx_byte_pool_prioritize*** prior to the byte release call that lifts thread suspension.</span></span> <span data-ttu-id="00e57-866">Priorytet puli bajtów Usługa umieszcza wątek o najwyższym priorytecie na początku listy zawieszania, pozostawiając wszystkie pozostałe zawieszone wątki w tej samej kolejności FIFO.</span><span class="sxs-lookup"><span data-stu-id="00e57-866">The byte pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-byte-pool-performance-information"></a><span data-ttu-id="00e57-867">Informacje o wydajności puli bajtów czasu wykonywania</span><span class="sxs-lookup"><span data-stu-id="00e57-867">Run-time Byte Pool Performance Information</span></span>

<span data-ttu-id="00e57-868">ThreadX zapewnia opcjonalne informacje o wydajności puli bajtów w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="00e57-868">ThreadX provides optional run-time byte pool performance information.</span></span> <span data-ttu-id="00e57-869">Jeśli biblioteka i aplikacja ThreadX została skompilowana przy użyciu zdefiniowanych ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** , ThreadX gromadzi poniższe informacje.</span><span class="sxs-lookup"><span data-stu-id="00e57-869">If the ThreadX library and application is built with ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="00e57-870">Łączna liczba dla całego systemu:</span><span class="sxs-lookup"><span data-stu-id="00e57-870">Total number for the overall system:</span></span>

  - <span data-ttu-id="00e57-871">alokacji</span><span class="sxs-lookup"><span data-stu-id="00e57-871">allocations</span></span>

  - <span data-ttu-id="00e57-872">wersje</span><span class="sxs-lookup"><span data-stu-id="00e57-872">releases</span></span>

  - <span data-ttu-id="00e57-873">fragmenty przeszukane</span><span class="sxs-lookup"><span data-stu-id="00e57-873">fragments searched</span></span>

  - <span data-ttu-id="00e57-874">fragmenty scalone</span><span class="sxs-lookup"><span data-stu-id="00e57-874">fragments merged</span></span>

  - <span data-ttu-id="00e57-875">utworzone fragmenty</span><span class="sxs-lookup"><span data-stu-id="00e57-875">fragments created</span></span>

  - <span data-ttu-id="00e57-876">zawieszenie alokacji</span><span class="sxs-lookup"><span data-stu-id="00e57-876">allocation suspensions</span></span>

  - <span data-ttu-id="00e57-877">limity czasu alokacji</span><span class="sxs-lookup"><span data-stu-id="00e57-877">allocation timeouts</span></span>

<span data-ttu-id="00e57-878">Łączna liczba dla każdej puli bajtów:</span><span class="sxs-lookup"><span data-stu-id="00e57-878">Total number for each byte pool:</span></span>

  - <span data-ttu-id="00e57-879">alokacji</span><span class="sxs-lookup"><span data-stu-id="00e57-879">allocations</span></span>

  - <span data-ttu-id="00e57-880">wersje</span><span class="sxs-lookup"><span data-stu-id="00e57-880">releases</span></span>

  - <span data-ttu-id="00e57-881">fragmenty przeszukane</span><span class="sxs-lookup"><span data-stu-id="00e57-881">fragments searched</span></span>

  - <span data-ttu-id="00e57-882">fragmenty scalone</span><span class="sxs-lookup"><span data-stu-id="00e57-882">fragments merged</span></span>

  - <span data-ttu-id="00e57-883">utworzone fragmenty</span><span class="sxs-lookup"><span data-stu-id="00e57-883">fragments created</span></span>

  - <span data-ttu-id="00e57-884">zawieszenie alokacji</span><span class="sxs-lookup"><span data-stu-id="00e57-884">allocation suspensions</span></span>

  - <span data-ttu-id="00e57-885">limity czasu alokacji</span><span class="sxs-lookup"><span data-stu-id="00e57-885">allocation timeouts</span></span>

<span data-ttu-id="00e57-886">Te informacje są dostępne w czasie wykonywania za pomocą usług \***tx_byte_pool_performance_info_get** _ i _ *_tx_byte_pool_performance_system_info_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="00e57-886">This information is available at run-time through the services ***tx_byte_pool_performance_info_get** _ and _*_tx_byte_pool_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="00e57-887">Informacje o wydajności puli bajtów są przydatne podczas ustalania, czy aplikacja działa prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="00e57-887">Byte pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="00e57-888">Jest on również przydatny do optymalizowania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-888">It is also useful in optimizing the application.</span></span> <span data-ttu-id="00e57-889">Na przykład stosunkowo wysoka liczba "zawieszeń alokacji" może sugerować, że Pula bajtów jest za mała.</span><span class="sxs-lookup"><span data-stu-id="00e57-889">For example, a relatively high number of "allocation suspensions" might suggest that the byte pool is too small.</span></span>

### <a name="memory-byte-pool-control-block-tx_byte_pool"></a><span data-ttu-id="00e57-890">Blok kontroli puli bajtów pamięci TX_BYTE_POOL</span><span class="sxs-lookup"><span data-stu-id="00e57-890">Memory Byte Pool Control Block TX_BYTE_POOL</span></span>

<span data-ttu-id="00e57-891">Charakterystyki każdej puli bajtów pamięci znajdują się w bloku sterowania.</span><span class="sxs-lookup"><span data-stu-id="00e57-891">The characteristics of each memory byte pool are found in its control block.</span></span> <span data-ttu-id="00e57-892">Zawiera użyteczne informacje, takie jak liczba bajtów dostępnych w puli.</span><span class="sxs-lookup"><span data-stu-id="00e57-892">It contains useful information such as the number of available bytes in the pool.</span></span> <span data-ttu-id="00e57-893">Ta struktura jest zdefiniowana w pliku ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-893">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="00e57-894">Bloki sterujące puli mogą znajdować się w dowolnym miejscu w pamięci, ale najczęściej jest to, że formant blokuje strukturę globalną poprzez definiowanie jej poza zakresem dowolnej funkcji.</span><span class="sxs-lookup"><span data-stu-id="00e57-894">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="nondeterministic-behavior"></a><span data-ttu-id="00e57-895">Zachowanie niedeterministyczne</span><span class="sxs-lookup"><span data-stu-id="00e57-895">Nondeterministic Behavior</span></span>

<span data-ttu-id="00e57-896">Chociaż pule bajtów pamięci zapewniają największą elastyczną alokację pamięci, mogą również mieć nieco niedeterministyczne zachowanie.</span><span class="sxs-lookup"><span data-stu-id="00e57-896">Although memory byte pools provide the most flexible memory allocation, they also suffer from somewhat nondeterministic behavior.</span></span> <span data-ttu-id="00e57-897">Na przykład Pula bajtów pamięci może mieć 2 000 bajtów pamięci, ale może nie być w stanie spełnić żądania alokacji o 1 000 bajtów.</span><span class="sxs-lookup"><span data-stu-id="00e57-897">For example, a memory byte pool may have 2,000 bytes of memory available but may not be able to satisfy an allocation request of 1,000 bytes.</span></span> <span data-ttu-id="00e57-898">Wynika to z faktu, że liczba wolnych bajtów jest ciągła.</span><span class="sxs-lookup"><span data-stu-id="00e57-898">This is because there are no guarantees on how many of the free bytes are contiguous.</span></span> <span data-ttu-id="00e57-899">Nawet jeśli istnieje blok o numerze 1 000 bajtów, nie ma żadnych gwarancji dotyczących czasu, w którym może upłynąć, aby znaleźć blok.</span><span class="sxs-lookup"><span data-stu-id="00e57-899">Even if a 1,000 byte free block exists, there are no guarantees on how long it might take to find the block.</span></span> <span data-ttu-id="00e57-900">W całości jest możliwe, że cała pula pamięci będzie musiała zostać przeszukana w celu znalezienia bloku bajtów 1 000.</span><span class="sxs-lookup"><span data-stu-id="00e57-900">It is completely possible that the entire memory pool would need to be searched to find the 1,000 byte block.</span></span>

> [!TIP]
> <span data-ttu-id="00e57-901">*W wyniku niedeterministycznych zachowań pul bajtów pamięci zwykle warto unikać używania usług bajtów pamięci w obszarach, w których jest wymagane jednoznaczne zachowanie w czasie rzeczywistym. Wiele aplikacji wstępnie przydzieli wymaganą pamięć w czasie inicjalizacji lub konfiguracji czasu wykonywania.*</span><span class="sxs-lookup"><span data-stu-id="00e57-901">*As a result of the nondeterministic behavior of memory byte pools, it is generally good practice to avoid using memory byte services in areas where deterministic, real-time behavior is required. Many applications pre-allocate their required memory during initialization or run-time configuration.*</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="00e57-902">Zastępowanie bloków pamięci</span><span class="sxs-lookup"><span data-stu-id="00e57-902">Overwriting Memory Blocks</span></span>

<span data-ttu-id="00e57-903">Ważne jest, aby upewnić się, że użytkownik przydzieloną pamięć nie zapisuje poza granicami.</span><span class="sxs-lookup"><span data-stu-id="00e57-903">It is important to ensure that the user of allocated memory does not write outside its boundaries.</span></span> <span data-ttu-id="00e57-904">W takim przypadku uszkodzenie występuje w sąsiednim (zazwyczaj następnym) obszarze pamięci.</span><span class="sxs-lookup"><span data-stu-id="00e57-904">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="00e57-905">Wyniki są nieprzewidywalne i często występujące w wyniku wykonywania programu.</span><span class="sxs-lookup"><span data-stu-id="00e57-905">The results are unpredictable and often catastrophic for program execution.</span></span>

## <a name="application-timers"></a><span data-ttu-id="00e57-906">Czasomierze aplikacji</span><span class="sxs-lookup"><span data-stu-id="00e57-906">Application Timers</span></span>

<span data-ttu-id="00e57-907">Szybka odpowiedź na asynchroniczne zdarzenia zewnętrzne to najważniejsze funkcje aplikacji osadzonych w czasie rzeczywistym.</span><span class="sxs-lookup"><span data-stu-id="00e57-907">Fast response to asynchronous external events is the most important function of real-time, embedded applications.</span></span> <span data-ttu-id="00e57-908">Jednak wiele z tych aplikacji musi również wykonywać pewne działania w ustalonych odstępach czasu.</span><span class="sxs-lookup"><span data-stu-id="00e57-908">However, many of these applications must also perform certain activities at predetermined intervals of time.</span></span>

<span data-ttu-id="00e57-909">Czasomierze aplikacji ThreadX zapewniają aplikacjom możliwość wykonywania funkcji C w określonych odstępach czasu.</span><span class="sxs-lookup"><span data-stu-id="00e57-909">ThreadX application timers provide applications with the ability to execute application C functions at specific intervals of time.</span></span> <span data-ttu-id="00e57-910">Istnieje również możliwość wygaśnięcia czasomierza aplikacji tylko raz.</span><span class="sxs-lookup"><span data-stu-id="00e57-910">It is also possible for an application timer to expire only once.</span></span> <span data-ttu-id="00e57-911">Ten typ czasomierza jest nazywany *czasomierzem z jednym zrzutem*, podczas gdy powtarzające się czasomierze interwału są określane jako *okresowe czasomierze*.</span><span class="sxs-lookup"><span data-stu-id="00e57-911">This type of timer is called a *one-shot timer*, while repeating interval timers are called *periodic timers*.</span></span>

<span data-ttu-id="00e57-912">Każdy czasomierz aplikacji jest zasobem publicznym.</span><span class="sxs-lookup"><span data-stu-id="00e57-912">Each application timer is a public resource.</span></span> <span data-ttu-id="00e57-913">ThreadX nie ma żadnych ograniczeń dotyczących sposobu używania czasomierzy aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-913">ThreadX places no constraints on how application timers are used.</span></span>

### <a name="timer-intervals"></a><span data-ttu-id="00e57-914">Interwały czasomierza</span><span class="sxs-lookup"><span data-stu-id="00e57-914">Timer Intervals</span></span>

<span data-ttu-id="00e57-915">Interwały czasu ThreadX są mierzone przez okresowe przerwania czasomierza.</span><span class="sxs-lookup"><span data-stu-id="00e57-915">In ThreadX time intervals are measured by periodic timer interrupts.</span></span> <span data-ttu-id="00e57-916">Każdy przerwa czasomierza jest nazywany *cyklem* czasomierza.</span><span class="sxs-lookup"><span data-stu-id="00e57-916">Each timer interrupt is called a timer *tick*.</span></span> <span data-ttu-id="00e57-917">Rzeczywisty czas między taktami czasomierza jest określany przez aplikację, ale 10 MS jest normą dla większości implementacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-917">The actual time between timer ticks is specified by the application, but 10ms is the norm for most implementations.</span></span> <span data-ttu-id="00e57-918">Konfiguracja czasomierza okresowego zazwyczaj znajduje się w pliku zestawu ***tx_initialize_low_level*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-918">The periodic timer setup is typically found in the ***tx_initialize_low_level*** assembly file.</span></span>

<span data-ttu-id="00e57-919">Warto zauważyć, że podstawowy sprzęt musi mieć możliwość generowania okresowych przerwań dla czasomierzy aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-919">It is worth mentioning that the underlying hardware must have the ability to generate periodic interrupts for application timers to function.</span></span> <span data-ttu-id="00e57-920">W niektórych przypadkach procesor ma wbudowaną funkcję okresowego przerwania.</span><span class="sxs-lookup"><span data-stu-id="00e57-920">In some cases, the processor has a built-in periodic interrupt capability.</span></span> <span data-ttu-id="00e57-921">Jeśli procesor nie ma takiej możliwości, tablica użytkownika musi mieć urządzenie peryferyjne, które może generować okresowe przerwania.</span><span class="sxs-lookup"><span data-stu-id="00e57-921">If the processor doesn't have this ability, the user's board must have a peripheral device that can generate periodic interrupts.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="00e57-922">*ThreadX może nadal działać nawet bez okresowego źródła przerwań. Jednak wszystkie przetwarzanie związane z czasomierzem jest następnie wyłączone. Obejmuje to timeslicing, czas zawieszenia i usługi czasomierza.*</span><span class="sxs-lookup"><span data-stu-id="00e57-922">*ThreadX can still function even without a periodic interrupt source. However, all timer-related processing is then disabled. This includes timeslicing, suspension time-outs, and timer services.*</span></span>

### <a name="timer-accuracy"></a><span data-ttu-id="00e57-923">Dokładność czasomierza</span><span class="sxs-lookup"><span data-stu-id="00e57-923">Timer Accuracy</span></span>

<span data-ttu-id="00e57-924">Czas wygaśnięcia czasomierza jest określany w warunkach taktów.</span><span class="sxs-lookup"><span data-stu-id="00e57-924">Timer expirations are specified in terms of ticks.</span></span> <span data-ttu-id="00e57-925">Określona wartość wygaśnięcia jest zmniejszana o jeden w każdym taktie czasomierza.</span><span class="sxs-lookup"><span data-stu-id="00e57-925">The specified expiration value is decreased by one on each timer tick.</span></span> <span data-ttu-id="00e57-926">Ponieważ czasomierz aplikacji może być włączony tuż przed przerwaniem czasomierza (lub cyklem czasomierza), rzeczywisty czas wygaśnięcia może być wcześniejszy niż jeden cykl.</span><span class="sxs-lookup"><span data-stu-id="00e57-926">Because an application timer could be enabled just prior to a timer interrupt (or timer tick), the actual expiration time could be up to one tick early.</span></span>

<span data-ttu-id="00e57-927">Jeśli częstotliwość taktu czasomierza to 10 ms, czasomierze aplikacji mogą wygasnąć do 10 ms wczesnej.</span><span class="sxs-lookup"><span data-stu-id="00e57-927">If the timer tick rate is 10ms, application timers may expire up to 10ms early.</span></span> <span data-ttu-id="00e57-928">Jest to bardziej znaczące w przypadku czasomierzy 10 ms niż 1 sekunda czasomierza.</span><span class="sxs-lookup"><span data-stu-id="00e57-928">This is more significant for 10ms timers than 1 second timers.</span></span> <span data-ttu-id="00e57-929">Oczywiście zwiększenie częstotliwości przerwań czasomierza zmniejsza ten margines błędu.</span><span class="sxs-lookup"><span data-stu-id="00e57-929">Of course, increasing the timer interrupt frequency decreases this margin of error.</span></span>

### <a name="timer-execution"></a><span data-ttu-id="00e57-930">Wykonywanie czasomierza</span><span class="sxs-lookup"><span data-stu-id="00e57-930">Timer Execution</span></span>

<span data-ttu-id="00e57-931">Czasomierze aplikacji są wykonywane w kolejności, w jakiej stają się aktywne.</span><span class="sxs-lookup"><span data-stu-id="00e57-931">Application timers execute in the order they become active.</span></span> <span data-ttu-id="00e57-932">Na przykład jeśli trzy czasomierze są tworzone z tą samą wartością wygaśnięcia i aktywowane, odpowiednie funkcje wygasania są gwarantowane w kolejności, w jakiej zostały aktywowane.</span><span class="sxs-lookup"><span data-stu-id="00e57-932">For example, if three timers are created with the same expiration value and activated, their corresponding expiration functions are guaranteed to execute in the order they were activated.</span></span>

### <a name="creating-application-timers"></a><span data-ttu-id="00e57-933">Tworzenie czasomierzy aplikacji</span><span class="sxs-lookup"><span data-stu-id="00e57-933">Creating Application Timers</span></span>

<span data-ttu-id="00e57-934">Czasomierze aplikacji są tworzone podczas inicjacji lub w czasie wykonywania przez wątki aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-934">Application timers are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="00e57-935">Nie ma limitu liczby czasomierzy aplikacji w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-935">There is no limit on the number of application timers in an application.</span></span>

### <a name="run-time-application-timer-performance-information"></a><span data-ttu-id="00e57-936">Informacje o wydajności czasomierza aplikacji czasu wykonywania</span><span class="sxs-lookup"><span data-stu-id="00e57-936">Run-time Application Timer Performance Information</span></span>

<span data-ttu-id="00e57-937">ThreadX zapewnia opcjonalne informacje o wydajności czasomierza aplikacji czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="00e57-937">ThreadX provides optional run-time application timer performance information.</span></span> <span data-ttu-id="00e57-938">Jeśli biblioteka i aplikacja ThreadX zostały skompilowane przy użyciu zdefiniowanych **TX_TIMER_ENABLE_PERFORMANCE_INFO** , ThreadX gromadzi poniższe informacje.</span><span class="sxs-lookup"><span data-stu-id="00e57-938">If the ThreadX library and application are built with **TX_TIMER_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="00e57-939">Łączna liczba dla całego systemu:</span><span class="sxs-lookup"><span data-stu-id="00e57-939">Total number for the overall system:</span></span>

- <span data-ttu-id="00e57-940">aktywacji</span><span class="sxs-lookup"><span data-stu-id="00e57-940">activations</span></span>

- <span data-ttu-id="00e57-941">dezaktywacje</span><span class="sxs-lookup"><span data-stu-id="00e57-941">deactivations</span></span>

- <span data-ttu-id="00e57-942">ponowne aktywacje (okresowe czasomierze)</span><span class="sxs-lookup"><span data-stu-id="00e57-942">reactivations (periodic timers)</span></span>

- <span data-ttu-id="00e57-943">wygaśnięcia</span><span class="sxs-lookup"><span data-stu-id="00e57-943">expirations</span></span>

- <span data-ttu-id="00e57-944">Korekta wygaśnięcia</span><span class="sxs-lookup"><span data-stu-id="00e57-944">expiration adjustments</span></span>

<span data-ttu-id="00e57-945">Łączna liczba dla każdego czasomierza aplikacji:</span><span class="sxs-lookup"><span data-stu-id="00e57-945">Total number for each application timer:</span></span>

- <span data-ttu-id="00e57-946">aktywacji</span><span class="sxs-lookup"><span data-stu-id="00e57-946">activations</span></span>

- <span data-ttu-id="00e57-947">dezaktywacje</span><span class="sxs-lookup"><span data-stu-id="00e57-947">deactivations</span></span>

- <span data-ttu-id="00e57-948">ponowne aktywacje (okresowe czasomierze)</span><span class="sxs-lookup"><span data-stu-id="00e57-948">reactivations (periodic timers)</span></span>

- <span data-ttu-id="00e57-949">wygaśnięcia</span><span class="sxs-lookup"><span data-stu-id="00e57-949">expirations</span></span>

- <span data-ttu-id="00e57-950">Korekta wygaśnięcia</span><span class="sxs-lookup"><span data-stu-id="00e57-950">expiration adjustments</span></span>

<span data-ttu-id="00e57-951">Te informacje są dostępne w czasie wykonywania za pomocą usług \***tx_timer_performance_info_get** _ i _ *_tx_timer_performance_system_info_get_* \*.</span><span class="sxs-lookup"><span data-stu-id="00e57-951">This information is available at run-time through the services ***tx_timer_performance_info_get** _ and _*_tx_timer_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="00e57-952">Informacje o wydajności czasomierza aplikacji są przydatne w ustaleniu, czy aplikacja działa prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="00e57-952">Application Timer performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="00e57-953">Jest on również przydatny do optymalizowania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-953">It is also useful in optimizing the application.</span></span>

### <a name="application-timer-control-block-tx_timer"></a><span data-ttu-id="00e57-954">Blok sterowania czasomierzem aplikacji TX_TIMER</span><span class="sxs-lookup"><span data-stu-id="00e57-954">Application Timer Control Block TX_TIMER</span></span>

<span data-ttu-id="00e57-955">Charakterystyka każdego czasomierza aplikacji znajduje się w jego bloku sterowania.</span><span class="sxs-lookup"><span data-stu-id="00e57-955">The characteristics of each application timer are found in its control block.</span></span> <span data-ttu-id="00e57-956">Zawiera ona przydatne informacje, takie jak 32-bitowe wartości identyfikacyjne wygaśnięcia.</span><span class="sxs-lookup"><span data-stu-id="00e57-956">It contains useful information such as the 32-bit expiration identification value.</span></span> <span data-ttu-id="00e57-957">Ta struktura jest zdefiniowana w pliku ***tx_api. h*** .</span><span class="sxs-lookup"><span data-stu-id="00e57-957">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="00e57-958">Bloki sterujące czasomierzem aplikacji mogą znajdować się w dowolnym miejscu w pamięci, ale najczęściej jest to, że formant blokuje strukturę globalną przez definiowanie jej poza zakresem dowolnej funkcji.</span><span class="sxs-lookup"><span data-stu-id="00e57-958">Application timer control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="excessive-timers"></a><span data-ttu-id="00e57-959">Nadmierne czasomierze</span><span class="sxs-lookup"><span data-stu-id="00e57-959">Excessive Timers</span></span>

<span data-ttu-id="00e57-960">Domyślnie czasomierze aplikacji są wykonywane z ukrytego wątku systemowego, który działa z priorytetem zero, który jest zazwyczaj wyższy niż dowolny wątek aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-960">By default, application timers execute from within a hidden system thread that runs at priority zero, which is typically higher than any application thread.</span></span> <span data-ttu-id="00e57-961">Z tego powodu przetwarzanie wewnątrz czasomierzy aplikacji powinno być ograniczone do minimum.</span><span class="sxs-lookup"><span data-stu-id="00e57-961">Because of this, processing inside application timers should be kept to a minimum.</span></span>

<span data-ttu-id="00e57-962">Ważne jest również, aby uniknąć czasomierzy, który wygasa każdy cykl czasomierza.</span><span class="sxs-lookup"><span data-stu-id="00e57-962">It is also important to avoid, whenever possible, timers that expire every timer tick.</span></span> <span data-ttu-id="00e57-963">Takie sytuacje mogą powodować nadmierne obciążenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="00e57-963">Such a situation might induce excessive overhead in the application.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="00e57-964">*Jak wspomniano wcześniej, czasomierze aplikacji są wykonywane z ukrytego wątku systemowego. W związku z tym ważne jest, aby nie wybierać zawieszenia dla dowolnych wywołań usługi ThreadX wykonanych z funkcji wygaśnięcia czasomierza aplikacji.*</span><span class="sxs-lookup"><span data-stu-id="00e57-964">*As mentioned previously, application timers are executed from a hidden system thread. It is, therefore, important not to select suspension on any ThreadX service calls made from within the application timer's expiration function.*</span></span>

## <a name="relative-time"></a><span data-ttu-id="00e57-965">Czas względny</span><span class="sxs-lookup"><span data-stu-id="00e57-965">Relative Time</span></span>

<span data-ttu-id="00e57-966">Oprócz czasomierzy aplikacji wymienionych wcześniej ThreadX zapewnia jeden ciągły przyrost licznika 32-bitowego.</span><span class="sxs-lookup"><span data-stu-id="00e57-966">In addition to the application timers mentioned previously, ThreadX provides a single continuously incrementing 32-bit tick counter.</span></span> <span data-ttu-id="00e57-967">Licznik lub *czas* jest zwiększany o jeden w każdym przerwaniu czasomierza.</span><span class="sxs-lookup"><span data-stu-id="00e57-967">The tick counter or *time* is increased by one on each timer interrupt.</span></span>

<span data-ttu-id="00e57-968">Aplikacja może odczytywać lub ustawiać Ten licznik 32-bitowy przez wywołania do \***tx_time_get** _ i _ *_tx_time_set_* \*, odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="00e57-968">The application can read or set this 32-bit counter through calls to ***tx_time_get** _ and _*_tx_time_set_\*\*, respectively.</span></span> <span data-ttu-id="00e57-969">Użycie tego licznika jest całkowicie określane przez aplikację.</span><span class="sxs-lookup"><span data-stu-id="00e57-969">The use of this tick counter is determined completely by the application.</span></span> <span data-ttu-id="00e57-970">Nie jest on używany wewnętrznie przez ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-970">It is not used internally by ThreadX.</span></span>

## <a name="interrupts"></a><span data-ttu-id="00e57-971">Przerwań</span><span class="sxs-lookup"><span data-stu-id="00e57-971">Interrupts</span></span>

<span data-ttu-id="00e57-972">Szybka odpowiedź na zdarzenia asynchroniczne to główna funkcja aplikacji osadzonych w czasie rzeczywistym.</span><span class="sxs-lookup"><span data-stu-id="00e57-972">Fast response to asynchronous events is the principal function of real-time, embedded applications.</span></span> <span data-ttu-id="00e57-973">Aplikacja wie, że takie zdarzenie jest obecne za pomocą przerwań sprzętowych.</span><span class="sxs-lookup"><span data-stu-id="00e57-973">The application knows such an event is present through hardware interrupts.</span></span>

<span data-ttu-id="00e57-974">Przerwanie to asynchroniczna zmiana w wykonywaniu procesora.</span><span class="sxs-lookup"><span data-stu-id="00e57-974">An interrupt is an asynchronous change in processor execution.</span></span> <span data-ttu-id="00e57-975">Zwykle, gdy wystąpi przerwanie, procesor *przerwań* zapisuje niewielką część bieżącego wykonania na stosie i przenosi formant do odpowiedniego wektora przerwań.</span><span class="sxs-lookup"><span data-stu-id="00e57-975">Typically, when an interrupt occurs, the *Interrupts* processor saves a small portion of the current execution on the stack and transfers control to the appropriate interrupt vector.</span></span> <span data-ttu-id="00e57-976">Wektor przerwania jest w zasadzie tylko adresem procedury odpowiedzialnej za obsługę określonego przerwania typu.</span><span class="sxs-lookup"><span data-stu-id="00e57-976">The interrupt vector is basically just the address of the routine responsible for handling the specific type interrupt.</span></span> <span data-ttu-id="00e57-977">Dokładna procedura obsługi przerwania jest zależna od procesora.</span><span class="sxs-lookup"><span data-stu-id="00e57-977">The exact interrupt handling procedure is processor specific.</span></span>

### <a name="interrupt-control"></a><span data-ttu-id="00e57-978">Kontrola przerwania</span><span class="sxs-lookup"><span data-stu-id="00e57-978">Interrupt Control</span></span>

<span data-ttu-id="00e57-979">Usługa ***tx_interrupt_control*** umożliwia aplikacjom Włączanie i wyłączanie przerwań.</span><span class="sxs-lookup"><span data-stu-id="00e57-979">The ***tx_interrupt_control*** service allows applications to enable and disable interrupts.</span></span> <span data-ttu-id="00e57-980">Ta usługa zwróci poprzednią wartość Enable/Disable stan.</span><span class="sxs-lookup"><span data-stu-id="00e57-980">The previous interrupt enable/disable posture is returned by this service.</span></span> <span data-ttu-id="00e57-981">Należy zauważyć, że kontrola przerwania ma wpływ tylko na aktualnie wykonywany segment programu.</span><span class="sxs-lookup"><span data-stu-id="00e57-981">It is important to mention that interrupt control only affects the currently executing program segment.</span></span> <span data-ttu-id="00e57-982">Na przykład jeśli wątek wyłącza przerwania, zostaną one wyłączone tylko podczas wykonywania tego wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-982">For example, if a thread disables interrupts, they only remain disabled during execution of that thread.</span></span>

> [!NOTE]
> <span data-ttu-id="00e57-983">*Przerwanie z maską (NMI) to przerwanie, które nie może zostać wyłączone przez sprzęt. Takie przerwanie może być używane przez aplikacje ThreadX. Jednak procedura obsługi NMI aplikacji nie może używać funkcji zarządzania kontekstem ThreadX ani żadnych usług API.*</span><span class="sxs-lookup"><span data-stu-id="00e57-983">*A Non-Maskable Interrupt (NMI) is an interrupt that cannot be disabled by the hardware. Such an interrupt may be used by ThreadX applications. However, the application's NMI handling routine is not allowed to use ThreadX context management or any API services.*</span></span>

### <a name="threadx-managed-interrupts"></a><span data-ttu-id="00e57-984">ThreadX zarządzane przerwania</span><span class="sxs-lookup"><span data-stu-id="00e57-984">ThreadX Managed Interrupts</span></span>

<span data-ttu-id="00e57-985">ThreadX udostępnia aplikacje z kompletnym zarządzaniem przerwami.</span><span class="sxs-lookup"><span data-stu-id="00e57-985">ThreadX provides applications with complete interrupt management.</span></span> <span data-ttu-id="00e57-986">To zarządzanie obejmuje zapisanie i przywrócenie kontekstu przerwanego wykonania.</span><span class="sxs-lookup"><span data-stu-id="00e57-986">This management includes saving and restoring the context of the interrupted execution.</span></span> <span data-ttu-id="00e57-987">Ponadto ThreadX umożliwia wywoływanie niektórych usług z poziomu procedur usługi przerwania (procedury ISR).</span><span class="sxs-lookup"><span data-stu-id="00e57-987">In addition, ThreadX allows certain services to be called from within Interrupt Service Routines (ISRs).</span></span> <span data-ttu-id="00e57-988">Poniżej znajduje się lista usług ThreadX Services, które są dozwolone w aplikacji procedury ISR.</span><span class="sxs-lookup"><span data-stu-id="00e57-988">The following is a list of ThreadX services allowed from application ISRs.</span></span>

```c
tx_block_allocate
tx_block_pool_info_get tx_block_pool_prioritize
tx_block_pool_performance_info_get
tx_block_pool_performance_system_info_get tx_block_release
tx_byte_pool_info_get tx_byte_pool_performance_info_get
tx_byte_pool_performance_system_info_get
tx_byte_pool_prioritize tx_event_flags_info_get
tx_event_flags_get tx_event_flags_set
tx_event_flags_performance_info_get
tx_event_flags_performance_system_info_get
tx_event_flags_set_notify tx_interrupt_control
tx_mutex_performance_info_get
tx_mutex_performance_system_info_get tx_queue_front_send
tx_queue_info_get tx_queue_performance_info_get
tx_queue_performance_system_info_get tx_queue_prioritize
tx_queue_receive tx_queue_send tx_semaphore_get
tx_queue_send_notify tx_semaphore_ceiling_put
tx_semaphore_info_get tx_semaphore_performance_info_get
tx_semaphore_performance_system_info_get
tx_semaphore_prioritize tx_semaphore_put tx_thread_identify
tx_semaphore_put_notify tx_thread_entry_exit_notify
tx_thread_info_get tx_thread_resume
tx_thread_performance_info_get
tx_thread_performance_system_info_get
tx_thread_stack_error_notify tx_thread_wait_abort tx_time_get
tx_time_set tx_timer_activate tx_timer_change
tx_timer_deactivate tx_timer_info_get
tx_timer_performance_info_get
tx_timer_performance_system_info_get
```

> [!IMPORTANT]
> <span data-ttu-id="00e57-989">*Zawieszenie nie jest dozwolone z procedury ISR. W związku z tym, parametr **WAIT_OPTION** dla wszystkich wywołań usługi ThreadX wykonanych z procedury ISR musi być ustawiony na **TX_NO_WAIT**.*</span><span class="sxs-lookup"><span data-stu-id="00e57-989">*Suspension is not allowed from ISRs. Therefore, the **wait_option** parameter for all ThreadX service calls made from an ISR must be set to **TX_NO_WAIT**.*</span></span>

### <a name="isr-template"></a><span data-ttu-id="00e57-990">Szablon ISR</span><span class="sxs-lookup"><span data-stu-id="00e57-990">ISR Template</span></span>

<span data-ttu-id="00e57-991">Aby zarządzać przerwami aplikacji, należy wywołać kilka narzędzi ThreadX na początku i na końcu aplikacji procedury ISR.</span><span class="sxs-lookup"><span data-stu-id="00e57-991">To manage application interrupts, several ThreadX utilities must be called in the beginning and end of application ISRs.</span></span> <span data-ttu-id="00e57-992">Dokładny format obsługi przerwań zależy od portów.</span><span class="sxs-lookup"><span data-stu-id="00e57-992">The exact format for interrupt handling varies between ports.</span></span>

<span data-ttu-id="00e57-993">Następujący mały segment kodu jest typowy dla większości ThreadX zarządzanych procedury ISR.</span><span class="sxs-lookup"><span data-stu-id="00e57-993">The following small code segment is typical of most ThreadX managed ISRs.</span></span> <span data-ttu-id="00e57-994">W większości przypadków to przetwarzanie jest w języku asemblera.</span><span class="sxs-lookup"><span data-stu-id="00e57-994">In most cases, this processing is in assembly language.</span></span>

```c
_application_ISR_vector_entry:

; Save context and prepare for

; ThreadX use by calling the ISR

; entry function.

CALL _tx_thread_context_save

; The ISR can now call ThreadX

; services and its own C functions

; When the ISR is finished, context

; is restored (or thread preemption)

; by calling the context restore ; function. Control does not return!

JUMP _tx_thread_context_restore
```

### <a name="high-frequency-interrupts"></a><span data-ttu-id="00e57-995">Przerwania o wysokiej częstotliwości</span><span class="sxs-lookup"><span data-stu-id="00e57-995">High-frequency Interrupts</span></span>

<span data-ttu-id="00e57-996">Niektóre przerwania są wykonywane z taką dużą częstotliwością, że zapis i przywrócenie pełnego kontekstu dla każdego przerwania zużywa nadmierną przepustowość przetwarzania.</span><span class="sxs-lookup"><span data-stu-id="00e57-996">Some interrupts occur at such a high frequency that saving and restoring full context upon each interrupt would consume excessive processing bandwidth.</span></span> <span data-ttu-id="00e57-997">W takich przypadkach często aplikacja ma mały język zestawu procedur ISR, który wykonuje ograniczoną ilość przetwarzania dla większości przerwań o wysokiej częstotliwości.</span><span class="sxs-lookup"><span data-stu-id="00e57-997">In such cases, it is common for the application to have a small assembly language ISR that does a limited amount of processing for a majority of these high-frequency interrupts.</span></span>

<span data-ttu-id="00e57-998">Od pewnego momentu małe procedury ISR mogą wymagać współpracy z ThreadX.</span><span class="sxs-lookup"><span data-stu-id="00e57-998">After a certain point in time, the small ISR may need to interact with ThreadX.</span></span> <span data-ttu-id="00e57-999">Jest to realizowane przez wywołanie funkcji wejścia i wyjścia opisanych w powyższym szablonie.</span><span class="sxs-lookup"><span data-stu-id="00e57-999">This is accomplished by calling the entry and exit functions described in the above template.</span></span>

### <a name="interrupt-latency"></a><span data-ttu-id="00e57-1000">Opóźnienie przerwania</span><span class="sxs-lookup"><span data-stu-id="00e57-1000">Interrupt Latency</span></span>

<span data-ttu-id="00e57-1001">ThreadX blokuje przerwania w krótkim okresie czasu.</span><span class="sxs-lookup"><span data-stu-id="00e57-1001">ThreadX locks out interrupts over brief periods of time.</span></span> <span data-ttu-id="00e57-1002">Maksymalna liczba przerwań czasu jest wyłączona w kolejności czasu wymaganej do zapisania lub przywrócenia kontekstu wątku.</span><span class="sxs-lookup"><span data-stu-id="00e57-1002">The maximum amount of time interrupts are disabled is on the order of the time required to save or restore a thread's context.</span></span>
